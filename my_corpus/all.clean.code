from threading import local
import warnings
from django . conf import settings
from django . core import signals
from django . core . cache . backends . base import ( InvalidCacheBackendError , CacheKeyWarning , BaseCache )
from django . core . exceptions import ImproperlyConfigured
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . module _ loading import import _ string
_ _ all _ _ = &#91; &apos; get _ cache &apos; , &apos; cache &apos; , &apos; DEFAULT _ CACHE _ ALIAS &apos; , &apos; InvalidCacheBackendError &apos; , &apos; CacheKeyWarning &apos; , &apos; BaseCache &apos; , &#93;
default _ CACHE _ ALIAS = &apos; default&apos;
if DEFAULT _ CACHE _ ALIAS not in settings . caches :
raise ImproperlyConfigured ( &quot; You must define a &apos; % s &apos; cache &quot; % DEFAULT _ CACHE _ ALIAS )
def get _ cache ( backend , * * kwargs ) :
warnings . warn ( &quot; &apos; get _ cache &apos; is deprecated in favor of &apos; caches &apos; . &quot; , RemovedInDjango19Warning , stacklevel = 2 )
cache = _ create _ cache ( backend , * * kwargs )
signals . request _ finished . connect ( cache . close )
return cache
def _ create _ cache ( backend , * * kwargs ) :
try :
try :
conf = settings . caches &#91; backend &#93;
except KeyError :
try :
import _ string ( backend )
except ImportError as e :
raise InvalidCacheBackendError ( &quot; Could not find backend &apos; % s &apos; : % s &quot; % ( backend , e ) )
location = kwargs . pop ( &apos; LOCATION &apos; , &apos; &apos; )
params = kwargs
else :
params = conf . copy ( )
params . update ( kwargs )
backend = params . pop ( &apos; BACKEND &apos; )
location = params . pop ( &apos; LOCATION &apos; , &apos; &apos; )
backend _ cls = import _ string ( backend )
except ImportError as e :
raise InvalidCacheBackendError ( &quot; Could not find backend &apos; % s &apos; : % s &quot; % ( backend , e ) )
return backend _ cls ( location , params )
class CacheHandler ( object ) :
def _ _ init _ _ ( self ) :
self . _ caches = local ( )
def _ _ getitem _ _ ( self , alias ) :
try :
return self . _ caches . caches &#91; alias &#93;
except AttributeError :
self . _ caches . caches = { }
except KeyError :
pass
if alias not in settings . caches :
raise InvalidCacheBackendError ( &quot; Could not find config for &apos; % s &apos; in settings.CACHES &quot; % alias )
cache = _ create _ cache ( alias )
self . _ caches . caches &#91; alias &#93; = cache
return cache
def all ( self ) :
return getattr ( self . _ caches , &apos; caches &apos; , { } ) . values ( )
caches = CacheHandler ( )
class DefaultCacheProxy ( object ) :
def _ _ getattr _ _ ( self , name ) :
return getattr ( caches &#91; DEFAULT _ CACHE _ ALIAS &#93; , name )
def _ _ setattr _ _ ( self , name , value ) :
return setattr ( caches &#91; DEFAULT _ CACHE _ ALIAS &#93; , name , value )
def _ _ delattr _ _ ( self , name ) :
return delattr ( caches &#91; DEFAULT _ CACHE _ ALIAS &#93; , name )
def _ _ contains _ _ ( self , key ) :
return key in caches &#91; DEFAULT _ CACHE _ ALIAS &#93;
def _ _ eq _ _ ( self , other ) :
return caches &#91; DEFAULT _ CACHE _ ALIAS &#93; = = other
def _ _ ne _ _ ( self , other ) :
return caches &#91; DEFAULT _ CACHE _ ALIAS &#93; ! = other
cache = DefaultCacheProxy ( )
def close _ caches ( * * kwargs ) :
for cache in caches . all ( ) :
cache . close ( )
signals . request _ finished . connect ( close _ caches )
from _ _ future _ _ import unicode _ literals
import time
import warnings
from django . core . exceptions import ImproperlyConfigured , DjangoRuntimeWarning
from django . utils . module _ loading import import _ string
class InvalidCacheBackendError ( ImproperlyConfigured ) :
pass
class CacheKeyWarning ( DjangoRuntimeWarning ) :
pass
default _ TIMEOUT = object ( )
memcache _ MAX _ KEY _ LENGTH = 250
def default _ key _ func ( key , key _ prefix , version ) :
return &apos; % s : % s : % s &apos; % ( key _ prefix , version , key )
def get _ key _ func ( key _ func ) :
if key _ func is not None :
if callable ( key _ func ) :
return key _ func
else :
return import _ string ( key _ func )
return default _ key _ func
class BaseCache ( object ) :
def _ _ init _ _ ( self , params ) :
timeout = params . get ( &apos; timeout &apos; , params . get ( &apos; TIMEOUT &apos; , 300 ) )
if timeout is not None :
try :
timeout = int ( timeout )
except ( ValueError , TypeError ) :
timeout = 300
self . default _ timeout = timeout
options = params . get ( &apos; OPTIONS &apos; , { } )
max _ entries = params . get ( &apos; max _ entries &apos; , options . get ( &apos; MAX _ ENTRIES &apos; , 300 ) )
try :
self . _ max _ entries = int ( max _ entries )
except ( ValueError , TypeError ) :
self . _ max _ entries = 300
cull _ frequency = params . get ( &apos; cull _ frequency &apos; , options . get ( &apos; CULL _ FREQUENCY &apos; , 3 ) )
try :
self . _ cull _ frequency = int ( cull _ frequency )
except ( ValueError , TypeError ) :
self . _ cull _ frequency = 3
self . key _ prefix = params . get ( &apos; KEY _ PREFIX &apos; , &apos; &apos; )
self . version = params . get ( &apos; VERSION &apos; , 1 )
self . key _ func = get _ key _ func ( params . get ( &apos; KEY _ FUNCTION &apos; , None ) )
def get _ backend _ timeout ( self , timeout = DEFAULT _ TIMEOUT ) :
if timeout = = DEFAULT _ TIMEOUT :
timeout = self . default _ timeout
elif timeout = = 0 :
timeout = - 1
return None if timeout is None else time . time ( ) + timeout
def make _ key ( self , key , version = None ) :
if version is None :
version = self . version
new _ key = self . key _ func ( key , self . key _ prefix , version )
return new _ key
def add ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
&quot; &quot; &quot; set a value in the cache if the key does not already exist . if timeout is given , that timeout will be used for the key ; otherwise the default cache timeout will be used . returns True if the value was stored , False otherwise . &quot; &quot; &quot;
raise NotImplementedError ( &apos; subclasses of BaseCache must provide an add ( ) method &apos; )
def get ( self , key , default = None , version = None ) :
raise NotImplementedError ( &apos; subclasses of BaseCache must provide a get ( ) method &apos; )
def set ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
raise NotImplementedError ( &apos; subclasses of BaseCache must provide a set ( ) method &apos; )
def delete ( self , key , version = None ) :
raise NotImplementedError ( &apos; subclasses of BaseCache must provide a delete ( ) method &apos; )
def get _ many ( self , keys , version = None ) :
d = { }
for k in keys :
val = self . get ( k , version = version )
if val is not None :
d &#91; k &#93; = val
return d
def has _ key ( self , key , version = None ) :
return self . get ( key , version = version ) is not None
def incr ( self , key , delta = 1 , version = None ) :
value = self . get ( key , version = version )
if value is None :
raise ValueError ( &quot; Key &apos; % s &apos; not found &quot; % key )
new _ value = value + delta
self . set ( key , new _ value , version = version )
return new _ value
def decr ( self , key , delta = 1 , version = None ) :
return self . incr ( key , - delta , version = version )
def _ _ contains _ _ ( self , key ) :
return self . has _ key ( key )
def set _ many ( self , data , timeout = DEFAULT _ TIMEOUT , version = None ) :
for key , value in data . items ( ) :
self . set ( key , value , timeout = timeout , version = version )
def delete _ many ( self , keys , version = None ) :
for key in keys :
self . delete ( key , version = version )
def clear ( self ) :
raise NotImplementedError ( &apos; subclasses of BaseCache must provide a clear ( ) method &apos; )
def validate _ key ( self , key ) :
if len ( key ) &gt; MEMCACHE _ MAX _ KEY _ LENGTH :
warnings . warn ( &apos; Cache key will cause errors if used with memcached : &apos; &apos; % s ( longer than % s ) &apos; % ( key , MEMCACHE _ MAX _ KEY _ LENGTH ) , CacheKeyWarning )
for char in key :
if ord ( char ) &lt; 33 or ord ( char ) = = 127 :
warnings . warn ( &apos; Cache key contains characters that will cause &apos; &apos; errors if used with memcached : % r &apos; % key , CacheKeyWarning )
def incr _ version ( self , key , delta = 1 , version = None ) :
if version is None :
version = self . version
value = self . get ( key , version = version )
if value is None :
raise ValueError ( &quot; Key &apos; % s &apos; not found &quot; % key )
self . set ( key , value , version = version + delta )
self . delete ( key , version = version )
return version + delta
def decr _ version ( self , key , delta = 1 , version = None ) :
return self . incr _ version ( key , - delta , version )
def close ( self , * * kwargs ) :
&quot; &quot; &quot; close the cache connection &quot; &quot; &quot;
pass
import base64
from datetime import datetime
try :
from django . utils . six . moves import cPickle as pickle
except ImportError :
import pickle
from django . conf import settings
from django . core . cache . backends . base import BaseCache , DEFAULT _ TIMEOUT
from django . db import connections , transaction , router , DatabaseError
from django . db . backends . utils import typecast _ timestamp
from django . utils import timezone , six
from django . utils . encoding import force _ bytes
class Options ( object ) :
def _ _ init _ _ ( self , table ) :
self . db _ table = table
self . app _ label = &apos; django _ cache&apos;
self . model _ name = &apos; cacheentry&apos;
self . verbose _ name = &apos; cache entry&apos;
self . verbose _ name _ plural = &apos; cache entries&apos;
self . object _ name = &apos; CacheEntry&apos;
self . abstract = False
self . managed = True
self . proxy = False
class BaseDatabaseCache ( BaseCache ) :
def _ _ init _ _ ( self , table , params ) :
BaseCache . _ _ init _ _ ( self , params )
self . _ table = table
class CacheEntry ( object ) :
_ meta = Options ( table )
self . cache _ model _ class = CacheEntry
class DatabaseCache ( BaseDatabaseCache ) :
def get ( self , key , default = None , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
db = router . db _ for _ read ( self . cache _ model _ class )
table = connections &#91; db &#93; . ops . quote _ name ( self . _ table )
with connections &#91; db &#93; . cursor ( ) as cursor :
cursor . execute ( &quot; SELECT cache _ key , value , expires FROM % s &quot; &quot; WHERE cache _ key = % % s &quot; % table , &#91; key &#93; )
row = cursor . fetchone ( )
if row is None :
return default
now = timezone . now ( )
expires = row &#91; 2 &#93;
if connections &#91; db &#93; . features . needs _ datetime _ string _ cast and not isinstance ( expires , datetime ) :
expires = typecast _ timestamp ( str ( expires ) )
if expires &lt; now :
db = router . db _ for _ write ( self . cache _ model _ class )
with connections &#91; db &#93; . cursor ( ) as cursor :
cursor . execute ( &quot; DELETE FROM % s &quot; &quot; WHERE cache _ key = % % s &quot; % table , &#91; key &#93; )
return default
value = connections &#91; db &#93; . ops . process _ clob ( row &#91; 1 &#93; )
return pickle . loads ( base64 . b64decode ( force _ bytes ( value ) ) )
def set ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
self . _ base _ set ( &apos; set &apos; , key , value , timeout )
def add ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
return self . _ base _ set ( &apos; add &apos; , key , value , timeout )
def _ base _ set ( self , mode , key , value , timeout = DEFAULT _ TIMEOUT ) :
timeout = self . get _ backend _ timeout ( timeout )
db = router . db _ for _ write ( self . cache _ model _ class )
table = connections &#91; db &#93; . ops . quote _ name ( self . _ table )
with connections &#91; db &#93; . cursor ( ) as cursor :
cursor . execute ( &quot; SELECT COUNT ( * ) FROM % s &quot; % table )
num = cursor . fetchone ( ) &#91; 0 &#93;
now = timezone . now ( )
now = now . replace ( microsecond = 0 )
if timeout is None :
exp = datetime . max
elif settings . use _ TZ :
exp = datetime . utcfromtimestamp ( timeout )
else :
exp = datetime . fromtimestamp ( timeout )
exp = exp . replace ( microsecond = 0 )
if num &gt; self . _ max _ entries :
self . _ cull ( db , cursor , now )
pickled = pickle . dumps ( value , pickle . HIGHEST _ PROTOCOL )
b64encoded = base64 . b64encode ( pickled )
if six . PY3 :
b64encoded = b64encoded . decode ( &apos; latin1 &apos; )
try :
with transaction . atomic ( using = db ) :
cursor . execute ( &quot; SELECT cache _ key , expires FROM % s &quot; &quot; WHERE cache _ key = % % s &quot; % table , &#91; key &#93; )
result = cursor . fetchone ( )
if result :
current _ expires = result &#91; 1 &#93;
if ( connections &#91; db &#93; . features . needs _ datetime _ string _ cast and not isinstance ( current _ expires , datetime ) ) :
current _ expires = typecast _ timestamp ( str ( current _ expires ) )
exp = connections &#91; db &#93; . ops . value _ to _ db _ datetime ( exp )
if result and ( mode = = &apos; set &apos; or ( mode = = &apos; add &apos; and current _ expires &lt; now ) ) :
cursor . execute ( &quot; UPDATE % s SET value = % % s , expires = % % s &quot; &quot; WHERE cache _ key = % % s &quot; % table , &#91; b64encoded , exp , key &#93; )
else :
cursor . execute ( &quot; INSERT INTO % s ( cache _ key , value , expires ) &quot; &quot; VALUES ( % % s , % % s , % % s ) &quot; % table , &#91; key , b64encoded , exp &#93; )
except DatabaseError :
return False
else :
return True
def delete ( self , key , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
db = router . db _ for _ write ( self . cache _ model _ class )
table = connections &#91; db &#93; . ops . quote _ name ( self . _ table )
with connections &#91; db &#93; . cursor ( ) as cursor :
cursor . execute ( &quot; DELETE FROM % s WHERE cache _ key = % % s &quot; % table , &#91; key &#93; )
def has _ key ( self , key , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
db = router . db _ for _ read ( self . cache _ model _ class )
table = connections &#91; db &#93; . ops . quote _ name ( self . _ table )
if settings . use _ TZ :
now = datetime . utcnow ( )
else :
now = datetime . now ( )
now = now . replace ( microsecond = 0 )
with connections &#91; db &#93; . cursor ( ) as cursor :
cursor . execute ( &quot; SELECT cache _ key FROM % s &quot; &quot; WHERE cache _ key = % % s and expires &gt; % % s &quot; % table , &#91; key , connections &#91; db &#93; . ops . value _ to _ db _ datetime ( now ) &#93; )
return cursor . fetchone ( ) is not None
def _ cull ( self , db , cursor , now ) :
if self . _ cull _ frequency = = 0 :
self . clear ( )
else :
now = now . replace ( tzinfo = None )
table = connections &#91; db &#93; . ops . quote _ name ( self . _ table )
cursor . execute ( &quot; DELETE FROM % s WHERE expires &lt; % % s &quot; % table , &#91; connections &#91; db &#93; . ops . value _ to _ db _ datetime ( now ) &#93; )
cursor . execute ( &quot; SELECT COUNT ( * ) FROM % s &quot; % table )
num = cursor . fetchone ( ) &#91; 0 &#93;
if num &gt; self . _ max _ entries :
cull _ num = num / / self . _ cull _ frequency
cursor . execute ( connections &#91; db &#93; . ops . cache _ key _ culling _ sql ( ) % table , &#91; cull _ num &#93; )
cursor . execute ( &quot; DELETE FROM % s &quot; &quot; WHERE cache _ key &lt; % % s &quot; % table , &#91; cursor . fetchone ( ) &#91; 0 &#93; &#93; )
def clear ( self ) :
db = router . db _ for _ write ( self . cache _ model _ class )
table = connections &#91; db &#93; . ops . quote _ name ( self . _ table )
with connections &#91; db &#93; . cursor ( ) as cursor :
cursor . execute ( &apos; DELETE FROM % s &apos; % table )
class CacheClass ( DatabaseCache ) :
pass
from django . core . cache . backends . base import BaseCache , DEFAULT _ TIMEOUT
class DummyCache ( BaseCache ) :
def _ _ init _ _ ( self , host , * args , * * kwargs ) :
BaseCache . _ _ init _ _ ( self , * args , * * kwargs )
def add ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
return True
def get ( self , key , default = None , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
return default
def set ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
def delete ( self , key , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
def get _ many ( self , keys , version = None ) :
return { }
def has _ key ( self , key , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
return False
def set _ many ( self , data , timeout = DEFAULT _ TIMEOUT , version = None ) :
pass
def delete _ many ( self , keys , version = None ) :
pass
def clear ( self ) :
pass
class CacheClass ( DummyCache ) :
pass
import errno
import glob
import hashlib
import io
import os
import random
import tempfile
import time
import zlib
from django . core . cache . backends . base import BaseCache , DEFAULT _ TIMEOUT
from django . core . files . move import file _ move _ safe
from django . utils . encoding import force _ bytes
try :
from django . utils . six . moves import cPickle as pickle
except ImportError :
import pickle
class FileBasedCache ( BaseCache ) :
cache _ suffix = &apos; .djcache&apos;
def _ _ init _ _ ( self , dir , params ) :
super ( FileBasedCache , self ) . _ _ init _ _ ( params )
self . _ dir = os . path . abspath ( dir )
self . _ createdir ( )
def add ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
if self . has _ key ( key , version ) :
return False
self . set ( key , value , timeout , version )
return True
def get ( self , key , default = None , version = None ) :
fname = self . _ key _ to _ file ( key , version )
if os . path . exists ( fname ) :
try :
with io . open ( fname , &apos; rb &apos; ) as f :
if not self . _ is _ expired ( f ) :
return pickle . loads ( zlib . decompress ( f . read ( ) ) )
except IOError as e :
if e . errno = = errno . ENOENT :
pass
return default
def set ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
self . _ createdir ( )
fname = self . _ key _ to _ file ( key , version )
self . _ cull ( )
fd , tmp _ path = tempfile . mkstemp ( dir = self . _ dir )
renamed = False
try :
with io . open ( fd , &apos; wb &apos; ) as f :
expiry = self . get _ backend _ timeout ( timeout )
f . write ( pickle . dumps ( expiry , - 1 ) )
f . write ( zlib . compress ( pickle . dumps ( value ) , - 1 ) )
file _ move _ safe ( tmp _ path , fname , allow _ overwrite = True )
renamed = True
finally :
if not renamed :
os . remove ( tmp _ path )
def delete ( self , key , version = None ) :
self . _ delete ( self . _ key _ to _ file ( key , version ) )
def _ delete ( self , fname ) :
if not fname . startswith ( self . _ dir ) or not os . path . exists ( fname ) :
return
try :
os . remove ( fname )
except OSError as e :
if e . errno ! = errno . ENOENT :
raise
def has _ key ( self , key , version = None ) :
fname = self . _ key _ to _ file ( key , version )
if os . path . exists ( fname ) :
with io . open ( fname , &apos; rb &apos; ) as f :
return not self . _ is _ expired ( f )
return False
def _ cull ( self ) :
filelist = self . _ list _ cache _ files ( )
num _ entries = len ( filelist )
if num _ entries &lt; self . _ max _ entries :
return
if self . _ cull _ frequency = = 0 :
return self . clear ( )
filelist = random . sample ( filelist , int ( num _ entries / self . _ cull _ frequency ) )
for fname in filelist :
self . _ delete ( fname )
def _ createdir ( self ) :
if not os . path . exists ( self . _ dir ) :
try :
os . makedirs ( self . _ dir , 0o700 )
except OSError as e :
if e . errno ! = errno . EEXIST :
raise EnvironmentError ( &quot; Cache directory &apos; % s &apos; does not exist &quot; &quot; and could not be created &apos; &quot; % self . _ dir )
def _ key _ to _ file ( self , key , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
return os . path . join ( self . _ dir , &apos; &apos; . join ( &#91; hashlib . md5 ( force _ bytes ( key ) ) . hexdigest ( ) , self . cache _ suffix &#93; ) )
def clear ( self ) :
if not os . path . exists ( self . _ dir ) :
return
for fname in self . _ list _ cache _ files ( ) :
self . _ delete ( fname )
def _ is _ expired ( self , f ) :
exp = pickle . load ( f )
if exp is not None and exp &lt; time . time ( ) :
f . close ( )
self . _ delete ( f . name )
return True
return False
def _ list _ cache _ files ( self ) :
if not os . path . exists ( self . _ dir ) :
return &#91; &#93;
filelist = &#91; os . path . join ( self . _ dir , fname ) for fname in glob . glob1 ( self . _ dir , &apos; * % s &apos; % self . cache _ suffix ) &#93;
return filelist
class CacheClass ( FileBasedCache ) :
pass
import time
try :
from django . utils . six . moves import cPickle as pickle
except ImportError :
import pickle
from django . core . cache . backends . base import BaseCache , DEFAULT _ TIMEOUT
from django . utils . synch import RWLock
_ caches = { }
_ expire _ info = { }
_ locks = { }
class LocMemCache ( BaseCache ) :
def _ _ init _ _ ( self , name , params ) :
BaseCache . _ _ init _ _ ( self , params )
self . _ cache = _ caches . setdefault ( name , { } )
self . _ expire _ info = _ expire _ info . setdefault ( name , { } )
self . _ lock = _ locks . setdefault ( name , RWLock ( ) )
def add ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
pickled = pickle . dumps ( value , pickle . HIGHEST _ PROTOCOL )
with self . _ lock . writer ( ) :
if self . _ has _ expired ( key ) :
self . _ set ( key , pickled , timeout )
return True
return False
def get ( self , key , default = None , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
pickled = None
with self . _ lock . reader ( ) :
if not self . _ has _ expired ( key ) :
pickled = self . _ cache &#91; key &#93;
if pickled is not None :
try :
return pickle . loads ( pickled )
except pickle . PickleError :
return default
with self . _ lock . writer ( ) :
try :
del self . _ cache &#91; key &#93;
del self . _ expire _ info &#91; key &#93;
except KeyError :
pass
return default
def _ set ( self , key , value , timeout = DEFAULT _ TIMEOUT ) :
if len ( self . _ cache ) &gt; = self . _ max _ entries :
self . _ cull ( )
self . _ cache &#91; key &#93; = value
self . _ expire _ info &#91; key &#93; = self . get _ backend _ timeout ( timeout )
def set ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
pickled = pickle . dumps ( value , pickle . HIGHEST _ PROTOCOL )
with self . _ lock . writer ( ) :
self . _ set ( key , pickled , timeout )
def incr ( self , key , delta = 1 , version = None ) :
value = self . get ( key , version = version )
if value is None :
raise ValueError ( &quot; Key &apos; % s &apos; not found &quot; % key )
new _ value = value + delta
key = self . make _ key ( key , version = version )
pickled = pickle . dumps ( new _ value , pickle . HIGHEST _ PROTOCOL )
with self . _ lock . writer ( ) :
self . _ cache &#91; key &#93; = pickled
return new _ value
def has _ key ( self , key , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
with self . _ lock . reader ( ) :
if not self . _ has _ expired ( key ) :
return True
with self . _ lock . writer ( ) :
try :
del self . _ cache &#91; key &#93;
del self . _ expire _ info &#91; key &#93;
except KeyError :
pass
return False
def _ has _ expired ( self , key ) :
exp = self . _ expire _ info . get ( key , - 1 )
if exp is None or exp &gt; time . time ( ) :
return False
return True
def _ cull ( self ) :
if self . _ cull _ frequency = = 0 :
self . clear ( )
else :
doomed = &#91; k for ( i , k ) in enumerate ( self . _ cache ) if i % self . _ cull _ frequency = = 0 &#93;
for k in doomed :
self . _ delete ( k )
def _ delete ( self , key ) :
try :
del self . _ cache &#91; key &#93;
except KeyError :
pass
try :
del self . _ expire _ info &#91; key &#93;
except KeyError :
pass
def delete ( self , key , version = None ) :
key = self . make _ key ( key , version = version )
self . validate _ key ( key )
with self . _ lock . writer ( ) :
self . _ delete ( key )
def clear ( self ) :
self . _ cache . clear ( )
self . _ expire _ info . clear ( )
class CacheClass ( LocMemCache ) :
pass
import time
import pickle
from django . core . cache . backends . base import BaseCache , DEFAULT _ TIMEOUT
from django . utils import six
from django . utils . deprecation import RenameMethodsBase , RemovedInDjango19Warning
from django . utils . encoding import force _ str
from django . utils . functional import cached _ property
class BaseMemcachedCacheMethods ( RenameMethodsBase ) :
renamed _ methods = ( ( &apos; _ get _ memcache _ timeout &apos; , &apos; get _ backend _ timeout &apos; , RemovedInDjango19Warning ) , )
class BaseMemcachedCache ( six . with _ metaclass ( BaseMemcachedCacheMethods , BaseCache ) ) :
def _ _ init _ _ ( self , server , params , library , value _ not _ found _ exception ) :
super ( BaseMemcachedCache , self ) . _ _ init _ _ ( params )
if isinstance ( server , six . string _ types ) :
self . _ servers = server . split ( &apos; ; &apos; )
else :
self . _ servers = server
self . LibraryValueNotFoundException = value _ not _ found _ exception
self . _ lib = library
self . _ options = params . get ( &apos; OPTIONS &apos; , None )
@ property
def _ cache ( self ) :
if getattr ( self , &apos; _ client &apos; , None ) is None :
self . _ client = self . _ lib . client ( self . _ servers )
return self . _ client
def get _ backend _ timeout ( self , timeout = DEFAULT _ TIMEOUT ) :
if timeout = = DEFAULT _ TIMEOUT :
timeout = self . default _ timeout
if timeout is None :
return 0
elif int ( timeout ) = = 0 :
timeout = - 1
if timeout &gt; 2592000 :
timeout + = int ( time . time ( ) )
return int ( timeout )
def make _ key ( self , key , version = None ) :
return force _ str ( super ( BaseMemcachedCache , self ) . make _ key ( key , version ) )
def add ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
key = self . make _ key ( key , version = version )
return self . _ cache . add ( key , value , self . get _ backend _ timeout ( timeout ) )
def get ( self , key , default = None , version = None ) :
key = self . make _ key ( key , version = version )
val = self . _ cache . get ( key )
if val is None :
return default
return val
def set ( self , key , value , timeout = DEFAULT _ TIMEOUT , version = None ) :
key = self . make _ key ( key , version = version )
self . _ cache . set ( key , value , self . get _ backend _ timeout ( timeout ) )
def delete ( self , key , version = None ) :
key = self . make _ key ( key , version = version )
self . _ cache . delete ( key )
def get _ many ( self , keys , version = None ) :
new _ keys = &#91; self . make _ key ( x , version = version ) for x in keys &#93;
ret = self . _ cache . get _ multi ( new _ keys )
if ret :
_ = { }
m = dict ( zip ( new _ keys , keys ) )
for k , v in ret . items ( ) :
_ &#91; m &#91; k &#93; &#93; = v
ret = _
return ret
def close ( self , * * kwargs ) :
self . _ cache . disconnect _ all ( )
def incr ( self , key , delta = 1 , version = None ) :
key = self . make _ key ( key , version = version )
if delta &lt; 0 :
return self . _ cache . decr ( key , - delta )
try :
val = self . _ cache . incr ( key , delta )
except self . LibraryValueNotFoundException :
val = None
if val is None :
raise ValueError ( &quot; Key &apos; % s &apos; not found &quot; % key )
return val
def decr ( self , key , delta = 1 , version = None ) :
key = self . make _ key ( key , version = version )
if delta &lt; 0 :
return self . _ cache . incr ( key , - delta )
try :
val = self . _ cache . decr ( key , delta )
except self . LibraryValueNotFoundException :
val = None
if val is None :
raise ValueError ( &quot; Key &apos; % s &apos; not found &quot; % key )
return val
def set _ many ( self , data , timeout = DEFAULT _ TIMEOUT , version = None ) :
safe _ data = { }
for key , value in data . items ( ) :
key = self . make _ key ( key , version = version )
safe _ data &#91; key &#93; = value
self . _ cache . set _ multi ( safe _ data , self . get _ backend _ timeout ( timeout ) )
def delete _ many ( self , keys , version = None ) :
l = lambda x : self . make _ key ( x , version = version )
self . _ cache . delete _ multi ( map ( l , keys ) )
def clear ( self ) :
self . _ cache . flush _ all ( )
class MemcachedCache ( BaseMemcachedCache ) :
def _ _ init _ _ ( self , server , params ) :
import memcache
super ( MemcachedCache , self ) . _ _ init _ _ ( server , params , library = memcache , value _ not _ found _ exception = ValueError )
@ property
def _ cache ( self ) :
if getattr ( self , &apos; _ client &apos; , None ) is None :
self . _ client = self . _ lib . client ( self . _ servers , pickleProtocol = pickle . HIGHEST _ PROTOCOL )
return self . _ client
class PyLibMCCache ( BaseMemcachedCache ) :
def _ _ init _ _ ( self , server , params ) :
import pylibmc
super ( PyLibMCCache , self ) . _ _ init _ _ ( server , params , library = pylibmc , value _ not _ found _ exception = pylibmc . NotFound )
@ cached _ property
def _ cache ( self ) :
client = self . _ lib . client ( self . _ servers )
if self . _ options :
client . behaviors = self . _ options
return client
from _ _ future _ _ import unicode _ literals
import hashlib
from django . utils . encoding import force _ bytes
from django . utils . http import urlquote
template _ FRAGMENT _ KEY _ TEMPLATE = &apos; template.cache. % s . % s&apos;
def make _ template _ fragment _ key ( fragment _ name , vary _ on = None ) :
if vary _ on is None :
vary _ on = ( )
key = &apos; : &apos; . join ( urlquote ( var ) for var in vary _ on )
args = hashlib . md5 ( force _ bytes ( key ) )
return TEMPLATE _ FRAGMENT _ KEY _ TEMPLATE % ( fragment _ name , args . hexdigest ( ) )
from _ _ future _ _ import unicode _ literals
from . messages import ( CheckMessage , Debug , Info , Warning , Error , Critical , DEBUG , INFO , WARNING , ERROR , CRITICAL )
from . registry import register , run _ checks , tag _ exists , Tags
import django . core . checks . compatibility . Django _ 1 _ 6 _ 0
import django . core . checks . compatibility . Django _ 1 _ 7 _ 0
import django . core . checks . model _ checks
_ _ all _ _ = &#91; &apos; CheckMessage &apos; , &apos; Debug &apos; , &apos; Info &apos; , &apos; Warning &apos; , &apos; Error &apos; , &apos; Critical &apos; , &apos; DEBUG &apos; , &apos; INFO &apos; , &apos; WARNING &apos; , &apos; ERROR &apos; , &apos; CRITICAL &apos; , &apos; register &apos; , &apos; run _ checks &apos; , &apos; tag _ exists &apos; , &apos; Tags &apos; , &#93;
from _ _ future _ _ import unicode _ literals
from django . apps import apps
from . . import Warning , register , Tags
@ register ( Tags . compatibility )
def check _ 1 _ 6 _ compatibility ( * * kwargs ) :
errors = &#91; &#93;
errors . extend ( _ check _ test _ runner ( * * kwargs ) )
errors . extend ( _ check _ boolean _ field _ default _ value ( * * kwargs ) )
return errors
def _ check _ test _ runner ( app _ configs = None , * * kwargs ) :
from django . conf import settings
weight = 0
if not settings . is _ overridden ( &apos; TEST _ RUNNER &apos; ) :
try :
settings . site _ ID
weight + = 2
except AttributeError :
pass
try :
settings . base _ DIR
except AttributeError :
weight + = 2
if settings . is _ overridden ( &apos; TEMPLATE _ LOADERS &apos; ) :
weight + = 2
if settings . is _ overridden ( &apos; MANAGERS &apos; ) :
weight + = 2
if settings . is _ overridden ( &apos; ADMINS &apos; ) :
weight + = 1
if &apos; django.middleware.clickjacking.XFrameOptionsMiddleware &apos; not in set ( settings . middleware _ CLASSES ) :
weight + = 1
if weight &gt; = 6 :
return &#91; Warning ( &quot; some project unittests may not execute as expected . &quot; , hint = ( &quot; Django 1.6 introduced a new default test runner . it looks like &quot; &quot; this project was generated using Django 1.5 or earlier . you should &quot; &quot; ensure your tests are all running &amp; behaving as expected . see &quot; &quot; https : / / docs.djangoproject.com / en / dev / releases / 1.6 / # new-test-runner &quot; &quot; for more information . &quot; ) , obj = None , id = &apos; 1 _ 6.W001 &apos; , ) &#93;
else :
return &#91; &#93;
def _ check _ boolean _ field _ default _ value ( app _ configs = None , * * kwargs ) :
from django . db import models
Problem _ fields = &#91; field for model in apps . get _ models ( * * kwargs ) if app _ configs is None or model . _ meta . app _ config in app _ configs for field in model . _ meta . local _ fields if isinstance ( field , models . BooleanField ) and not field . has _ default ( ) &#93;
return &#91; Warning ( &quot; BooleanField does not have a default value . &quot; , hint = ( &quot; Django 1.6 changed the default value of BooleanField from False to None . &quot; &quot; see https : / / docs.djangoproject.com / en / 1.6 / ref / models / fields / # BooleanField &quot; &quot; for more information . &quot; ) , obj = field , id = &apos; 1 _ 6.W002 &apos; , ) for field in problem _ fields &#93;
from _ _ future _ _ import unicode _ literals
from . . import Warning , register , Tags
@ register ( Tags . compatibility )
def check _ 1 _ 7 _ compatibility ( * * kwargs ) :
errors = &#91; &#93;
errors . extend ( _ check _ middleware _ classes ( * * kwargs ) )
return errors
def _ check _ middleware _ classes ( app _ configs = None , * * kwargs ) :
from django . conf import settings
if not settings . is _ overridden ( &apos; MIDDLEWARE _ CLASSES &apos; ) :
return &#91; Warning ( &quot; MIDDLEWARE _ CLASSES is not set . &quot; , hint = ( &quot; Django 1.7 changed the global defaults for the MIDDLEWARE _ CLASSES . &quot; &quot; django.contrib.sessions.middleware.SessionMiddleware , &quot; &quot; django.contrib.auth.middleware.AuthenticationMiddleware , and &quot; &quot; django.contrib.messages.middleware.MessageMiddleware were removed from the defaults . &quot; &quot; if your project needs these middleware then you should configure this setting . &quot; ) , obj = None , id = &apos; 1 _ 7.W001 &apos; , ) &#93;
else :
return &#91; &#93;
from _ _ future _ _ import unicode _ literals
from django . utils . encoding import python _ 2 _ unicode _ compatible , force _ str
DEBUG = 10
info = 20
warning = 30
error = 40
Critical = 50
@ python _ 2 _ unicode _ compatible
class CheckMessage ( object ) :
def _ _ init _ _ ( self , level , msg , hint = None , obj = None , id = None ) :
assert isinstance ( level , int ) , &quot; The first argument should be level . &quot;
self . level = level
self . msg = msg
self . hint = hint
self . obj = obj
self . id = id
def _ _ eq _ _ ( self , other ) :
return all ( getattr ( self , attr ) = = getattr ( other , attr ) for attr in &#91; &apos; level &apos; , &apos; msg &apos; , &apos; hint &apos; , &apos; obj &apos; , &apos; id &apos; &#93; )
def _ _ ne _ _ ( self , other ) :
return not ( self = = other )
def _ _ str _ _ ( self ) :
from django . db import models
if self . obj is None :
obj = &quot; ? &quot;
elif isinstance ( self . obj , models . base . ModelBase ) :
model = self . obj
app = model . _ meta . app _ label
obj = &apos; % s . % s &apos; % ( app , model . _ meta . object _ name )
else :
obj = force _ str ( self . obj )
id = &quot; ( % s ) &quot; % self . id if self . id else &quot; &quot;
hint = &quot; \ n \ tHINT : % s &quot; % self . hint if self . hint else &apos; &apos;
return &quot; % s : % s % s % s &quot; % ( obj , id , self . msg , hint )
def _ _ repr _ _ ( self ) :
return &quot; &lt; % s : level = % r , msg = % r , hint = % r , obj = % r , id = % r &gt; &quot; % ( self . _ _ class _ _ . _ _ name _ _ , self . level , self . msg , self . hint , self . obj , self . id )
def is _ serious ( self ) :
return self . level &gt; = ERROR
def is _ silenced ( self ) :
from django . conf import settings
return self . id in settings . silenced _ SYSTEM _ CHECKS
class Debug ( CheckMessage ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
return super ( Debug , self ) . _ _ init _ _ ( DEBUG , * args , * * kwargs )
class Info ( CheckMessage ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
return super ( Info , self ) . _ _ init _ _ ( INFO , * args , * * kwargs )
class Warning ( CheckMessage ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
return super ( Warning , self ) . _ _ init _ _ ( WARNING , * args , * * kwargs )
class Error ( CheckMessage ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
return super ( Error , self ) . _ _ init _ _ ( ERROR , * args , * * kwargs )
class Critical ( CheckMessage ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
return super ( Critical , self ) . _ _ init _ _ ( CRITICAL , * args , * * kwargs )
from _ _ future _ _ import unicode _ literals
from itertools import chain
import types
from django . apps import apps
from . import Error , Tags , register
@ register ( Tags . models )
def check _ all _ models ( app _ configs = None , * * kwargs ) :
errors = &#91; model . check ( * * kwargs ) for model in apps . get _ models ( ) if app _ configs is None or model . _ meta . app _ config in app _ configs &#93;
return list ( chain ( * errors ) )
@ register ( Tags . models , Tags . signals )
def check _ model _ signals ( app _ configs = None , * * kwargs ) :
from django . db import models
errors = &#91; &#93;
for name in dir ( models . signals ) :
obj = getattr ( models . signals , name )
if isinstance ( obj , models . signals . ModelSignal ) :
for reference , receivers in obj . unresolved _ references . items ( ) :
for receiver , _ , _ in receivers :
if isinstance ( receiver , types . FunctionType ) :
description = &quot; The &apos; % s &apos; function &quot; % receiver . _ _ name _ _
else :
description = &quot; An instance of the &apos; % s &apos; class &quot; % receiver . _ _ class _ _ . _ _ name _ _
errors . append ( Error ( &quot; % s was connected to the &apos; % s &apos; signal &quot; &quot; with a lazy reference to the &apos; % s &apos; sender , &quot; &quot; which has not been installed . &quot; % ( description , name , &apos; .&apos; . join ( reference ) ) , obj = receiver . _ _ module _ _ , hint = None , id = &apos; signals.E001 &apos; ) )
return errors
from _ _ future _ _ import unicode _ literals
from itertools import chain
from django . utils . itercompat import is _ iterable
class Tags ( object ) :
admin = &apos; admin&apos;
compatibility = &apos; compatibility&apos;
models = &apos; models&apos;
signals = &apos; signals&apos;
class CheckRegistry ( object ) :
def _ _ init _ _ ( self ) :
self . registered _ checks = &#91; &#93;
def register ( self , * tags ) :
def inner ( check ) :
check . tags = tags
if check not in self . registered _ checks :
self . registered _ checks . append ( check )
return check
return inner
def run _ checks ( self , app _ configs = None , tags = None ) :
errors = &#91; &#93;
if tags is not None :
checks = &#91; check for check in self . registered _ checks if hasattr ( check , &apos; tags &apos; ) and set ( check . tags ) &amp; set ( tags ) &#93;
else :
checks = self . registered _ checks
for check in checks :
new _ errors = check ( app _ configs = app _ configs )
assert is _ iterable ( new _ errors ) , ( &quot; The function % r did not return a list . all functions registered &quot; &quot; with the checks registry must return a list . &quot; % check )
errors . extend ( new _ errors )
return errors
def tag _ exists ( self , tag ) :
return tag in self . tags _ available ( )
def tags _ available ( self ) :
return set ( chain ( * &#91; check . tags for check in self . registered _ checks if hasattr ( check , &apos; tags &apos; ) &#93; ) )
registry = CheckRegistry ( )
register = registry . register
run _ checks = registry . run _ checks
tag _ exists = registry . tag _ exists
from _ _ future _ _ import unicode _ literals
from django . conf import settings
from django . middleware . csrf import get _ token
from django . utils import six
from django . utils . encoding import smart _ text
from django . utils . functional import lazy
def csrf ( request ) :
def _ get _ val ( ) :
token = get _ token ( request )
if token is None :
return &apos; NOTPROVIDED&apos;
else :
return smart _ text ( token )
_ get _ val = lazy ( _ get _ val , six . text _ type )
return { &apos; csrf _ token &apos; : _ get _ val ( ) }
def debug ( request ) :
context _ extras = { }
if settings . DEBUG and request . meta . get ( &apos; REMOTE _ ADDR &apos; ) in settings . internal _ IPS :
context _ extras &#91; &apos; debug &apos; &#93; = True
from django . db import connection
context _ extras &#91; &apos; sql _ queries &apos; &#93; = connection . queries
return context _ extras
def i18n ( request ) :
from django . utils import translation
context _ extras = { }
context _ extras &#91; &apos; LANGUAGES &apos; &#93; = settings . LANGUAGES
context _ extras &#91; &apos; LANGUAGE _ CODE &apos; &#93; = translation . get _ language ( )
context _ extras &#91; &apos; LANGUAGE _ BIDI &apos; &#93; = translation . get _ language _ bidi ( )
return context _ extras
def tz ( request ) :
from django . utils import timezone
return { &apos; TIME _ ZONE &apos; : timezone . get _ current _ timezone _ name ( ) }
def static ( request ) :
return { &apos; STATIC _ URL &apos; : settings . static _ URL }
def media ( request ) :
return { &apos; MEDIA _ URL &apos; : settings . media _ URL }
def request ( request ) :
return { &apos; request &apos; : request }
from functools import reduce
import operator
from django . utils import six
from django . utils . encoding import force _ text
class DjangoRuntimeWarning ( RuntimeWarning ) :
pass
class AppRegistryNotReady ( Exception ) :
pass
class ObjectDoesNotExist ( Exception ) :
silent _ variable _ failure = True
class MultipleObjectsReturned ( Exception ) :
pass
class SuspiciousOperation ( Exception ) :
class SuspiciousMultipartForm ( SuspiciousOperation ) :
pass
class SuspiciousFileOperation ( SuspiciousOperation ) :
pass
class DisallowedHost ( SuspiciousOperation ) :
pass
class DisallowedRedirect ( SuspiciousOperation ) :
pass
class PermissionDenied ( Exception ) :
pass
class ViewDoesNotExist ( Exception ) :
pass
class MiddlewareNotUsed ( Exception ) :
pass
class ImproperlyConfigured ( Exception ) :
pass
class FieldError ( Exception ) :
pass
non _ FIELD _ ERRORS = &apos; _ _ all _ _ &apos;
class ValidationError ( Exception ) :
def _ _ init _ _ ( self , message , code = None , params = None ) :
super ( ValidationError , self ) . _ _ init _ _ ( message , code , params )
if isinstance ( message , ValidationError ) :
if hasattr ( message , &apos; error _ dict &apos; ) :
message = message . error _ dict
elif not hasattr ( message , &apos; message &apos; if six . PY3 else &apos; code &apos; ) :
message = message . error _ list
else :
message , code , params = message . message , message . code , message . params
if isinstance ( message , dict ) :
self . error _ dict = { }
for field , messages in message . items ( ) :
if not isinstance ( messages , ValidationError ) :
messages = ValidationError ( messages )
self . error _ dict &#91; field &#93; = messages . error _ list
elif isinstance ( message , list ) :
self . error _ list = &#91; &#93;
for message in message :
if not isinstance ( message , ValidationError ) :
message = ValidationError ( message )
self . error _ list . extend ( message . error _ list )
else :
self . message = message
self . code = code
self . params = params
self . error _ list = &#91; self &#93;
@ property
def message _ dict ( self ) :
getattr ( self , &apos; error _ dict &apos; )
return dict ( self )
@ property
def messages ( self ) :
if hasattr ( self , &apos; error _ dict &apos; ) :
return reduce ( operator . add , dict ( self ) . values ( ) )
return list ( self )
def update _ error _ dict ( self , error _ dict ) :
if hasattr ( self , &apos; error _ dict &apos; ) :
for field , error _ list in self . error _ dict . items ( ) :
error _ dict . setdefault ( field , &#91; &#93; ) . extend ( error _ list )
else :
error _ dict . setdefault ( NON _ FIELD _ ERRORS , &#91; &#93; ) . extend ( self . error _ list )
return error _ dict
def _ _ iter _ _ ( self ) :
if hasattr ( self , &apos; error _ dict &apos; ) :
for field , errors in self . error _ dict . items ( ) :
yield field , list ( ValidationError ( errors ) )
else :
for error in self . error _ list :
message = error . message
if error . params :
message % = error . params
yield force _ text ( message )
def _ _ str _ _ ( self ) :
if hasattr ( self , &apos; error _ dict &apos; ) :
return repr ( dict ( self ) )
return repr ( list ( self ) )
def _ _ repr _ _ ( self ) :
return &apos; ValidationError ( % s ) &apos; % self
from django . core . files . base import File
_ _ all _ _ = &#91; &apos; File &apos; &#93;
from _ _ future _ _ import unicode _ literals
import os
from io import BytesIO , StringIO , UnsupportedOperation
from django . utils . encoding import smart _ text
from django . core . files . utils import FileProxyMixin
from django . utils import six
from django . utils . encoding import force _ bytes , python _ 2 _ unicode _ compatible
@ python _ 2 _ unicode _ compatible
class File ( FileProxyMixin ) :
default _ CHUNK _ SIZE = 64 * 2 * * 10
def _ _ init _ _ ( self , file , name = None ) :
self . file = file
if name is None :
name = getattr ( file , &apos; name &apos; , None )
self . name = name
if hasattr ( file , &apos; mode &apos; ) :
self . mode = file . mode
def _ _ str _ _ ( self ) :
return smart _ text ( self . name or &apos; &apos; )
def _ _ repr _ _ ( self ) :
return &quot; &lt; % s : % s &gt; &quot; % ( self . _ _ class _ _ . _ _ name _ _ , self or &quot; None &quot; )
def _ _ bool _ _ ( self ) :
return bool ( self . name )
def _ _ nonzero _ _ ( self ) :
return type ( self ) . _ _ bool _ _ ( self )
def _ _ len _ _ ( self ) :
return self . size
def _ get _ size _ from _ underlying _ file ( self ) :
if hasattr ( self . file , &apos; size &apos; ) :
return self . file . size
if hasattr ( self . file , &apos; name &apos; ) :
try :
return os . path . getsize ( self . file . name )
except ( OSError , TypeError ) :
pass
if hasattr ( self . file , &apos; tell &apos; ) and hasattr ( self . file , &apos; seek &apos; ) :
pos = self . file . tell ( )
self . file . seek ( 0 , os . seek _ END )
size = self . file . tell ( )
self . file . seek ( pos )
return size
raise AttributeError ( &quot; Unable to determine the file &apos;s size . &quot; )
def _ get _ size ( self ) :
if hasattr ( self , &apos; _ size &apos; ) :
return self . _ size
self . _ size = self . _ get _ size _ from _ underlying _ file ( )
return self . _ size
def _ set _ size ( self , size ) :
self . _ size = size
size = property ( _ get _ size , _ set _ size )
def _ get _ closed ( self ) :
return not self . file or self . file . closed
closed = property ( _ get _ closed )
def chunks ( self , chunk _ size = None ) :
if not chunk _ size :
chunk _ size = self . default _ CHUNK _ SIZE
try :
self . seek ( 0 )
except ( AttributeError , UnsupportedOperation ) :
pass
while True :
data = self . read ( chunk _ size )
if not data :
break
yield data
def multiple _ chunks ( self , chunk _ size = None ) :
if not chunk _ size :
chunk _ size = self . default _ CHUNK _ SIZE
return self . size &gt; chunk _ size
def _ _ iter _ _ ( self ) :
buffer _ = None
for chunk in self . chunks ( ) :
chunk _ buffer = BytesIO ( chunk )
for line in chunk _ buffer :
if buffer _ :
line = buffer _ + line
buffer _ = None
if line &#91; - 1 : &#93; in ( b &apos; \ n &apos; , b &apos; \ r &apos; ) :
yield line
else :
buffer _ = line
if buffer _ is not None :
yield buffer _
def _ _ enter _ _ ( self ) :
return self
def _ _ exit _ _ ( self , exc _ type , exc _ value , tb ) :
self . close ( )
def open ( self , mode = None ) :
if not self . closed :
self . seek ( 0 )
elif self . name and os . path . exists ( self . name ) :
self . file = open ( self . name , mode or self . mode )
else :
raise ValueError ( &quot; The file cannot be reopened . &quot; )
def close ( self ) :
self . file . close ( )
@ python _ 2 _ unicode _ compatible
class ContentFile ( File ) :
def _ _ init _ _ ( self , content , name = None ) :
if six . PY3 :
stream _ class = StringIO if isinstance ( content , six . text _ type ) else BytesIO
else :
stream _ class = BytesIO
content = force _ bytes ( content )
super ( ContentFile , self ) . _ _ init _ _ ( stream _ class ( content ) , name = name )
self . size = len ( content )
def _ _ str _ _ ( self ) :
return &apos; Raw content&apos;
def _ _ bool _ _ ( self ) :
return True
def _ _ nonzero _ _ ( self ) :
return type ( self ) . _ _ bool _ _ ( self )
def open ( self , mode = None ) :
self . seek ( 0 )
def close ( self ) :
pass
import zlib
from django . core . files import File
class ImageFile ( File ) :
def _ get _ width ( self ) :
return self . _ get _ image _ dimensions ( ) &#91; 0 &#93;
width = property ( _ get _ width )
def _ get _ height ( self ) :
return self . _ get _ image _ dimensions ( ) &#91; 1 &#93;
height = property ( _ get _ height )
def _ get _ image _ dimensions ( self ) :
if not hasattr ( self , &apos; _ dimensions _ cache &apos; ) :
close = self . closed
self . open ( )
self . _ dimensions _ cache = get _ image _ dimensions ( self , close = close )
return self . _ dimensions _ cache
def get _ image _ dimensions ( file _ or _ path , close = False ) :
from PIL import ImageFile as PillowImageFile
p = PillowImageFile . parser ( )
if hasattr ( file _ or _ path , &apos; read &apos; ) :
file = file _ or _ path
file _ pos = file . tell ( )
file . seek ( 0 )
else :
file = open ( file _ or _ path , &apos; rb &apos; )
close = True
try :
chunk _ size = 1024
while 1 :
data = file . read ( chunk _ size )
if not data :
break
try :
p . feed ( data )
except zlib . error as e :
if e . args &#91; 0 &#93; . startswith ( &quot; Error -5 &quot; ) :
pass
else :
raise
if p . image :
return p . image . size
chunk _ size * = 2
return None
finally :
if close :
file . close ( )
else :
file . seek ( file _ pos )
import os
_ _ all _ _ = ( &apos; LOCK _ EX &apos; , &apos; LOCK _ SH &apos; , &apos; LOCK _ NB &apos; , &apos; lock &apos; , &apos; unlock &apos; )
def _ fd ( f ) :
return f . fileno ( ) if hasattr ( f , &apos; fileno &apos; ) else f
if os . name = = &apos; nt &apos; :
import msvcrt
from ctypes import ( sizeof , c _ ulong , c _ void _ p , c _ int64 , Structure , Union , POINTER , windll , byref )
from ctypes . wintypes import BOOL , DWORD , HANDLE
lock _ SH = 0
lock _ NB = 0x1
lock _ EX = 0x2
if sizeof ( c _ ulong ) ! = sizeof ( c _ void _ p ) :
ULONG _ PTR = c _ int64
else :
ULONG _ PTR = c _ ulong
PVOID = c _ void _ p
class _ OFFSET ( Structure ) :
_ fields _ = &#91; ( &apos; Offset &apos; , DWORD ) , ( &apos; OffsetHigh &apos; , DWORD ) &#93;
class _ OFFSET _ UNION ( Union ) :
_ anonymous _ = &#91; &apos; _ offset &apos; &#93;
_ fields _ = &#91; ( &apos; _ offset &apos; , _ OFFSET ) , ( &apos; Pointer &apos; , PVOID ) &#93;
class OVERLAPPED ( Structure ) :
_ anonymous _ = &#91; &apos; _ offset _ union &apos; &#93;
_ fields _ = &#91; ( &apos; Internal &apos; , ULONG _ PTR ) , ( &apos; InternalHigh &apos; , ULONG _ PTR ) , ( &apos; _ offset _ union &apos; , _ OFFSET _ UNION ) , ( &apos; hEvent &apos; , HANDLE ) &#93;
LPOVERLAPPED = POINTER ( OVERLAPPED )
LockFileEx = windll . kernel32 . LockFileEx
LockFileEx . restype = BOOL
LockFileEx . argtypes = &#91; HANDLE , DWORD , DWORD , DWORD , DWORD , LPOVERLAPPED &#93;
UnlockFileEx = windll . kernel32 . UnlockFileEx
UnlockFileEx . restype = BOOL
UnlockFileEx . argtypes = &#91; HANDLE , DWORD , DWORD , DWORD , LPOVERLAPPED &#93;
def lock ( f , flags ) :
hfile = msvcrt . get _ osfhandle ( _ fd ( f ) )
overlapped = OVERLAPPED ( )
ret = LockFileEx ( hfile , flags , 0 , 0 , 0xFFFF0000 , byref ( overlapped ) )
return bool ( ret )
def unlock ( f ) :
hfile = msvcrt . get _ osfhandle ( _ fd ( f ) )
overlapped = OVERLAPPED ( )
ret = UnlockFileEx ( hfile , 0 , 0 , 0xFFFF0000 , byref ( overlapped ) )
return bool ( ret )
else :
try :
import fcntl
lock _ SH = fcntl . lock _ SH
lock _ NB = fcntl . lock _ NB
lock _ EX = fcntl . lock _ EX
except ( ImportError , AttributeError ) :
lock _ EX = LOCK _ SH = LOCK _ NB = 0
def lock ( f , flags ) :
return False
def unlock ( f ) :
return True
else :
def lock ( f , flags ) :
ret = fcntl . flock ( _ fd ( f ) , flags )
return ( ret = = 0 )
def unlock ( f ) :
ret = fcntl . flock ( _ fd ( f ) , fcntl . lock _ UN )
return ( ret = = 0 )
import os
from django . core . files import locks
try :
from shutil import copystat
except ImportError :
import stat
def copystat ( src , dst ) :
st = os . stat ( src )
mode = stat . s _ IMODE ( st . st _ mode )
if hasattr ( os , &apos; utime &apos; ) :
os . utime ( dst , ( st . st _ atime , st . st _ mtime ) )
if hasattr ( os , &apos; chmod &apos; ) :
os . chmod ( dst , mode )
_ _ all _ _ = &#91; &apos; file _ move _ safe &apos; &#93;
def _ samefile ( src , dst ) :
if hasattr ( os . path , &apos; samefile &apos; ) :
try :
return os . path . samefile ( src , dst )
except OSError :
return False
return ( os . path . normcase ( os . path . abspath ( src ) ) = = os . path . normcase ( os . path . abspath ( dst ) ) )
def file _ move _ safe ( old _ file _ name , new _ file _ name , chunk _ size = 1024 * 64 , allow _ overwrite = False ) :
if _ samefile ( old _ file _ name , new _ file _ name ) :
return
try :
if not allow _ overwrite and os . access ( new _ file _ name , os . f _ OK ) :
raise IOError ( &quot; Destination file % s exists and allow _ overwrite is False &quot; % new _ file _ name )
os . rename ( old _ file _ name , new _ file _ name )
return
except OSError :
pass
with open ( old _ file _ name , &apos; rb &apos; ) as old _ file :
fd = os . open ( new _ file _ name , ( os . o _ WRONLY &#124; os . o _ CREAT &#124; getattr ( os , &apos; O _ BINARY &apos; , 0 ) &#124; ( os . o _ EXCL if not allow _ overwrite else 0 ) ) )
try :
locks . lock ( fd , locks . lock _ EX )
current _ chunk = None
while current _ chunk ! = b &apos; &apos; :
current _ chunk = old _ file . read ( chunk _ size )
os . write ( fd , current _ chunk )
finally :
locks . unlock ( fd )
os . close ( fd )
copystat ( old _ file _ name , new _ file _ name )
try :
os . remove ( old _ file _ name )
except OSError as e :
if getattr ( e , &apos; winerror &apos; , 0 ) ! = 32 and getattr ( e , &apos; errno &apos; , 0 ) ! = 13 :
raise
import os
import errno
import itertools
from datetime import datetime
from django . conf import settings
from django . core . exceptions import SuspiciousFileOperation
from django . core . files import locks , File
from django . core . files . move import file _ move _ safe
from django . utils . encoding import force _ text , filepath _ to _ uri
from django . utils . functional import LazyObject
from django . utils . module _ loading import import _ string
from django . utils . six . moves . urllib . parse import urljoin
from django . utils . text import get _ valid _ filename
from django . utils . _ os import safe _ join , abspathu
from django . utils . deconstruct import deconstructible
_ _ all _ _ = ( &apos; Storage &apos; , &apos; FileSystemStorage &apos; , &apos; DefaultStorage &apos; , &apos; default _ storage &apos; )
class Storage ( object ) :
def open ( self , name , mode = &apos; rb &apos; ) :
return self . _ open ( name , mode )
def save ( self , name , content ) :
if name is None :
name = content . name
if not hasattr ( content , &apos; chunks &apos; ) :
content = File ( content )
name = self . get _ available _ name ( name )
name = self . _ save ( name , content )
return force _ text ( name . replace ( &apos; \ \ &apos; , &apos; / &apos; ) )
def get _ valid _ name ( self , name ) :
return get _ valid _ filename ( name )
def get _ available _ name ( self , name ) :
dir _ name , file _ name = os . path . split ( name )
file _ root , file _ ext = os . path . splitext ( file _ name )
count = itertools . count ( 1 )
while self . exists ( name ) :
name = os . path . join ( dir _ name , &quot; % s _ % s % s &quot; % ( file _ root , next ( count ) , file _ ext ) )
return name
def path ( self , name ) :
raise NotImplementedError ( &quot; This backend doesn &apos;t support absolute paths . &quot; )
def delete ( self , name ) :
raise NotImplementedError ( &apos; subclasses of Storage must provide a delete ( ) method &apos; )
def exists ( self , name ) :
raise NotImplementedError ( &apos; subclasses of Storage must provide an exists ( ) method &apos; )
def listdir ( self , path ) :
raise NotImplementedError ( &apos; subclasses of Storage must provide a listdir ( ) method &apos; )
def size ( self , name ) :
raise NotImplementedError ( &apos; subclasses of Storage must provide a size ( ) method &apos; )
def url ( self , name ) :
raise NotImplementedError ( &apos; subclasses of Storage must provide a url ( ) method &apos; )
def accessed _ time ( self , name ) :
raise NotImplementedError ( &apos; subclasses of Storage must provide an accessed _ time ( ) method &apos; )
def created _ time ( self , name ) :
raise NotImplementedError ( &apos; subclasses of Storage must provide a created _ time ( ) method &apos; )
def modified _ time ( self , name ) :
raise NotImplementedError ( &apos; subclasses of Storage must provide a modified _ time ( ) method &apos; )
@ deconstructible
class FileSystemStorage ( Storage ) :
def _ _ init _ _ ( self , location = None , base _ url = None , file _ permissions _ mode = None , directory _ permissions _ mode = None ) :
if location is None :
location = settings . media _ ROOT
self . base _ location = location
self . location = abspathu ( self . base _ location )
if base _ url is None :
base _ url = settings . media _ URL
elif not base _ url . endswith ( &apos; / &apos; ) :
base _ url + = &apos; / &apos;
self . base _ url = base _ url
self . file _ permissions _ mode = ( file _ permissions _ mode if file _ permissions _ mode is not None else settings . file _ UPLOAD _ PERMISSIONS )
self . directory _ permissions _ mode = ( directory _ permissions _ mode if directory _ permissions _ mode is not None else settings . file _ UPLOAD _ DIRECTORY _ PERMISSIONS )
def _ open ( self , name , mode = &apos; rb &apos; ) :
return File ( open ( self . path ( name ) , mode ) )
def _ save ( self , name , content ) :
full _ path = self . path ( name )
directory = os . path . dirname ( full _ path )
if not os . path . exists ( directory ) :
try :
if self . directory _ permissions _ mode is not None :
old _ umask = os . umask ( 0 )
try :
os . makedirs ( directory , self . directory _ permissions _ mode )
finally :
os . umask ( old _ umask )
else :
os . makedirs ( directory )
except OSError as e :
if e . errno ! = errno . EEXIST :
raise
if not os . path . isdir ( directory ) :
raise IOError ( &quot; % s exists and is not a directory . &quot; % directory )
while True :
try :
if hasattr ( content , &apos; temporary _ file _ path &apos; ) :
file _ move _ safe ( content . temporary _ file _ path ( ) , full _ path )
else :
flags = ( os . o _ WRONLY &#124; os . o _ CREAT &#124; os . o _ EXCL &#124; getattr ( os , &apos; O _ BINARY &apos; , 0 ) )
fd = os . open ( full _ path , flags , 0o666 )
_ file = None
try :
locks . lock ( fd , locks . lock _ EX )
for chunk in content . chunks ( ) :
if _ file is None :
mode = &apos; wb &apos; if isinstance ( chunk , bytes ) else &apos; wt&apos;
_ file = os . fdopen ( fd , mode )
_ file . write ( chunk )
finally :
locks . unlock ( fd )
if _ file is not None :
_ file . close ( )
else :
os . close ( fd )
except OSError as e :
if e . errno = = errno . EEXIST :
name = self . get _ available _ name ( name )
full _ path = self . path ( name )
else :
raise
else :
break
if self . file _ permissions _ mode is not None :
os . chmod ( full _ path , self . file _ permissions _ mode )
return name
def delete ( self , name ) :
assert name , &quot; The name argument is not allowed to be empty . &quot;
name = self . path ( name )
if os . path . exists ( name ) :
try :
os . remove ( name )
except OSError as e :
if e . errno ! = errno . ENOENT :
raise
def exists ( self , name ) :
return os . path . exists ( self . path ( name ) )
def listdir ( self , path ) :
path = self . path ( path )
directories , files = &#91; &#93; , &#91; &#93;
for entry in os . listdir ( path ) :
if os . path . isdir ( os . path . join ( path , entry ) ) :
directories . append ( entry )
else :
files . append ( entry )
return directories , files
def path ( self , name ) :
try :
path = safe _ join ( self . location , name )
except ValueError :
raise SuspiciousFileOperation ( &quot; Attempted access to &apos; % s &apos; denied . &quot; % name )
return os . path . normpath ( path )
def size ( self , name ) :
return os . path . getsize ( self . path ( name ) )
def url ( self , name ) :
if self . base _ url is None :
raise ValueError ( &quot; This file is not accessible via a URL . &quot; )
return urljoin ( self . base _ url , filepath _ to _ uri ( name ) )
def accessed _ time ( self , name ) :
return datetime . fromtimestamp ( os . path . getatime ( self . path ( name ) ) )
def created _ time ( self , name ) :
return datetime . fromtimestamp ( os . path . getctime ( self . path ( name ) ) )
def modified _ time ( self , name ) :
return datetime . fromtimestamp ( os . path . getmtime ( self . path ( name ) ) )
def get _ storage _ class ( import _ path = None ) :
return import _ string ( import _ path or settings . default _ FILE _ STORAGE )
class DefaultStorage ( LazyObject ) :
def _ setup ( self ) :
self . _ wrapped = get _ storage _ class ( ) ( )
default _ storage = DefaultStorage ( )
import os
import tempfile
from django . core . files . utils import FileProxyMixin
_ _ all _ _ = ( &apos; NamedTemporaryFile &apos; , &apos; gettempdir &apos; , )
if os . name = = &apos; nt &apos; :
class TemporaryFile ( FileProxyMixin ) :
def _ _ init _ _ ( self , mode = &apos; w + b &apos; , bufsize = - 1 , suffix = &apos; &apos; , prefix = &apos; &apos; , dir = None ) :
fd , name = tempfile . mkstemp ( suffix = suffix , prefix = prefix , dir = dir )
self . name = name
self . file = os . fdopen ( fd , mode , bufsize )
self . close _ called = False
unlink = os . unlink
def close ( self ) :
if not self . close _ called :
self . close _ called = True
try :
self . file . close ( )
except ( OSError , IOError ) :
pass
try :
self . unlink ( self . name )
except ( OSError ) :
pass
@ property
def closed ( self ) :
return self . file . closed
def _ _ del _ _ ( self ) :
self . close ( )
def _ _ enter _ _ ( self ) :
self . file . _ _ enter _ _ ( )
return self
def _ _ exit _ _ ( self , exc , value , tb ) :
self . file . _ _ exit _ _ ( exc , value , tb )
NamedTemporaryFile = TemporaryFile
else :
NamedTemporaryFile = tempfile . NamedTemporaryFile
gettempdir = tempfile . gettempdir
import errno
import os
from io import BytesIO
from django . conf import settings
from django . core . files . base import File
from django . core . files import temp as tempfile
from django . utils . encoding import force _ str
_ _ all _ _ = ( &apos; UploadedFile &apos; , &apos; TemporaryUploadedFile &apos; , &apos; InMemoryUploadedFile &apos; , &apos; SimpleUploadedFile &apos; )
class UploadedFile ( File ) :
default _ CHUNK _ SIZE = 64 * 2 * * 10
def _ _ init _ _ ( self , file = None , name = None , content _ type = None , size = None , charset = None , content _ type _ extra = None ) :
super ( UploadedFile , self ) . _ _ init _ _ ( file , name )
self . size = size
self . content _ type = content _ type
self . charset = charset
self . content _ type _ extra = content _ type _ extra
def _ _ repr _ _ ( self ) :
return force _ str ( &quot; &lt; % s : % s ( % s ) &gt; &quot; % ( self . _ _ class _ _ . _ _ name _ _ , self . name , self . content _ type ) )
def _ get _ name ( self ) :
return self . _ name
def _ set _ name ( self , name ) :
if name is not None :
name = os . path . basename ( name )
if len ( name ) &gt; 255 :
name , ext = os . path . splitext ( name )
ext = ext &#91; : 255 &#93;
name = name &#91; : 255 - len ( ext ) &#93; + ext
self . _ name = name
name = property ( _ get _ name , _ set _ name )
class TemporaryUploadedFile ( UploadedFile ) :
def _ _ init _ _ ( self , name , content _ type , size , charset , content _ type _ extra = None ) :
if settings . file _ UPLOAD _ TEMP _ DIR :
file = tempfile . NamedTemporaryFile ( suffix = &apos; .upload &apos; , dir = settings . file _ UPLOAD _ TEMP _ DIR )
else :
file = tempfile . NamedTemporaryFile ( suffix = &apos; .upload &apos; )
super ( TemporaryUploadedFile , self ) . _ _ init _ _ ( file , name , content _ type , size , charset , content _ type _ extra )
def temporary _ file _ path ( self ) :
return self . file . name
def close ( self ) :
try :
return self . file . close ( )
except OSError as e :
if e . errno ! = errno . ENOENT :
raise
class InMemoryUploadedFile ( UploadedFile ) :
def _ _ init _ _ ( self , file , field _ name , name , content _ type , size , charset , content _ type _ extra = None ) :
super ( InMemoryUploadedFile , self ) . _ _ init _ _ ( file , name , content _ type , size , charset , content _ type _ extra )
self . field _ name = field _ name
def open ( self , mode = None ) :
self . file . seek ( 0 )
def chunks ( self , chunk _ size = None ) :
self . file . seek ( 0 )
yield self . read ( )
def multiple _ chunks ( self , chunk _ size = None ) :
return False
class SimpleUploadedFile ( InMemoryUploadedFile ) :
def _ _ init _ _ ( self , name , content , content _ type = &apos; text / plain &apos; ) :
content = content or b &apos; &apos;
super ( SimpleUploadedFile , self ) . _ _ init _ _ ( BytesIO ( content ) , None , name , content _ type , len ( content ) , None , None )
@ classmethod
def from _ dict ( cls , file _ dict ) :
return cls ( file _ dict &#91; &apos; filename &apos; &#93; , file _ dict &#91; &apos; content &apos; &#93; , file _ dict . get ( &apos; content-type &apos; , &apos; text / plain &apos; ) )
from _ _ future _ _ import unicode _ literals
from io import BytesIO
from django . conf import settings
from django . core . files . UploadedFile import TemporaryUploadedFile , InMemoryUploadedFile
from django . utils . encoding import python _ 2 _ unicode _ compatible
from django . utils . module _ loading import import _ string
_ _ all _ _ = &#91; &apos; UploadFileException &apos; , &apos; StopUpload &apos; , &apos; SkipFile &apos; , &apos; FileUploadHandler &apos; , &apos; TemporaryFileUploadHandler &apos; , &apos; MemoryFileUploadHandler &apos; , &apos; load _ handler &apos; , &apos; StopFutureHandlers &apos; &#93;
class UploadFileException ( Exception ) :
pass
@ python _ 2 _ unicode _ compatible
class StopUpload ( UploadFileException ) :
def _ _ init _ _ ( self , connection _ reset = False ) :
self . connection _ reset = connection _ reset
def _ _ str _ _ ( self ) :
if self . connection _ reset :
return &apos; StopUpload : halt current upload . &apos;
else :
return &apos; StopUpload : consume request data , then halt . &apos;
class SkipFile ( UploadFileException ) :
pass
class StopFutureHandlers ( UploadFileException ) :
pass
class FileUploadHandler ( object ) :
chunk _ size = 64 * 2 * * 10
def _ _ init _ _ ( self , request = None ) :
self . file _ name = None
self . content _ type = None
self . content _ length = None
self . charset = None
self . content _ type _ extra = None
self . request = request
def handle _ raw _ input ( self , input _ data , META , content _ length , boundary , encoding = None ) :
pass
def new _ file ( self , field _ name , file _ name , content _ type , content _ length , charset = None , content _ type _ extra = None ) :
self . field _ name = field _ name
self . file _ name = file _ name
self . content _ type = content _ type
self . content _ length = content _ length
self . charset = charset
self . content _ type _ extra = content _ type _ extra
def receive _ data _ chunk ( self , raw _ data , start ) :
raise NotImplementedError ( &apos; subclasses of FileUploadHandler must provide a receive _ data _ chunk ( ) method &apos; )
def file _ complete ( self , file _ size ) :
raise NotImplementedError ( &apos; subclasses of FileUploadHandler must provide a file _ complete ( ) method &apos; )
def upload _ complete ( self ) :
pass
class TemporaryFileUploadHandler ( FileUploadHandler ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
super ( TemporaryFileUploadHandler , self ) . _ _ init _ _ ( * args , * * kwargs )
def new _ file ( self , file _ name , * args , * * kwargs ) :
super ( TemporaryFileUploadHandler , self ) . new _ file ( file _ name , * args , * * kwargs )
self . file = TemporaryUploadedFile ( self . file _ name , self . content _ type , 0 , self . charset , self . content _ type _ extra )
def receive _ data _ chunk ( self , raw _ data , start ) :
self . file . write ( raw _ data )
def file _ complete ( self , file _ size ) :
self . file . seek ( 0 )
self . file . size = file _ size
return self . file
class MemoryFileUploadHandler ( FileUploadHandler ) :
def handle _ raw _ input ( self , input _ data , META , content _ length , boundary , encoding = None ) :
if content _ length &gt; settings . file _ UPLOAD _ MAX _ MEMORY _ SIZE :
self . activated = False
else :
self . activated = True
def new _ file ( self , * args , * * kwargs ) :
super ( MemoryFileUploadHandler , self ) . new _ file ( * args , * * kwargs )
if self . activated :
self . file = BytesIO ( )
raise StopFutureHandlers ( )
def receive _ data _ chunk ( self , raw _ data , start ) :
if self . activated :
self . file . write ( raw _ data )
else :
return raw _ data
def file _ complete ( self , file _ size ) :
if not self . activated :
return
self . file . seek ( 0 )
return InMemoryUploadedFile ( file = self . file , field _ name = self . field _ name , name = self . file _ name , content _ type = self . content _ type , size = file _ size , charset = self . charset , content _ type _ extra = self . content _ type _ extra )
def load _ handler ( path , * args , * * kwargs ) :
return import _ string ( path ) ( * args , * * kwargs )
class FileProxyMixin ( object ) :
encoding = property ( lambda self : self . file . encoding )
fileno = property ( lambda self : self . file . fileno )
flush = property ( lambda self : self . file . flush )
isatty = property ( lambda self : self . file . isatty )
newlines = property ( lambda self : self . file . newlines )
read = property ( lambda self : self . file . read )
readinto = property ( lambda self : self . file . readinto )
readline = property ( lambda self : self . file . readline )
readlines = property ( lambda self : self . file . readlines )
seek = property ( lambda self : self . file . seek )
softspace = property ( lambda self : self . file . softspace )
tell = property ( lambda self : self . file . tell )
truncate = property ( lambda self : self . file . truncate )
write = property ( lambda self : self . file . write )
writelines = property ( lambda self : self . file . writelines )
xreadlines = property ( lambda self : self . file . xreadlines )
def _ _ iter _ _ ( self ) :
return iter ( self . file )
from _ _ future _ _ import unicode _ literals
import logging
import sys
import types
from django import http
from django . conf import settings
from django . core import urlresolvers
from django . core import signals
from django . core . exceptions import MiddlewareNotUsed , PermissionDenied , SuspiciousOperation
from django . db import connections , transaction
from django . utils . encoding import force _ text
from django . utils . module _ loading import import _ string
from django . utils import six
from django . views import debug
logger = logging . getLogger ( &apos; django.request &apos; )
class BaseHandler ( object ) :
response _ fixes = &#91; http . fix _ location _ header , http . conditional _ content _ removal , &#93;
def _ _ init _ _ ( self ) :
self . _ request _ middleware = self . _ view _ middleware = self . _ template _ response _ middleware = self . _ response _ middleware = self . _ exception _ middleware = None
def load _ middleware ( self ) :
self . _ view _ middleware = &#91; &#93;
self . _ template _ response _ middleware = &#91; &#93;
self . _ response _ middleware = &#91; &#93;
self . _ exception _ middleware = &#91; &#93;
request _ middleware = &#91; &#93;
for middleware _ path in settings . middleware _ CLASSES :
mw _ class = import _ string ( middleware _ path )
try :
mw _ instance = mw _ class ( )
except MiddlewareNotUsed :
continue
if hasattr ( mw _ instance , &apos; process _ request &apos; ) :
request _ middleware . append ( mw _ instance . process _ request )
if hasattr ( mw _ instance , &apos; process _ view &apos; ) :
self . _ view _ middleware . append ( mw _ instance . process _ view )
if hasattr ( mw _ instance , &apos; process _ template _ response &apos; ) :
self . _ template _ response _ middleware . insert ( 0 , mw _ instance . process _ template _ response )
if hasattr ( mw _ instance , &apos; process _ response &apos; ) :
self . _ response _ middleware . insert ( 0 , mw _ instance . process _ response )
if hasattr ( mw _ instance , &apos; process _ exception &apos; ) :
self . _ exception _ middleware . insert ( 0 , mw _ instance . process _ exception )
self . _ request _ middleware = request _ middleware
def make _ view _ atomic ( self , view ) :
non _ atomic _ requests = getattr ( view , &apos; _ non _ atomic _ requests &apos; , set ( ) )
for db in connections . all ( ) :
if ( db . settings _ dict &#91; &apos; ATOMIC _ REQUESTS &apos; &#93; and db . ALIAS not in non _ atomic _ requests ) :
view = transaction . atomic ( using = db . ALIAS ) ( view )
return view
def get _ exception _ response ( self , request , resolver , status _ code ) :
try :
callback , param _ dict = resolver . resolve _ error _ handler ( status _ code )
response = callback ( request , * * param _ dict )
except :
signals . got _ request _ exception . send ( sender = self . _ _ class _ _ , request = request )
response = self . handle _ uncaught _ exception ( request , resolver , sys . exc _ info ( ) )
return response
def get _ response ( self , request ) :
urlconf = settings . root _ URLCONF
urlresolvers . set _ urlconf ( urlconf )
resolver = urlresolvers . RegexURLResolver ( r &apos; ^ / &apos; , urlconf )
try :
response = None
for middleware _ method in self . _ request _ middleware :
response = middleware _ method ( request )
if response :
break
if response is None :
if hasattr ( request , &apos; urlconf &apos; ) :
urlconf = request . urlconf
urlresolvers . set _ urlconf ( urlconf )
resolver = urlresolvers . RegexURLResolver ( r &apos; ^ / &apos; , urlconf )
resolver _ match = resolver . resolve ( request . path _ info )
callback , callback _ args , callback _ kwargs = resolver _ match
request . resolver _ match = resolver _ match
for middleware _ method in self . _ view _ middleware :
response = middleware _ method ( request , callback , callback _ args , callback _ kwargs )
if response :
break
if response is None :
wrapped _ callback = self . make _ view _ atomic ( callback )
try :
response = wrapped _ callback ( request , * callback _ args , * * callback _ kwargs )
except Exception as e :
for middleware _ method in self . _ exception _ middleware :
response = middleware _ method ( request , e )
if response :
break
if response is None :
raise
if response is None :
if isinstance ( callback , types . FunctionType ) :
view _ name = callback . _ _ name _ _
else :
view _ name = callback . _ _ class _ _ . _ _ name _ _ + &apos; . _ _ call _ _ &apos;
raise ValueError ( &quot; The view % s . % s didn &apos;t return an HttpResponse object . it returned None instead . &quot; % ( callback . _ _ module _ _ , view _ name ) )
if hasattr ( response , &apos; render &apos; ) and callable ( response . render ) :
for middleware _ method in self . _ template _ response _ middleware :
response = middleware _ method ( request , response )
if response is None :
raise ValueError ( &quot; % s.process _ template _ response didn &apos;t return an &quot; &quot; HttpResponse object . it returned None instead . &quot; % ( middleware _ method . _ _ self _ _ . _ _ class _ _ . _ _ name _ _ ) )
response = response . render ( )
except http . Http404 as e :
logger . warning ( &apos; Not Found : % s &apos; , request . path , extra = { &apos; status _ code &apos; : 404 , &apos; request &apos; : request } )
if settings . DEBUG :
response = debug . technical _ 404 _ response ( request , e )
else :
response = self . get _ exception _ response ( request , resolver , 404 )
except PermissionDenied :
logger . warning ( &apos; Forbidden ( Permission denied ) : % s &apos; , request . path , extra = { &apos; status _ code &apos; : 403 , &apos; request &apos; : request } )
response = self . get _ exception _ response ( request , resolver , 403 )
except SuspiciousOperation as e :
security _ logger = logging . getLogger ( &apos; django.security. % s &apos; % e . _ _ class _ _ . _ _ name _ _ )
security _ logger . error ( force _ text ( e ) , extra = { &apos; status _ code &apos; : 400 , &apos; request &apos; : request } )
if settings . DEBUG :
return debug . technical _ 500 _ response ( request , * sys . exc _ info ( ) , status _ code = 400 )
response = self . get _ exception _ response ( request , resolver , 400 )
except SystemExit :
raise
except :
signals . got _ request _ exception . send ( sender = self . _ _ class _ _ , request = request )
response = self . handle _ uncaught _ exception ( request , resolver , sys . exc _ info ( ) )
try :
for middleware _ method in self . _ response _ middleware :
response = middleware _ method ( request , response )
if response is None :
raise ValueError ( &quot; % s.process _ response didn &apos;t return an &quot; &quot; HttpResponse object . it returned None instead . &quot; % ( middleware _ method . _ _ self _ _ . _ _ class _ _ . _ _ name _ _ ) )
response = self . apply _ response _ fixes ( request , response )
except :
signals . got _ request _ exception . send ( sender = self . _ _ class _ _ , request = request )
response = self . handle _ uncaught _ exception ( request , resolver , sys . exc _ info ( ) )
response . _ closable _ objects . append ( request )
return response
def handle _ uncaught _ exception ( self , request , resolver , exc _ info ) :
if settings . DEBUG _ PROPAGATE _ EXCEPTIONS :
raise
logger . error ( &apos; Internal Server Error : % s &apos; , request . path , exc _ info = exc _ info , extra = { &apos; status _ code &apos; : 500 , &apos; request &apos; : request } )
if settings . DEBUG :
return debug . technical _ 500 _ response ( request , * exc _ info )
if resolver . urlconf _ module is None :
six . reraise ( * exc _ info )
callback , param _ dict = resolver . resolve _ error _ handler ( 500 )
return callback ( request , * * param _ dict )
def apply _ response _ fixes ( self , request , response ) :
for func in self . response _ fixes :
response = func ( request , response )
return response
from _ _ future _ _ import unicode _ literals
import cgi
import codecs
import logging
import sys
from io import BytesIO
from threading import Lock
import warnings
from django import http
from django . conf import settings
from django . core import signals
from django . core . handlers import base
from django . core . urlresolvers import set _ script _ prefix
from django . utils import datastructures
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import force _ str , force _ text
from django . utils . functional import cached _ property
from django . utils import six
from django . http . response import REASON _ PHRASES as STATUS _ CODE _ TEXT
logger = logging . getLogger ( &apos; django.request &apos; )
iso _ 8859 _ 1 , UTF _ 8 = str ( &apos; iso-8859-1 &apos; ) , str ( &apos; utf-8 &apos; )
class LimitedStream ( object ) :
def _ _ init _ _ ( self , stream , limit , buf _ size = 64 * 1024 * 1024 ) :
self . stream = stream
self . remaining = limit
self . buffer = b &apos; &apos;
self . buf _ size = buf _ size
def _ read _ limited ( self , size = None ) :
if size is None or size &gt; self . remaining :
size = self . remaining
if size = = 0 :
return b &apos; &apos;
result = self . stream . read ( size )
self . remaining - = len ( result )
return result
def read ( self , size = None ) :
if size is None :
result = self . buffer + self . _ read _ limited ( )
self . buffer = b &apos; &apos;
elif size &lt; len ( self . buffer ) :
result = self . buffer &#91; : size &#93;
self . buffer = self . buffer &#91; size : &#93;
else :
result = self . buffer + self . _ read _ limited ( size - len ( self . buffer ) )
self . buffer = b &apos; &apos;
return result
def readline ( self , size = None ) :
while b &apos; \ n &apos; not in self . buffer and ( size is None or len ( self . buffer ) &lt; size ) :
if size :
chunk = self . _ read _ limited ( size - len ( self . buffer ) )
else :
chunk = self . _ read _ limited ( )
if not chunk :
break
self . buffer + = chunk
sio = BytesIO ( self . buffer )
if size :
line = sio . readline ( size )
else :
line = sio . readline ( )
self . buffer = sio . read ( )
return line
class WSGIRequest ( http . HttpRequest ) :
def _ _ init _ _ ( self , environ ) :
script _ name = get _ script _ name ( environ )
path _ info = get _ path _ info ( environ )
if not path _ info :
path _ info = &apos; / &apos;
self . environ = environ
self . path _ info = path _ info
self . path = &apos; % s / % s &apos; % ( script _ name . rstrip ( &apos; / &apos; ) , path _ info . replace ( &apos; / &apos; , &apos; &apos; , 1 ) )
self . meta = environ
self . meta &#91; &apos; PATH _ INFO &apos; &#93; = path _ info
self . meta &#91; &apos; SCRIPT _ NAME &apos; &#93; = script _ name
self . method = environ &#91; &apos; REQUEST _ METHOD &apos; &#93; . upper ( )
_ , content _ params = cgi . parse _ header ( environ . get ( &apos; CONTENT _ TYPE &apos; , &apos; &apos; ) )
if &apos; charset &apos; in content _ params :
try :
codecs . lookup ( content _ params &#91; &apos; charset &apos; &#93; )
except LookupError :
pass
else :
self . encoding = content _ params &#91; &apos; charset &apos; &#93;
self . _ post _ parse _ error = False
try :
content _ length = int ( environ . get ( &apos; CONTENT _ LENGTH &apos; ) )
except ( ValueError , TypeError ) :
content _ length = 0
self . _ stream = LimitedStream ( self . environ &#91; &apos; wsgi.input &apos; &#93; , content _ length )
self . _ read _ started = False
self . resolver _ match = None
def _ get _ scheme ( self ) :
return self . environ . get ( &apos; wsgi.url _ scheme &apos; )
def _ get _ request ( self ) :
warnings . warn ( &apos; `request.REQUEST` is deprecated , use `request.GET` or &apos; &apos;`request.POST` instead . &apos; , RemovedInDjango19Warning , 2 )
if not hasattr ( self , &apos; _ request &apos; ) :
self . _ request = datastructures . MergeDict ( self . post , self . get )
return self . _ request
@ cached _ property
def GET ( self ) :
raw _ query _ string = get _ bytes _ from _ wsgi ( self . environ , &apos; QUERY _ STRING &apos; , &apos; &apos; )
return http . QueryDict ( raw _ query _ string , encoding = self . _ encoding )
def _ get _ post ( self ) :
if not hasattr ( self , &apos; _ post &apos; ) :
self . _ load _ post _ and _ files ( )
return self . _ post
def _ set _ post ( self , post ) :
self . _ post = post
@ cached _ property
def COOKIES ( self ) :
raw _ cookie = get _ str _ from _ wsgi ( self . environ , &apos; HTTP _ COOKIE &apos; , &apos; &apos; )
return http . parse _ cookie ( raw _ cookie )
def _ get _ files ( self ) :
if not hasattr ( self , &apos; _ files &apos; ) :
self . _ load _ post _ and _ files ( )
return self . _ files
post = property ( _ get _ post , _ set _ post )
files = property ( _ get _ files )
request = property ( _ get _ request )
class WSGIHandler ( base . BaseHandler ) :
initLock = Lock ( )
request _ class = WSGIRequest
def _ _ call _ _ ( self , environ , start _ response ) :
if self . _ request _ middleware is None :
with self . initLock :
try :
if self . _ request _ middleware is None :
self . load _ middleware ( )
except :
self . _ request _ middleware = None
raise
set _ script _ prefix ( get _ script _ name ( environ ) )
signals . request _ started . send ( sender = self . _ _ class _ _ )
try :
request = self . request _ class ( environ )
except UnicodeDecodeError :
logger . warning ( &apos; Bad Request ( UnicodeDecodeError ) &apos; , exc _ info = sys . exc _ info ( ) , extra = { &apos; status _ code &apos; : 400 , } )
response = http . HttpResponseBadRequest ( )
else :
response = self . get _ response ( request )
response . _ handler _ class = self . _ _ class _ _
status = &apos; % s % s &apos; % ( response . status _ code , response . reason _ phrase )
response _ headers = &#91; ( str ( k ) , str ( v ) ) for k , v in response . items ( ) &#93;
for c in response . cookies . values ( ) :
response _ headers . append ( ( str ( &apos; Set-Cookie &apos; ) , str ( c . output ( header = &apos; &apos; ) ) ) )
start _ response ( force _ str ( status ) , response _ headers )
return response
def get _ path _ info ( environ ) :
path _ info = get _ bytes _ from _ wsgi ( environ , &apos; PATH _ INFO &apos; , &apos; / &apos; )
return path _ info . decode ( UTF _ 8 )
def get _ script _ name ( environ ) :
if settings . force _ SCRIPT _ NAME is not None :
return force _ text ( settings . force _ SCRIPT _ NAME )
script _ url = get _ bytes _ from _ wsgi ( environ , &apos; SCRIPT _ URL &apos; , &apos; &apos; )
if not script _ url :
script _ url = get _ bytes _ from _ wsgi ( environ , &apos; REDIRECT _ URL &apos; , &apos; &apos; )
if script _ url :
path _ info = get _ bytes _ from _ wsgi ( environ , &apos; PATH _ INFO &apos; , &apos; &apos; )
script _ name = script _ url &#91; : - len ( path _ info ) &#93;
else :
script _ name = get _ bytes _ from _ wsgi ( environ , &apos; SCRIPT _ NAME &apos; , &apos; &apos; )
return script _ name . decode ( UTF _ 8 )
def get _ bytes _ from _ wsgi ( environ , key , default ) :
value = environ . get ( str ( key ) , str ( default ) )
return value if six . PY2 else value . encode ( ISO _ 8859 _ 1 )
def get _ str _ from _ wsgi ( environ , key , default ) :
value = environ . get ( str ( key ) , str ( default ) )
return value if six . PY2 else value . encode ( ISO _ 8859 _ 1 ) . decode ( UTF _ 8 )
from _ _ future _ _ import unicode _ literals
from django . conf import settings
from django . utils . module _ loading import import _ string
from django . core . mail . utils import CachedDnsName , DNS _ NAME
from django . core . mail . message import ( EmailMessage , EmailMultiAlternatives , SafeMIMEText , SafeMIMEMultipart , DEFAULT _ ATTACHMENT _ MIME _ TYPE , make _ msgid , BadHeaderError , forbid _ multi _ line _ headers )
_ _ all _ _ = &#91; &apos; CachedDnsName &apos; , &apos; DNS _ NAME &apos; , &apos; EmailMessage &apos; , &apos; EmailMultiAlternatives &apos; , &apos; SafeMIMEText &apos; , &apos; SafeMIMEMultipart &apos; , &apos; DEFAULT _ ATTACHMENT _ MIME _ TYPE &apos; , &apos; make _ msgid &apos; , &apos; BadHeaderError &apos; , &apos; forbid _ multi _ line _ headers &apos; , &apos; get _ connection &apos; , &apos; send _ mail &apos; , &apos; send _ mass _ mail &apos; , &apos; mail _ admins &apos; , &apos; mail _ managers &apos; , &#93;
def get _ connection ( backend = None , fail _ silently = False , * * kwds ) :
klass = import _ string ( backend or settings . email _ BACKEND )
return klass ( fail _ silently = fail _ silently , * * kwds )
def send _ mail ( subject , message , from _ email , recipient _ list , fail _ silently = False , auth _ user = None , auth _ password = None , connection = None , html _ message = None ) :
connection = connection or get _ connection ( username = auth _ user , password = auth _ password , fail _ silently = fail _ silently )
mail = EmailMultiAlternatives ( subject , message , from _ email , recipient _ list , connection = connection )
if html _ message :
mail . attach _ alternative ( html _ message , &apos; text / html &apos; )
return mail . send ( )
def send _ mass _ mail ( datatuple , fail _ silently = False , auth _ user = None , auth _ password = None , connection = None ) :
connection = connection or get _ connection ( username = auth _ user , password = auth _ password , fail _ silently = fail _ silently )
messages = &#91; EmailMessage ( subject , message , sender , recipient , connection = connection ) for subject , message , sender , recipient in datatuple &#93;
return connection . send _ messages ( messages )
def mail _ admins ( subject , message , fail _ silently = False , connection = None , html _ message = None ) :
if not settings . admins :
return
mail = EmailMultiAlternatives ( &apos; % s % s &apos; % ( settings . email _ SUBJECT _ PREFIX , subject ) , message , settings . server _ EMAIL , &#91; a &#91; 1 &#93; for a in settings . admins &#93; , connection = connection )
if html _ message :
mail . attach _ alternative ( html _ message , &apos; text / html &apos; )
mail . send ( fail _ silently = fail _ silently )
def mail _ managers ( subject , message , fail _ silently = False , connection = None , html _ message = None ) :
if not settings . managers :
return
mail = EmailMultiAlternatives ( &apos; % s % s &apos; % ( settings . email _ SUBJECT _ PREFIX , subject ) , message , settings . server _ EMAIL , &#91; a &#91; 1 &#93; for a in settings . managers &#93; , connection = connection )
if html _ message :
mail . attach _ alternative ( html _ message , &apos; text / html &apos; )
mail . send ( fail _ silently = fail _ silently )
class BaseEmailBackend ( object ) :
def _ _ init _ _ ( self , fail _ silently = False , * * kwargs ) :
self . fail _ silently = fail _ silently
def open ( self ) :
pass
def close ( self ) :
pass
def _ _ enter _ _ ( self ) :
self . open ( )
return self
def _ _ exit _ _ ( self , exc _ type , exc _ value , traceback ) :
self . close ( )
def send _ messages ( self , email _ messages ) :
raise NotImplementedError ( &apos; subclasses of BaseEmailBackend must override send _ messages ( ) method &apos; )
import sys
import threading
from django . core . mail . backends . base import BaseEmailBackend
from django . utils import six
class EmailBackend ( BaseEmailBackend ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
self . stream = kwargs . pop ( &apos; stream &apos; , sys . stdout )
self . _ lock = threading . RLock ( )
super ( EmailBackend , self ) . _ _ init _ _ ( * args , * * kwargs )
def write _ message ( self , message ) :
msg = message . message ( )
msg _ data = msg . as _ bytes ( )
if six . PY3 :
charset = msg . get _ charset ( ) . get _ output _ charset ( ) if msg . get _ charset ( ) else &apos; utf-8&apos;
msg _ data = msg _ data . decode ( charset )
self . stream . write ( &apos; % s \ n &apos; % msg _ data )
self . stream . write ( &apos; -&apos; * 79 )
self . stream . write ( &apos; \ n &apos; )
def send _ messages ( self , email _ messages ) :
if not email _ messages :
return
msg _ count = 0
with self . _ lock :
try :
stream _ created = self . open ( )
for message in email _ messages :
self . write _ message ( message )
self . stream . flush ( )
msg _ count + = 1
if stream _ created :
self . close ( )
except Exception :
if not self . fail _ silently :
raise
return msg _ count
from django . core . mail . backends . base import BaseEmailBackend
class EmailBackend ( BaseEmailBackend ) :
def send _ messages ( self , email _ messages ) :
return len ( list ( email _ messages ) )
import datetime
import os
from django . conf import settings
from django . core . exceptions import ImproperlyConfigured
from django . core . mail . backends . console import EmailBackend as ConsoleEmailBackend
from django . utils import six
class EmailBackend ( ConsoleEmailBackend ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
self . _ fname = None
if &apos; file _ path &apos; in kwargs :
self . file _ path = kwargs . pop ( &apos; file _ path &apos; )
else :
self . file _ path = getattr ( settings , &apos; EMAIL _ FILE _ PATH &apos; , None )
if not isinstance ( self . file _ path , six . string _ types ) :
raise ImproperlyConfigured ( &apos; Path for saving emails is invalid : % r &apos; % self . file _ path )
self . file _ path = os . path . abspath ( self . file _ path )
if os . path . exists ( self . file _ path ) and not os . path . isdir ( self . file _ path ) :
raise ImproperlyConfigured ( &apos; Path for saving email messages exists , but is not a directory : % s &apos; % self . file _ path )
elif not os . path . exists ( self . file _ path ) :
try :
os . makedirs ( self . file _ path )
except OSError as err :
raise ImproperlyConfigured ( &apos; Could not create directory for saving email messages : % s ( % s ) &apos; % ( self . file _ path , err ) )
if not os . access ( self . file _ path , os . w _ OK ) :
raise ImproperlyConfigured ( &apos; Could not write to directory : % s &apos; % self . file _ path )
kwargs &#91; &apos; stream &apos; &#93; = None
super ( EmailBackend , self ) . _ _ init _ _ ( * args , * * kwargs )
def write _ message ( self , message ) :
self . stream . write ( message . message ( ) . as _ bytes ( ) + b &apos; \ n &apos; )
self . stream . write ( b &apos; - &apos; * 79 )
self . stream . write ( b &apos; \ n &apos; )
def _ get _ filename ( self ) :
if self . _ fname is None :
timestamp = datetime . datetime . now ( ) . strftime ( &quot; % Y % m % d- % H % M % S &quot; )
fname = &quot; % s- % s.log &quot; % ( timestamp , abs ( id ( self ) ) )
self . _ fname = os . path . join ( self . file _ path , fname )
return self . _ fname
def open ( self ) :
if self . stream is None :
self . stream = open ( self . _ get _ filename ( ) , &apos; ab &apos; )
return True
return False
def close ( self ) :
try :
if self . stream is not None :
self . stream . close ( )
finally :
self . stream = None
from django . core import mail
from django . core . mail . backends . base import BaseEmailBackend
class EmailBackend ( BaseEmailBackend ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
super ( EmailBackend , self ) . _ _ init _ _ ( * args , * * kwargs )
if not hasattr ( mail , &apos; outbox &apos; ) :
mail . outbox = &#91; &#93;
def send _ messages ( self , messages ) :
msg _ count = 0
for message in messages :
message . message ( )
msg _ count + = 1
mail . outbox . extend ( messages )
return msg _ count
import smtplib
import ssl
import threading
from django . conf import settings
from django . core . mail . backends . base import BaseEmailBackend
from django . core . mail . utils import DNS _ NAME
from django . core . mail . message import sanitize _ address
class EmailBackend ( BaseEmailBackend ) :
def _ _ init _ _ ( self , host = None , port = None , username = None , password = None , use _ tls = None , fail _ silently = False , use _ ssl = None , timeout = None , * * kwargs ) :
super ( EmailBackend , self ) . _ _ init _ _ ( fail _ silently = fail _ silently )
self . host = host or settings . email _ HOST
self . port = port or settings . email _ PORT
self . username = settings . email _ HOST _ USER if username is None else username
self . password = settings . email _ HOST _ PASSWORD if password is None else password
self . use _ tls = settings . email _ USE _ TLS if use _ tls is None else use _ tls
self . use _ ssl = settings . email _ USE _ SSL if use _ ssl is None else use _ ssl
self . timeout = timeout
if self . use _ ssl and self . use _ tls :
raise ValueError ( &quot; EMAIL _ USE _ TLS / EMAIL _ USE _ SSL are mutually exclusive , so only set &quot; &quot; one of those settings to True . &quot; )
self . connection = None
self . _ lock = threading . RLock ( )
def open ( self ) :
if self . connection :
return False
connection _ class = smtplib . SMTP _ SSL if self . use _ ssl else smtplib . SMTP
connection _ params = { &apos; local _ hostname &apos; : DNS _ NAME . get _ fqdn ( ) }
if self . timeout is not None :
connection _ params &#91; &apos; timeout &apos; &#93; = self . timeout
try :
self . connection = connection _ class ( self . host , self . port , * * connection _ params )
if not self . use _ ssl and self . use _ tls :
self . connection . ehlo ( )
self . connection . starttls ( )
self . connection . ehlo ( )
if self . username and self . password :
self . connection . login ( self . username , self . password )
return True
except smtplib . SMTPException :
if not self . fail _ silently :
raise
def close ( self ) :
if self . connection is None :
return
try :
try :
self . connection . quit ( )
except ( ssl . SSLError , smtplib . SMTPServerDisconnected ) :
self . connection . close ( )
except smtplib . SMTPException :
if self . fail _ silently :
return
raise
finally :
self . connection = None
def send _ messages ( self , email _ messages ) :
if not email _ messages :
return
with self . _ lock :
new _ conn _ created = self . open ( )
if not self . connection :
return
num _ sent = 0
for message in email _ messages :
sent = self . _ send ( message )
if sent :
num _ sent + = 1
if new _ conn _ created :
self . close ( )
return num _ sent
def _ send ( self , email _ message ) :
if not email _ message . recipients ( ) :
return False
from _ email = sanitize _ address ( email _ message . from _ email , email _ message . encoding )
recipients = &#91; sanitize _ address ( addr , email _ message . encoding ) for addr in email _ message . recipients ( ) &#93;
message = email _ message . message ( )
try :
self . connection . sendmail ( from _ email , recipients , message . as _ bytes ( ) )
except smtplib . SMTPException :
if not self . fail _ silently :
raise
return False
return True
from _ _ future _ _ import unicode _ literals
import mimetypes
import os
import random
import sys
import time
from email import ( charset as Charset , encoders as Encoders , message _ from _ string , generator )
from email . message import Message
from email . mime . text import MIMEText
from email . mime . multipart import MIMEMultipart
from email . mime . base import MIMEBase
from email . mime . message import MIMEMessage
from email . header import Header
from email . utils import formatdate , getaddresses , formataddr , parseaddr
from django . conf import settings
from django . core . mail . utils import DNS _ NAME
from django . utils . encoding import force _ text
from django . utils import six
utf8 _ charset = Charset . charset ( &apos; utf-8 &apos; )
utf8 _ charset . body _ encoding = None
default _ ATTACHMENT _ MIME _ TYPE = &apos; application / octet-stream&apos;
class BadHeaderError ( ValueError ) :
pass
def make _ msgid ( idstring = None ) :
timeval = time . time ( )
utcdate = time . strftime ( &apos; % Y % m % d % H % M % S &apos; , time . gmtime ( timeval ) )
try :
pid = os . getpid ( )
except AttributeError :
pid = 1
randint = random . randrange ( 100000 )
if idstring is None :
idstring = &apos; &apos;
else :
idstring = &apos; .&apos; + idstring
idhost = DNS _ NAME
msgid = &apos; &lt; % s . % s . % s % s @ % s &gt; &apos; % ( utcdate , pid , randint , idstring , idhost )
return msgid
address _ HEADERS = set ( &#91; &apos; from &apos; , &apos; sender &apos; , &apos; reply-to &apos; , &apos; to &apos; , &apos; cc &apos; , &apos; bcc &apos; , &apos; resent-from &apos; , &apos; resent-sender &apos; , &apos; resent-to &apos; , &apos; resent-cc &apos; , &apos; resent-bcc &apos; , &#93; )
def forbid _ multi _ line _ headers ( name , val , encoding ) :
encoding = encoding or settings . default _ CHARSET
val = force _ text ( val )
if &apos; \ n &apos; in val or &apos; \ r &apos; in val :
raise BadHeaderError ( &quot; Header values can &apos;t contain newlines ( got % r for header % r ) &quot; % ( val , name ) )
try :
val . encode ( &apos; ascii &apos; )
except UnicodeEncodeError :
if name . lower ( ) in ADDRESS _ HEADERS :
val = &apos; , &apos; . join ( sanitize _ address ( addr , encoding ) for addr in getaddresses ( ( val , ) ) )
else :
val = Header ( val , encoding ) . encode ( )
else :
if name . lower ( ) = = &apos; subject &apos; :
val = Header ( val ) . encode ( )
return str ( name ) , val
def sanitize _ address ( addr , encoding ) :
if isinstance ( addr , six . string _ types ) :
addr = parseaddr ( force _ text ( addr ) )
nm , addr = addr
try :
nm = Header ( nm , encoding ) . encode ( )
except UnicodeEncodeError :
nm = Header ( nm , &apos; utf-8 &apos; ) . encode ( )
try :
addr . encode ( &apos; ascii &apos; )
except UnicodeEncodeError :
if &apos; @ &apos; in addr :
localpart , domain = addr . split ( &apos; @ &apos; , 1 )
localpart = str ( Header ( localpart , encoding ) )
domain = domain . encode ( &apos; idna &apos; ) . decode ( &apos; ascii &apos; )
addr = &apos; @ &apos; . join ( &#91; localpart , domain &#93; )
else :
addr = Header ( addr , encoding ) . encode ( )
return formataddr ( ( nm , addr ) )
class MIMEMixin ( ) :
def as _ string ( self , unixfrom = False ) :
fp = six . StringIO ( )
g = generator . generator ( fp , mangle _ from _ = False )
g . flatten ( self , unixfrom = unixfrom )
return fp . getvalue ( )
if six . PY2 :
as _ bytes = as _ string
else :
def as _ bytes ( self , unixfrom = False ) :
fp = six . BytesIO ( )
g = generator . BytesGenerator ( fp , mangle _ from _ = False )
g . flatten ( self , unixfrom = unixfrom )
return fp . getvalue ( )
class SafeMIMEMessage ( MIMEMixin , MIMEMessage ) :
def _ _ setitem _ _ ( self , name , val ) :
name , val = forbid _ multi _ line _ headers ( name , val , &apos; ascii &apos; )
MIMEMessage . _ _ setitem _ _ ( self , name , val )
class SafeMIMEText ( MIMEMixin , MIMEText ) :
def _ _ init _ _ ( self , text , subtype , charset ) :
self . encoding = charset
if charset = = &apos; utf-8 &apos; :
MIMEText . _ _ init _ _ ( self , text , subtype , None )
del self &#91; &apos; Content-Transfer-Encoding &apos; &#93;
if ( 3 , 2 ) &lt; sys . version _ info &lt; ( 3 , 3 , 4 ) :
payload = text . encode ( utf8 _ charset . output _ charset )
self . _ payload = payload . decode ( &apos; ascii &apos; , &apos; surrogateescape &apos; )
self . set _ charset ( utf8 _ charset )
else :
self . set _ payload ( text , utf8 _ charset )
self . replace _ header ( &apos; Content-Type &apos; , &apos; text / % s ; charset = &quot; % s &quot; &apos; % ( subtype , charset ) )
else :
MIMEText . _ _ init _ _ ( self , text , subtype , charset )
def _ _ setitem _ _ ( self , name , val ) :
name , val = forbid _ multi _ line _ headers ( name , val , self . encoding )
MIMEText . _ _ setitem _ _ ( self , name , val )
class SafeMIMEMultipart ( MIMEMixin , MIMEMultipart ) :
def _ _ init _ _ ( self , _ subtype = &apos; mixed &apos; , boundary = None , _ subparts = None , encoding = None , * * _ params ) :
self . encoding = encoding
MIMEMultipart . _ _ init _ _ ( self , _ subtype , boundary , _ subparts , * * _ params )
def _ _ setitem _ _ ( self , name , val ) :
name , val = forbid _ multi _ line _ headers ( name , val , self . encoding )
MIMEMultipart . _ _ setitem _ _ ( self , name , val )
class EmailMessage ( object ) :
content _ subtype = &apos; plain&apos;
mixed _ subtype = &apos; mixed&apos;
encoding = None
def _ _ init _ _ ( self , subject = &apos; &apos; , body = &apos; &apos; , from _ email = None , to = None , bcc = None , connection = None , attachments = None , headers = None , cc = None ) :
if to :
assert not isinstance ( to , six . string _ types ) , &apos; &quot; to &quot; argument must be a list or tuple&apos;
self . to = list ( to )
else :
self . to = &#91; &#93;
if cc :
assert not isinstance ( cc , six . string _ types ) , &apos; &quot; cc &quot; argument must be a list or tuple&apos;
self . cc = list ( cc )
else :
self . cc = &#91; &#93;
if bcc :
assert not isinstance ( bcc , six . string _ types ) , &apos; &quot; bcc &quot; argument must be a list or tuple&apos;
self . bcc = list ( bcc )
else :
self . bcc = &#91; &#93;
self . from _ email = from _ email or settings . default _ FROM _ EMAIL
self . subject = subject
self . body = body
self . attachments = attachments or &#91; &#93;
self . extra _ headers = headers or { }
self . connection = connection
def get _ connection ( self , fail _ silently = False ) :
from django . core . mail import get _ connection
if not self . connection :
self . connection = get _ connection ( fail _ silently = fail _ silently )
return self . connection
def message ( self ) :
encoding = self . encoding or settings . default _ CHARSET
msg = SafeMIMEText ( self . body , self . content _ subtype , encoding )
msg = self . _ create _ message ( msg )
msg &#91; &apos; Subject &apos; &#93; = self . subject
msg &#91; &apos; From &apos; &#93; = self . extra _ headers . get ( &apos; From &apos; , self . from _ email )
msg &#91; &apos; To &apos; &#93; = self . extra _ headers . get ( &apos; To &apos; , &apos; , &apos; . join ( self . to ) )
if self . cc :
msg &#91; &apos; Cc &apos; &#93; = &apos; , &apos; . join ( self . cc )
header _ names = &#91; key . lower ( ) for key in self . extra _ headers &#93;
if &apos; date &apos; not in header _ names :
msg &#91; &apos; Date &apos; &#93; = formatdate ( )
if &apos; message-id &apos; not in header _ names :
msg &#91; &apos; Message-ID &apos; &#93; = make _ msgid ( )
for name , value in self . extra _ headers . items ( ) :
if name . lower ( ) in ( &apos; from &apos; , &apos; to &apos; ) :
continue
msg &#91; name &#93; = value
return msg
def recipients ( self ) :
return self . to + self . cc + self . bcc
def send ( self , fail _ silently = False ) :
if not self . recipients ( ) :
return 0
return self . get _ connection ( fail _ silently ) . send _ messages ( &#91; self &#93; )
def attach ( self , filename = None , content = None , mimetype = None ) :
if isinstance ( filename , MIMEBase ) :
assert content is None
assert mimetype is None
self . attachments . append ( filename )
else :
assert content is not None
self . attachments . append ( ( filename , content , mimetype ) )
def attach _ file ( self , path , mimetype = None ) :
filename = os . path . basename ( path )
with open ( path , &apos; rb &apos; ) as f :
content = f . read ( )
self . attach ( filename , content , mimetype )
def _ create _ message ( self , msg ) :
return self . _ create _ attachments ( msg )
def _ create _ attachments ( self , msg ) :
if self . attachments :
encoding = self . encoding or settings . default _ CHARSET
body _ msg = msg
msg = SafeMIMEMultipart ( _ subtype = self . mixed _ subtype , encoding = encoding )
if self . body :
msg . attach ( body _ msg )
for attachment in self . attachments :
if isinstance ( attachment , MIMEBase ) :
msg . attach ( attachment )
else :
msg . attach ( self . _ create _ attachment ( * attachment ) )
return msg
def _ create _ mime _ attachment ( self , content , mimetype ) :
basetype , subtype = mimetype . split ( &apos; / &apos; , 1 )
if basetype = = &apos; text &apos; :
encoding = self . encoding or settings . default _ CHARSET
attachment = SafeMIMEText ( content , subtype , encoding )
elif basetype = = &apos; message &apos; and subtype = = &apos; rfc822 &apos; :
if isinstance ( content , EmailMessage ) :
content = content . message ( )
elif not isinstance ( content , Message ) :
content = message _ from _ string ( content )
attachment = SafeMIMEMessage ( content , subtype )
else :
attachment = MIMEBase ( basetype , subtype )
attachment . set _ payload ( content )
Encoders . encode _ base64 ( attachment )
return attachment
def _ create _ attachment ( self , filename , content , mimetype = None ) :
if mimetype is None :
mimetype , _ = mimetypes . guess _ type ( filename )
if mimetype is None :
mimetype = DEFAULT _ ATTACHMENT _ MIME _ TYPE
attachment = self . _ create _ mime _ attachment ( content , mimetype )
if filename :
try :
filename . encode ( &apos; ascii &apos; )
except UnicodeEncodeError :
if six . PY2 :
filename = filename . encode ( &apos; utf-8 &apos; )
filename = ( &apos; utf-8 &apos; , &apos; &apos; , filename )
attachment . add _ header ( &apos; Content-Disposition &apos; , &apos; attachment &apos; , filename = filename )
return attachment
class EmailMultiAlternatives ( EmailMessage ) :
alternative _ subtype = &apos; alternative&apos;
def _ _ init _ _ ( self , subject = &apos; &apos; , body = &apos; &apos; , from _ email = None , to = None , bcc = None , connection = None , attachments = None , headers = None , alternatives = None , cc = None ) :
super ( EmailMultiAlternatives , self ) . _ _ init _ _ ( subject , body , from _ email , to , bcc , connection , attachments , headers , cc )
self . alternatives = alternatives or &#91; &#93;
def attach _ alternative ( self , content , mimetype ) :
assert content is not None
assert mimetype is not None
self . alternatives . append ( ( content , mimetype ) )
def _ create _ message ( self , msg ) :
return self . _ create _ attachments ( self . _ create _ alternatives ( msg ) )
def _ create _ alternatives ( self , msg ) :
encoding = self . encoding or settings . default _ CHARSET
if self . alternatives :
body _ msg = msg
msg = SafeMIMEMultipart ( _ subtype = self . alternative _ subtype , encoding = encoding )
if self . body :
msg . attach ( body _ msg )
for alternative in self . alternatives :
msg . attach ( self . _ create _ mime _ attachment ( * alternative ) )
return msg
import socket
class CachedDnsName ( object ) :
def _ _ str _ _ ( self ) :
return self . get _ fqdn ( )
def get _ fqdn ( self ) :
if not hasattr ( self , &apos; _ fqdn &apos; ) :
self . _ fqdn = socket . getfqdn ( )
return self . _ fqdn
DNS _ NAME = CachedDnsName ( )
from _ _ future _ _ import unicode _ literals
import collections
from importlib import import _ module
import os
import sys
import django
from django . apps import apps
from django . conf import settings
from django . core . exceptions import ImproperlyConfigured
from django . core . management . base import ( BaseCommand , CommandError , CommandParser , handle _ default _ options )
from django . core . management . color import color _ style
from django . utils import lru _ cache
from django . utils import six
def find _ commands ( management _ dir ) :
command _ dir = os . path . join ( management _ dir , &apos; commands &apos; )
try :
return &#91; f &#91; : - 3 &#93; for f in os . listdir ( command _ dir ) if not f . startswith ( &apos; _ &apos; ) and f . endswith ( &apos; .py &apos; ) &#93;
except OSError :
return &#91; &#93;
def load _ command _ class ( app _ name , name ) :
module = import _ module ( &apos; % s.management.commands. % s &apos; % ( app _ name , name ) )
return module . command ( )
@ lru _ cache . lru _ cache ( maxsize = None )
def get _ commands ( ) :
commands = { name : &apos; django.core &apos; for name in find _ commands ( _ _ path _ _ &#91; 0 &#93; ) }
if not settings . configured :
return commands
for app _ config in reversed ( list ( apps . get _ app _ configs ( ) ) ) :
path = os . path . join ( app _ config . path , &apos; management &apos; )
commands . update ( { name : app _ config . name for name in find _ commands ( path ) } )
return commands
def call _ command ( name , * args , * * options ) :
try :
app _ name = get _ commands ( ) &#91; name &#93;
except KeyError :
raise CommandError ( &quot; Unknown command : % r &quot; % name )
if isinstance ( app _ name , BaseCommand ) :
command = app _ name
else :
command = load _ command _ class ( app _ name , name )
parser = command . create _ parser ( &apos; &apos; , name )
if command . use _ argparse :
defaults = parser . parse _ args ( args = args )
defaults = dict ( defaults . _ get _ kwargs ( ) , * * options )
else :
defaults , _ = parser . parse _ args ( args = &#91; &#93; )
defaults = dict ( defaults . _ _ dict _ _ , * * options )
return command . execute ( * args , * * defaults )
class ManagementUtility ( object ) :
def _ _ init _ _ ( self , argv = None ) :
self . argv = argv or sys . argv &#91; : &#93;
self . prog _ name = os . path . basename ( self . argv &#91; 0 &#93; )
self . settings _ exception = None
def main _ help _ text ( self , commands _ only = False ) :
if commands _ only :
usage = sorted ( get _ commands ( ) . keys ( ) )
else :
usage = &#91; &quot; &quot; , &quot; Type &apos; % s help &lt; subcommand &gt; &apos; for help on a specific subcommand . &quot; % self . prog _ name , &quot; &quot; , &quot; Available subcommands : &quot; , &#93;
commands _ dict = collections . defaultdict ( lambda : &#91; &#93; )
for name , app in six . iteritems ( get _ commands ( ) ) :
if app = = &apos; django.core &apos; :
app = &apos; django&apos;
else :
app = app . rpartition ( &apos; .&apos; ) &#91; - 1 &#93;
commands _ dict &#91; app &#93; . append ( name )
style = color _ style ( )
for app in sorted ( commands _ dict . keys ( ) ) :
usage . append ( &quot; &quot; )
usage . append ( style . Notice ( &quot; &#91; % s &#93; &quot; % app ) )
for name in sorted ( commands _ dict &#91; app &#93; ) :
usage . append ( &quot; % s &quot; % name )
if self . settings _ exception is not None :
usage . append ( style . Notice ( &quot; Note that only Django core commands are listed &quot; &quot; as settings are not properly configured ( error : % s ) . &quot; % self . settings _ exception ) )
return &apos; \ n &apos; . join ( usage )
def fetch _ command ( self , subcommand ) :
commands = get _ commands ( )
try :
app _ name = commands &#91; subcommand &#93;
except KeyError :
settings . installed _ APPS
sys . stderr . write ( &quot; Unknown command : % r \ nType &apos; % s help &apos; for usage . \ n &quot; % ( subcommand , self . prog _ name ) )
sys . exit ( 1 )
if isinstance ( app _ name , BaseCommand ) :
klass = app _ name
else :
klass = load _ command _ class ( app _ name , subcommand )
return klass
def autocomplete ( self ) :
if &apos; DJANGO _ AUTO _ COMPLETE &apos; not in os . environ :
return
cwords = os . environ &#91; &apos; COMP _ WORDS &apos; &#93; . split ( ) &#91; 1 : &#93;
cword = int ( os . environ &#91; &apos; COMP _ CWORD &apos; &#93; )
try :
curr = cwords &#91; cword - 1 &#93;
except IndexError :
curr = &apos; &apos;
subcommands = list ( get _ commands ( ) ) + &#91; &apos; help &apos; &#93;
options = &#91; ( &apos; --help &apos; , None ) &#93;
if cword = = 1 :
print ( &apos; &apos; . join ( sorted ( filter ( lambda x : x . startswith ( curr ) , subcommands ) ) ) )
elif cwords &#91; 0 &#93; in subcommands and cwords &#91; 0 &#93; ! = &apos; help &apos; :
subcommand _ cls = self . fetch _ command ( cwords &#91; 0 &#93; )
if cwords &#91; 0 &#93; = = &apos; runfcgi &apos; :
from django . core . servers . FASTCGI import FASTCGI _ OPTIONS
options + = &#91; ( k , 1 ) for k in FASTCGI _ OPTIONS &#93;
elif cwords &#91; 0 &#93; in ( &apos; dumpdata &apos; , &apos; sql &apos; , &apos; sqlall &apos; , &apos; sqlclear &apos; , &apos; sqlcustom &apos; , &apos; sqlindexes &apos; , &apos; sqlsequencereset &apos; , &apos; test &apos; ) :
try :
app _ configs = apps . get _ app _ configs ( )
options + = &#91; ( app _ config . label , 0 ) for app _ config in app _ configs &#93;
except ImportError :
pass
parser = subcommand _ cls . create _ parser ( &apos; &apos; , cwords &#91; 0 &#93; )
if subcommand _ cls . use _ argparse :
options + = &#91; ( sorted ( s _ opt . option _ strings ) &#91; 0 &#93; , s _ opt . nargs ! = 0 ) for s _ opt in parser . _ actions if s _ opt . option _ strings &#93;
else :
options + = &#91; ( s _ opt . get _ opt _ string ( ) , s _ opt . nargs ) for s _ opt in parser . option _ list &#93;
PREV _ opts = &#91; x . split ( &apos; = &apos; ) &#91; 0 &#93; for x in cwords &#91; 1 : cword - 1 &#93; &#93;
options = &#91; opt for opt in options if opt &#91; 0 &#93; not in prev _ opts &#93;
options = sorted ( ( k , v ) for k , v in options if k . startswith ( curr ) )
for option in options :
opt _ label = option &#91; 0 &#93;
if option &#91; 1 &#93; :
opt _ label + = &apos; = &apos;
print ( opt _ label )
sys . exit ( 1 )
def execute ( self ) :
try :
subcommand = self . argv &#91; 1 &#93;
except IndexError :
subcommand = &apos; help&apos;
parser = CommandParser ( None , usage = &quot; % ( prog ) s subcommand &#91; options &#93; &#91; args &#93; &quot; , add _ help = False )
parser . add _ argument ( &apos; --settings &apos; )
parser . add _ argument ( &apos; --pythonpath &apos; )
parser . add _ argument ( &apos; args &apos; , nargs = &apos; * &apos; )
try :
options , args = parser . parse _ known _ args ( self . argv &#91; 2 : &#93; )
handle _ default _ options ( options )
except CommandError :
pass
no _ settings _ commands = &#91; &apos; help &apos; , &apos; version &apos; , &apos; --help &apos; , &apos; --version &apos; , &apos; -h &apos; , &apos; compilemessages &apos; , &apos; makemessages &apos; , &apos; startapp &apos; , &apos; startproject &apos; , &#93;
try :
settings . installed _ APPS
except ImproperlyConfigured as exc :
self . settings _ exception = exc
if subcommand in no _ settings _ commands :
settings . configure ( )
if settings . configured :
Django . setup ( )
self . autocomplete ( )
if subcommand = = &apos; help &apos; :
if &apos; --commands &apos; in args :
sys . stdout . write ( self . main _ help _ text ( commands _ only = True ) + &apos; \ n &apos; )
elif len ( options . args ) &lt; 1 :
sys . stdout . write ( self . main _ help _ text ( ) + &apos; \ n &apos; )
else :
self . fetch _ command ( options . args &#91; 0 &#93; ) . print _ help ( self . prog _ name , options . args &#91; 0 &#93; )
elif subcommand = = &apos; version &apos; or self . argv &#91; 1 : &#93; = = &#91; &apos; --version &apos; &#93; :
sys . stdout . write ( django . get _ version ( ) + &apos; \ n &apos; )
elif self . argv &#91; 1 : &#93; in ( &#91; &apos; --help &apos; &#93; , &#91; &apos; -h &apos; &#93; ) :
sys . stdout . write ( self . main _ help _ text ( ) + &apos; \ n &apos; )
else :
self . fetch _ command ( subcommand ) . run _ from _ argv ( self . argv )
def execute _ from _ command _ line ( argv = None ) :
utility = ManagementUtility ( argv )
utility . execute ( )
from _ _ future _ _ import unicode _ literals
import os
import sys
import warnings
from argparse import ArgumentParser
from optparse import OptionParser
import django
from django . core import checks
from django . core . exceptions import ImproperlyConfigured
from django . core . management . color import color _ style , no _ style
from django . utils . deprecation import RemovedInDjango19Warning , RemovedInDjango20Warning
from django . utils . encoding import force _ str
class CommandError ( Exception ) :
pass
class CommandParser ( ArgumentParser ) :
def _ _ init _ _ ( self , cmd , * * kwargs ) :
self . cmd = cmd
super ( CommandParser , self ) . _ _ init _ _ ( * * kwargs )
def parse _ args ( self , args = None , namespace = None ) :
if ( hasattr ( self . cmd , &apos; missing _ args _ message &apos; ) and not ( args or any ( &#91; not arg . startswith ( &apos; -&apos; ) for arg in args &#93; ) ) ) :
self . error ( self . cmd . missing _ args _ message )
return super ( CommandParser , self ) . parse _ args ( args , namespace )
def error ( self , message ) :
if self . cmd . _ called _ from _ command _ line :
super ( CommandParser , self ) . error ( message )
else :
raise CommandError ( &quot; Error : % s &quot; % message )
def handle _ default _ options ( options ) :
if options . settings :
os . environ &#91; &apos; DJANGO _ SETTINGS _ MODULE &apos; &#93; = options . settings
if options . PYTHONPATH :
sys . path . insert ( 0 , options . PYTHONPATH )
class OutputWrapper ( object ) :
def _ _ init _ _ ( self , out , style _ func = None , ending = &apos; \ n &apos; ) :
self . _ out = out
self . style _ func = None
if hasattr ( out , &apos; isatty &apos; ) and out . isatty ( ) :
self . style _ func = style _ func
self . ending = ending
def _ _ getattr _ _ ( self , name ) :
return getattr ( self . _ out , name )
def write ( self , msg , style _ func = None , ending = None ) :
ending = self . ending if ending is None else ending
if ending and not msg . endswith ( ending ) :
msg + = ending
style _ func = &#91; f for f in ( style _ func , self . style _ func , lambda x : x ) if f is not None &#93; &#91; 0 &#93;
self . _ out . write ( force _ str ( style _ func ( msg ) ) )
class BaseCommand ( object ) :
option _ list = ( )
help = &apos; &apos;
args = &apos; &apos;
_ called _ from _ command _ line = False
can _ import _ settings = True
output _ transaction = False
leave _ locale _ alone = False
def _ _ init _ _ ( self ) :
self . style = color _ style ( )
has _ old _ option = hasattr ( self , &apos; requires _ model _ validation &apos; )
has _ new _ option = hasattr ( self , &apos; requires _ system _ checks &apos; )
if has _ old _ option :
warnings . warn ( &apos; &quot; requires _ model _ validation &quot; is deprecated &apos; &apos; in favor of &quot; requires _ system _ checks &quot; . &apos; , RemovedInDjango19Warning )
if has _ old _ option and has _ new _ option :
raise ImproperlyConfigured ( &apos; Command % s defines both &quot; requires _ model _ validation &quot; &apos; &apos; and &quot; requires _ system _ checks &quot; , which is illegal . use only &apos; &apos; &quot; requires _ system _ checks &quot; . &apos; % self . _ _ class _ _ . _ _ name _ _ )
self . requires _ system _ checks = ( self . requires _ system _ checks if has _ new _ option else self . requires _ model _ validation if has _ old _ option else True )
@ property
def use _ argparse ( self ) :
return not bool ( self . option _ list )
def get _ version ( self ) :
return django . get _ version ( )
def usage ( self , subcommand ) :
usage = &apos; % % prog % s &#91; options &#93; % s &apos; % ( subcommand , self . args )
if self . help :
return &apos; % s \ n \ n % s &apos; % ( usage , self . help )
else :
return usage
def create _ parser ( self , prog _ name , subcommand ) :
if not self . use _ argparse :
warnings . warn ( &quot; OptionParser usage for Django management commands &quot; &quot; is deprecated , use ArgumentParser instead &quot; , RemovedInDjango20Warning )
parser = OptionParser ( prog = prog _ name , usage = self . usage ( subcommand ) , version = self . get _ version ( ) )
parser . add _ option ( &apos; -v &apos; , &apos; --verbosity &apos; , action = &apos; store &apos; , dest = &apos; verbosity &apos; , default = &apos; 1&apos; , type = &apos; choice &apos; , choices = &#91; &apos; 0&apos; , &apos; 1&apos; , &apos; 2&apos; , &apos; 3&apos; &#93; , help = &apos; Verbosity level ; 0 = minimal output , 1 = normal output , 2 = verbose output , 3 = very verbose output &apos; )
parser . add _ option ( &apos; --settings &apos; , help = &apos; The Python path to a settings module , e.g. &quot; myproject.settings.main &quot; . if this isn \ &apos; t provided , the DJANGO _ SETTINGS _ MODULE environment variable will be used . &apos; )
parser . add _ option ( &apos; --pythonpath &apos; , help = &apos; A directory to add to the Python path , e.g. &quot; / home / djangoprojects / myproject &quot; . &apos; ) ,
parser . add _ option ( &apos; --traceback &apos; , action = &apos; store _ true &apos; , help = &apos; Raise on exception &apos; )
parser . add _ option ( &apos; --no-color &apos; , action = &apos; store _ true &apos; , dest = &apos; no _ color &apos; , default = False , help = &quot; Don &apos;t colorize the command output . &quot; )
for opt in self . option _ list :
parser . add _ option ( opt )
else :
parser = CommandParser ( self , prog = &quot; % s % s &quot; % ( os . path . basename ( prog _ name ) , subcommand ) , description = self . help or None )
parser . add _ argument ( &apos; --version &apos; , action = &apos; version &apos; , version = self . get _ version ( ) )
parser . add _ argument ( &apos; -v &apos; , &apos; --verbosity &apos; , action = &apos; store &apos; , dest = &apos; verbosity &apos; , default = &apos; 1&apos; , type = int , choices = &#91; 0 , 1 , 2 , 3 &#93; , help = &apos; Verbosity level ; 0 = minimal output , 1 = normal output , 2 = verbose output , 3 = very verbose output &apos; )
parser . add _ argument ( &apos; --settings &apos; , help = &apos; The Python path to a settings module , e.g. &quot; myproject.settings.main &quot; . if this isn \ &apos; t provided , the DJANGO _ SETTINGS _ MODULE environment variable will be used . &apos; )
parser . add _ argument ( &apos; --pythonpath &apos; , help = &apos; A directory to add to the Python path , e.g. &quot; / home / djangoprojects / myproject &quot; . &apos; )
parser . add _ argument ( &apos; --traceback &apos; , action = &apos; store _ true &apos; , help = &apos; Raise on exception &apos; )
parser . add _ argument ( &apos; --no-color &apos; , action = &apos; store _ true &apos; , dest = &apos; no _ color &apos; , default = False , help = &quot; Don &apos;t colorize the command output . &quot; )
if self . args :
parser . add _ argument ( &apos; args &apos; , nargs = &apos; * &apos; )
self . add _ arguments ( parser )
return parser
def add _ arguments ( self , parser ) :
pass
def print _ help ( self , prog _ name , subcommand ) :
parser = self . create _ parser ( prog _ name , subcommand )
parser . print _ help ( )
def run _ from _ argv ( self , argv ) :
self . _ called _ from _ command _ line = True
parser = self . create _ parser ( argv &#91; 0 &#93; , argv &#91; 1 &#93; )
if self . use _ argparse :
options = parser . parse _ args ( argv &#91; 2 : &#93; )
cmd _ options = vars ( options )
if &apos; args &apos; in options :
args = options . args
del cmd _ options &#91; &apos; args &apos; &#93;
else :
args = ( )
else :
options , args = parser . parse _ args ( argv &#91; 2 : &#93; )
cmd _ options = vars ( options )
handle _ default _ options ( options )
try :
self . execute ( * args , * * cmd _ options )
except Exception as e :
if options . traceback or not isinstance ( e , CommandError ) :
raise
stderr = getattr ( self , &apos; stderr &apos; , OutputWrapper ( sys . stderr , self . style . error ) )
stderr . write ( &apos; % s : % s &apos; % ( e . _ _ class _ _ . _ _ name _ _ , e ) )
sys . exit ( 1 )
def execute ( self , * args , * * options ) :
self . stdout = OutputWrapper ( options . get ( &apos; stdout &apos; , sys . stdout ) )
if options . get ( &apos; no _ color &apos; ) :
self . style = no _ style ( )
self . stderr = OutputWrapper ( options . get ( &apos; stderr &apos; , sys . stderr ) )
else :
self . stderr = OutputWrapper ( options . get ( &apos; stderr &apos; , sys . stderr ) , self . style . error )
if self . can _ import _ settings :
from django . conf import settings
saved _ locale = None
if not self . leave _ locale _ alone :
if not self . can _ import _ settings :
raise CommandError ( &quot; Incompatible values of &apos; leave _ locale _ alone &apos; &quot; &quot; ( % s ) and &apos; can _ import _ settings &apos; ( % s ) command &quot; &quot; options . &quot; % ( self . leave _ locale _ alone , self . can _ import _ settings ) )
from django . utils import translation
saved _ locale = translation . get _ language ( )
translation . activate ( &apos; en-us &apos; )
try :
if ( self . requires _ system _ checks and not options . get ( &apos; skip _ validation &apos; ) and not options . get ( &apos; skip _ checks &apos; ) ) :
self . check ( )
output = self . handle ( * args , * * options )
if output :
if self . output _ transaction :
from django . db import connections , DEFAULT _ DB _ ALIAS
connection = connections &#91; options . get ( &apos; database &apos; , DEFAULT _ DB _ ALIAS ) &#93;
if connection . ops . start _ transaction _ sql ( ) :
self . stdout . write ( self . style . sql _ KEYWORD ( connection . ops . start _ transaction _ sql ( ) ) )
self . stdout . write ( output )
if self . output _ transaction :
self . stdout . write ( &apos; \ n &apos; + self . style . sql _ KEYWORD ( connection . ops . end _ transaction _ sql ( ) ) )
finally :
if saved _ locale is not None :
translation . activate ( saved _ locale )
def validate ( self , app _ config = None , display _ num _ errors = False ) :
if app _ config is None :
app _ configs = None
else :
app _ configs = &#91; app _ config &#93;
return self . check ( app _ configs = app _ configs , display _ num _ errors = display _ num _ errors )
def check ( self , app _ configs = None , tags = None , display _ num _ errors = False ) :
all _ issues = checks . run _ checks ( app _ configs = app _ configs , tags = tags )
msg = &quot; &quot;
visible _ issue _ count = 0
if all _ issues :
debugs = &#91; e for e in all _ issues if e . level &lt; checks . info and not e . is _ silenced ( ) &#93;
infos = &#91; e for e in all _ issues if checks . info &lt; = e . level &lt; checks . warning and not e . is _ silenced ( ) &#93;
warnings = &#91; e for e in all _ issues if checks . warning &lt; = e . level &lt; checks . error and not e . is _ silenced ( ) &#93;
errors = &#91; e for e in all _ issues if checks . error &lt; = e . level &lt; checks . Critical &#93;
CRITICALS = &#91; e for e in all _ issues if checks . Critical &lt; = e . level &#93;
sorted _ issues = &#91; ( criticals , &apos; CRITICALS &apos; ) , ( errors , &apos; ERRORS &apos; ) , ( warnings , &apos; WARNINGS &apos; ) , ( infos , &apos; INFOS &apos; ) , ( debugs , &apos; debugs &apos; ) , &#93;
for issues , group _ name in sorted _ issues :
if issues :
visible _ issue _ count + = len ( issues )
formatted = ( color _ style ( ) . error ( force _ str ( e ) ) if e . is _ serious ( ) else color _ style ( ) . warning ( force _ str ( e ) ) for e in issues )
formatted = &quot; \ n &quot; . join ( sorted ( formatted ) )
msg + = &apos; \ n % s : \ n % s \ n &apos; % ( group _ name , formatted )
if msg :
msg = &quot; System check identified some issues : \ n % s &quot; % msg
if display _ num _ errors :
if msg :
msg + = &apos; \ n&apos;
msg + = &quot; System check identified % s ( % s silenced ) . &quot; % ( &quot; no issues &quot; if visible _ issue _ count = = 0 else &quot; 1 issue &quot; if visible _ issue _ count = = 1 else &quot; % s issues &quot; % visible _ issue _ count , len ( all _ issues ) - visible _ issue _ count , )
if any ( e . is _ serious ( ) and not e . is _ silenced ( ) for e in all _ issues ) :
raise CommandError ( msg )
elif msg and visible _ issue _ count :
self . stderr . write ( msg )
elif msg :
self . stdout . write ( msg )
def handle ( self , * args , * * options ) :
raise NotImplementedError ( &apos; subclasses of BaseCommand must provide a handle ( ) method &apos; )
class AppCommand ( BaseCommand ) :
missing _ args _ message = &quot; Enter at least one application label . &quot;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; args &apos; , metavar = &apos; app _ label &apos; , nargs = &apos; + &apos; , help = &apos; One or more application label . &apos; )
def handle ( self , * app _ labels , * * options ) :
from django . apps import apps
try :
app _ configs = &#91; apps . get _ app _ config ( app _ label ) for app _ label in app _ labels &#93;
except ( LookupError , ImportError ) as e :
raise CommandError ( &quot; % s . are you sure your INSTALLED _ APPS setting is correct ? &quot; % e )
output = &#91; &#93;
for app _ config in app _ configs :
app _ output = self . handle _ app _ config ( app _ config , * * options )
if app _ output :
output . append ( app _ output )
return &apos; \ n &apos; . join ( output )
def handle _ app _ config ( self , app _ config , * * options ) :
try :
handle _ app = self . handle _ app
except AttributeError :
raise NotImplementedError ( &quot; Subclasses of AppCommand must provide &quot; &quot; a handle _ app _ config ( ) method . &quot; )
else :
warnings . warn ( &quot; AppCommand.handle _ app ( ) is superseded by &quot; &quot; AppCommand.handle _ app _ config ( ) . &quot; , RemovedInDjango19Warning , stacklevel = 2 )
if app _ config . models _ module is None :
raise CommandError ( &quot; AppCommand cannot handle app &apos; % s &apos; in legacy mode &quot; &quot; because it doesn &apos;t have a models module . &quot; % app _ config . label )
return handle _ app ( app _ config . models _ module , * * options )
class LabelCommand ( BaseCommand ) :
label = &apos; label&apos;
missing _ args _ message = &quot; Enter at least one % s . &quot; % label
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; args &apos; , metavar = self . label , nargs = &apos; + &apos; )
def handle ( self , * labels , * * options ) :
output = &#91; &#93;
for label in labels :
label _ output = self . handle _ label ( label , * * options )
if label _ output :
output . append ( label _ output )
return &apos; \ n &apos; . join ( output )
def handle _ label ( self , label , * * options ) :
raise NotImplementedError ( &apos; subclasses of LabelCommand must provide a handle _ label ( ) method &apos; )
class NoArgsCommand ( BaseCommand ) :
args = &apos; &apos;
def _ _ init _ _ ( self ) :
warnings . warn ( &quot; NoArgsCommand class is deprecated and will be removed in Django 2.0 . &quot; &quot; use BaseCommand instead , which takes no arguments by default . &quot; , RemovedInDjango20Warning )
super ( NoArgsCommand , self ) . _ _ init _ _ ( )
def handle ( self , * args , * * options ) :
if args :
raise CommandError ( &quot; Command doesn &apos;t accept any arguments &quot; )
return self . handle _ noargs ( * * options )
def handle _ noargs ( self , * * options ) :
raise NotImplementedError ( &apos; subclasses of NoArgsCommand must provide a handle _ noargs ( ) method &apos; )
import os
import sys
from django . utils import termcolors
def supports _ color ( ) :
plat = sys . platform
supported _ platform = plat ! = &apos; Pocket PC &apos; and ( plat ! = &apos; win32 &apos; or &apos; ANSICON &apos; in os . environ )
is _ a _ tty = hasattr ( sys . stdout , &apos; isatty &apos; ) and sys . stdout . isatty ( )
if not supported _ platform or not is _ a _ tty :
return False
return True
def color _ style ( ) :
if not supports _ color ( ) :
style = no _ style ( )
else :
Django _ COLORS = os . environ . get ( &apos; DJANGO _ COLORS &apos; , &apos; &apos; )
color _ settings = termcolors . parse _ color _ setting ( DJANGO _ COLORS )
if color _ settings :
class dummy :
pass
style = dummy ( )
for role in termcolors . PALETTES &#91; termcolors . NOCOLOR _ PALETTE &#93; :
format = color _ settings . get ( role , { } )
setattr ( style , role , termcolors . make _ style ( * * format ) )
style . error _ OUTPUT = style . error
else :
style = no _ style ( )
return style
def no _ style ( ) :
class dummy :
def _ _ getattr _ _ ( self , attr ) :
return lambda x : x
return dummy ( )
from _ _ future _ _ import unicode _ literals
from django . apps import apps
from django . core import checks
from django . core . checks . registry import registry
from django . core . management . base import BaseCommand , CommandError
class Command ( BaseCommand ) :
help = &quot; Checks the entire Django project for potential problems . &quot;
requires _ system _ checks = False
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; args &apos; , metavar = &apos; app _ label &apos; , nargs = &apos; * &apos; )
parser . add _ argument ( &apos; --tag &apos; , &apos; -t &apos; , action = &apos; append &apos; , dest = &apos; tags &apos; , help = &apos; Run only checks labeled with given tag . &apos; )
parser . add _ argument ( &apos; --list-tags &apos; , action = &apos; store _ true &apos; , dest = &apos; list _ tags &apos; , help = &apos; List available tags . &apos; )
def handle ( self , * app _ labels , * * options ) :
if options . get ( &apos; list _ tags &apos; ) :
self . stdout . write ( &apos; \ n &apos; . join ( sorted ( registry . tags _ available ( ) ) ) )
return
if app _ labels :
app _ configs = &#91; apps . get _ app _ config ( app _ label ) for app _ label in app _ labels &#93;
else :
app _ configs = None
tags = options . get ( &apos; tags &apos; , None )
if tags and any ( not checks . tag _ exists ( tag ) for tag in tags ) :
invalid _ tag = next ( tag for tag in tags if not checks . tag _ exists ( tag ) )
raise CommandError ( &apos; There is no system check with the &quot; % s &quot; tag . &apos; % invalid _ tag )
self . check ( app _ configs = app _ configs , tags = tags , display _ num _ errors = True )
from _ _ future _ _ import unicode _ literals
import codecs
import glob
import os
from django . core . management . base import BaseCommand , CommandError
from django . core . management . utils import find _ command , popen _ wrapper
from django . utils . _ os import npath , upath
def has _ bom ( fn ) :
with open ( fn , &apos; rb &apos; ) as f :
sample = f . read ( 4 )
return sample &#91; : 3 &#93; = = b &apos; \ xef \ xbb \ xbf &apos; or sample . startswith ( codecs . BOM _ UTF16 _ LE ) or sample . startswith ( codecs . BOM _ UTF16 _ BE )
def is _ writable ( path ) :
try :
with open ( path , &apos; a &apos; ) :
os . utime ( path , None )
except ( IOError , OSError ) :
return False
return True
class Command ( BaseCommand ) :
help = &apos; Compiles .po files to .mo files for use with builtin gettext support . &apos;
requires _ system _ checks = False
leave _ locale _ alone = True
program = &apos; msgfmt&apos;
program _ options = &#91; &apos; --check-format &apos; &#93;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; --locale &apos; , &apos; -l &apos; , dest = &apos; locale &apos; , action = &apos; append &apos; , default = &#91; &#93; , help = &apos; Locale ( s ) to process ( e.g. de _ AT ) . default is to process all . &apos; &apos; can be used multiple times . &apos; )
parser . add _ argument ( &apos; --exclude &apos; , &apos; -x &apos; , dest = &apos; exclude &apos; , action = &apos; append &apos; , default = &#91; &#93; , help = &apos; Locales to exclude . default is none . can be used multiple times . &apos; )
def handle ( self , * * options ) :
locale = options . get ( &apos; locale &apos; )
exclude = options . get ( &apos; exclude &apos; )
self . verbosity = int ( options . get ( &apos; verbosity &apos; ) )
if find _ command ( self . program ) is None :
raise CommandError ( &quot; Can &apos;t find % s . make sure you have GNU gettext &quot; &quot; tools 0.15 or newer installed . &quot; % self . program )
basedirs = &#91; os . path . join ( &apos; conf &apos; , &apos; locale &apos; ) , &apos; locale &apos; &#93;
if os . environ . get ( &apos; DJANGO _ SETTINGS _ MODULE &apos; ) :
from django . conf import settings
basedirs . extend ( &#91; upath ( path ) for path in settings . locale _ PATHS &#93; )
basedirs = set ( map ( os . path . abspath , filter ( os . path . isdir , basedirs ) ) )
if not basedirs :
raise CommandError ( &quot; This script should be run from the Django Git &quot; &quot; checkout or your project or app tree , or with &quot; &quot; the settings module specified . &quot; )
all _ locales = &#91; &#93;
for basedir in basedirs :
locale _ dirs = filter ( os . path . isdir , glob . glob ( &apos; % s / * &apos; % basedir ) )
all _ locales . extend ( map ( os . path . basename , locale _ dirs ) )
locales = locale or all _ locales
locales = set ( locales ) - set ( exclude )
for basedir in basedirs :
if locales :
dirs = &#91; os . path . join ( basedir , l , &apos; LC _ MESSAGES &apos; ) for l in locales &#93;
else :
dirs = &#91; basedir &#93;
locations = &#91; &#93;
for ldir in dirs :
for dirpath , dirnames , filenames in os . walk ( ldir ) :
locations . extend ( ( dirpath , f ) for f in filenames if f . endswith ( &apos; .po &apos; ) )
if locations :
self . compile _ messages ( locations )
def compile _ messages ( self , locations ) :
for i , ( dirpath , f ) in enumerate ( locations ) :
if self . verbosity &gt; 0 :
self . stdout . write ( &apos; processing file % s in % s \ n &apos; % ( f , dirpath ) )
po _ path = os . path . join ( dirpath , f )
if has _ bom ( po _ path ) :
raise CommandError ( &quot; The % s file has a BOM ( Byte Order Mark ) . &quot; &quot; Django only supports .po files encoded in &quot; &quot; UTF-8 and without any BOM . &quot; % po _ path )
base _ path = os . path . splitext ( po _ path ) &#91; 0 &#93;
if i = = 0 and not is _ writable ( npath ( base _ path + &apos; .mo &apos; ) ) :
self . stderr . write ( &quot; The po files under % s are in a seemingly not writable location . &quot; &quot; mo files will not be updated / created . &quot; % dirpath )
return
args = &#91; self . program &#93; + self . program _ options + &#91; &apos; -o &apos; , npath ( base _ path + &apos; .mo &apos; ) , npath ( base _ path + &apos; .po &apos; ) &#93;
output , errors , status = popen _ wrapper ( args )
if status :
if errors :
msg = &quot; Execution of % s failed : % s &quot; % ( self . program , errors )
else :
msg = &quot; Execution of % s failed &quot; % self . program
raise CommandError ( msg )
from django . conf import settings
from django . core . cache import caches
from django . core . cache . backends . db import BaseDatabaseCache
from django . core . management . base import BaseCommand , CommandError
from django . db import connections , router , transaction , models , DEFAULT _ DB _ ALIAS
from django . db . utils import DatabaseError
from django . utils . encoding import force _ text
class Command ( BaseCommand ) :
help = &quot; Creates the tables needed to use the SQL cache backend . &quot;
requires _ system _ checks = False
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; args &apos; , metavar = &apos; table _ name &apos; , nargs = &apos; * &apos; , help = &apos; Optional table names . otherwise , settings.CACHES is used to &apos; &apos; find cache tables . &apos; )
parser . add _ argument ( &apos; --database &apos; , action = &apos; store &apos; , dest = &apos; database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database onto which the cache tables will be &apos; &apos; installed . defaults to the &quot; default &quot; database . &apos; )
def handle ( self , * tablenames , * * options ) :
db = options . get ( &apos; database &apos; )
self . verbosity = int ( options . get ( &apos; verbosity &apos; ) )
if len ( tablenames ) :
for tablename in tablenames :
self . create _ table ( db , tablename )
else :
for cache _ alias in settings . caches :
cache = caches &#91; cache _ alias &#93;
if isinstance ( cache , BaseDatabaseCache ) :
self . create _ table ( db , cache . _ table )
def create _ table ( self , database , tablename ) :
cache = BaseDatabaseCache ( tablename , { } )
if not router . allow _ migrate ( database , cache . cache _ model _ class ) :
return
connection = connections &#91; database &#93;
if tablename in connection . introspection . table _ names ( ) :
if self . verbosity &gt; 0 :
self . stdout . write ( &quot; Cache table &apos; % s &apos; already exists . &quot; % tablename )
return
fields = ( models . CharField ( name = &apos; cache _ key &apos; , max _ length = 255 , unique = True , primary _ key = True ) , models . TextField ( name = &apos; value &apos; ) , models . DateTimeField ( name = &apos; expires &apos; , db _ index = True ) , )
table _ output = &#91; &#93;
index _ output = &#91; &#93;
qn = connection . ops . quote _ name
for f in fields :
field _ output = &#91; qn ( f . name ) , f . db _ type ( connection = connection ) &#93;
field _ output . append ( &quot; % sNULL &quot; % ( &quot; NOT &quot; if not f . null else &quot; &quot; ) )
if f . primary _ key :
field _ output . append ( &quot; PRIMARY KEY &quot; )
elif f . unique :
field _ output . append ( &quot; UNIQUE &quot; )
if f . db _ index :
unique = &quot; UNIQUE &quot; if f . unique else &quot; &quot;
index _ output . append ( &quot; CREATE % sINDEX % s ON % s ( % s ) ; &quot; % ( unique , qn ( &apos; % s _ % s &apos; % ( tablename , f . name ) ) , qn ( tablename ) , qn ( f . name ) ) )
table _ output . append ( &quot; &quot; . join ( field _ output ) )
full _ statement = &#91; &quot; CREATE TABLE % s ( &quot; % qn ( tablename ) &#93;
for i , line in enumerate ( table _ output ) :
full _ statement . append ( &apos; % s % s &apos; % ( line , &apos; , &apos; if i &lt; len ( table _ output ) - 1 else &apos; &apos; ) )
full _ statement . append ( &apos; ) ; &apos; )
with transaction . atomic ( using = database , savepoint = connection . features . can _ rollback _ ddl ) :
with connection . cursor ( ) as curs :
try :
curs . execute ( &quot; \ n &quot; . join ( full _ statement ) )
except DatabaseError as e :
raise CommandError ( &quot; Cache table &apos; % s &apos; could not be created . \ nThe error was : % s . &quot; % ( tablename , force _ text ( e ) ) )
for statement in index _ output :
curs . execute ( statement )
if self . verbosity &gt; 1 :
self . stdout . write ( &quot; Cache table &apos; % s &apos; created . &quot; % tablename )
from django . core . management . base import BaseCommand , CommandError
from django . db import connections , DEFAULT _ DB _ ALIAS
class Command ( BaseCommand ) :
help = ( &quot; Runs the command-line client for specified database , or the &quot; &quot; default database if none is provided . &quot; )
requires _ system _ checks = False
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; --database &apos; , action = &apos; store &apos; , dest = &apos; database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database onto which to &apos; &apos; open a shell . defaults to the &quot; default &quot; database . &apos; )
def handle ( self , * * options ) :
connection = connections &#91; options . get ( &apos; database &apos; ) &#93;
try :
connection . client . runshell ( )
except OSError :
raise CommandError ( &apos; You appear not to have the % r program installed or on your path . &apos; % connection . client . executable _ name )
from django . core . management . base import BaseCommand
def module _ to _ dict ( module , omittable = lambda k : k . startswith ( &apos; _ &apos; ) ) :
return dict ( ( k , repr ( v ) ) for k , v in module . _ _ dict _ _ . items ( ) if not omittable ( k ) )
class Command ( BaseCommand ) :
requires _ system _ checks = False
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; --all &apos; , action = &apos; store _ true &apos; , dest = &apos; all &apos; , default = False , help = &apos; Display all settings , regardless of their value . &apos; &apos; default values are prefixed by &quot; # # # &quot; . &apos; )
def handle ( self , * * options ) :
from django . conf import settings , global _ settings
settings . _ setup ( )
user _ settings = module _ to _ dict ( settings . _ wrapped )
default _ settings = module _ to _ dict ( global _ settings )
output = &#91; &#93;
for key in sorted ( user _ settings ) :
if key not in default _ settings :
output . append ( &quot; % s = % s # # # &quot; % ( key , user _ settings &#91; key &#93; ) )
elif user _ settings &#91; key &#93; ! = default _ settings &#91; key &#93; :
output . append ( &quot; % s = % s &quot; % ( key , user _ settings &#91; key &#93; ) )
elif options &#91; &apos; all &apos; &#93; :
output . append ( &quot; # # # % s = % s &quot; % ( key , user _ settings &#91; key &#93; ) )
return &apos; \ n &apos; . join ( output )
import warnings
from collections import OrderedDict
from django . apps import apps
from django . core . management . base import BaseCommand , CommandError
from django . core import serializers
from django . db import router , DEFAULT _ DB _ ALIAS
from django . utils . deprecation import RemovedInDjango19Warning
class Command ( BaseCommand ) :
help = ( &quot; Output the contents of the database as a fixture of the given &quot; &quot; format ( using each model &apos;s default manager unless --all is &quot; &quot; specified ) . &quot; )
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; args &apos; , metavar = &apos; app _ label &#91; .ModelName &#93; &apos; , nargs = &apos; * &apos; , help = &apos; Restricts dumped data to the specified app _ label or app _ label.ModelName. &apos; )
parser . add _ argument ( &apos; --format &apos; , default = &apos; json &apos; , dest = &apos; format &apos; , help = &apos; Specifies the output serialization format for fixtures . &apos; )
parser . add _ argument ( &apos; --indent &apos; , default = None , dest = &apos; indent &apos; , type = int , help = &apos; Specifies the indent level to use when pretty-printing output . &apos; )
parser . add _ argument ( &apos; --database &apos; , action = &apos; store &apos; , dest = &apos; database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a specific database to dump fixtures from . &apos; &apos; defaults to the &quot; default &quot; database . &apos; )
parser . add _ argument ( &apos; -e &apos; , &apos; --exclude &apos; , dest = &apos; exclude &apos; , action = &apos; append &apos; , default = &#91; &#93; , help = &apos; An app _ label or app _ label.ModelName to exclude &apos; &apos; ( use multiple --exclude to exclude multiple apps / models ) . &apos; )
parser . add _ argument ( &apos; -n &apos; , &apos; --natural &apos; , action = &apos; store _ true &apos; , dest = &apos; use _ natural _ keys &apos; , default = False , help = &apos; Use natural keys if they are available ( deprecated : use --natural-foreign instead ) . &apos; )
parser . add _ argument ( &apos; --natural-foreign &apos; , action = &apos; store _ true &apos; , dest = &apos; use _ natural _ foreign _ keys &apos; , default = False , help = &apos; Use natural foreign keys if they are available . &apos; )
parser . add _ argument ( &apos; --natural-primary &apos; , action = &apos; store _ true &apos; , dest = &apos; use _ natural _ primary _ keys &apos; , default = False , help = &apos; Use natural primary keys if they are available . &apos; )
parser . add _ argument ( &apos; -a &apos; , &apos; --all &apos; , action = &apos; store _ true &apos; , dest = &apos; use _ base _ manager &apos; , default = False , help = &quot; Use Django &apos;s base manager to dump all models stored in the database , &quot; &quot; including those that would otherwise be filtered or modified by a custom manager . &quot; )
parser . add _ argument ( &apos; --pks &apos; , dest = &apos; primary _ keys &apos; , help = &quot; Only dump objects with given primary keys . &quot; &quot; Accepts a comma separated list of keys . &quot; &quot; this option will only work when you specify one model . &quot; )
parser . add _ argument ( &apos; -o &apos; , &apos; --output &apos; , default = None , dest = &apos; output &apos; , help = &apos; Specifies file to which the output is written . &apos; )
def handle ( self , * app _ labels , * * options ) :
format = options . get ( &apos; format &apos; )
indent = options . get ( &apos; indent &apos; )
using = options . get ( &apos; database &apos; )
excludes = options . get ( &apos; exclude &apos; )
output = options . get ( &apos; output &apos; )
show _ traceback = options . get ( &apos; traceback &apos; )
use _ natural _ keys = options . get ( &apos; use _ natural _ keys &apos; )
if use _ natural _ keys :
warnings . warn ( &quot; ``--natural`` is deprecated ; use ``--natural-foreign`` instead . &quot; , RemovedInDjango19Warning )
use _ natural _ foreign _ keys = options . get ( &apos; use _ natural _ foreign _ keys &apos; ) or use _ natural _ keys
use _ natural _ primary _ keys = options . get ( &apos; use _ natural _ primary _ keys &apos; )
use _ base _ manager = options . get ( &apos; use _ base _ manager &apos; )
pks = options . get ( &apos; primary _ keys &apos; )
if pks :
primary _ keys = pks . split ( &apos; , &apos; )
else :
primary _ keys = &#91; &#93;
excluded _ apps = set ( )
excluded _ models = set ( )
for exclude in excludes :
if &apos; .&apos; in exclude :
try :
model = apps . get _ model ( exclude )
except LookupError :
raise CommandError ( &apos; Unknown model in excludes : % s &apos; % exclude )
excluded _ models . add ( model )
else :
try :
app _ config = apps . get _ app _ config ( exclude )
except LookupError :
raise CommandError ( &apos; Unknown app in excludes : % s &apos; % exclude )
excluded _ apps . add ( app _ config )
if len ( app _ labels ) = = 0 :
if primary _ keys :
raise CommandError ( &quot; You can only use --pks option with one model &quot; )
app _ list = OrderedDict ( ( app _ config , None ) for app _ config in apps . get _ app _ configs ( ) if app _ config . models _ module is not None and app _ config not in excluded _ apps )
else :
if len ( app _ labels ) &gt; 1 and primary _ keys :
raise CommandError ( &quot; You can only use --pks option with one model &quot; )
app _ list = OrderedDict ( )
for label in app _ labels :
try :
app _ label , model _ label = label . split ( &apos; .&apos; )
try :
app _ config = apps . get _ app _ config ( app _ label )
except LookupError :
raise CommandError ( &quot; Unknown application : % s &quot; % app _ label )
if app _ config . models _ module is None or app _ config in excluded _ apps :
continue
try :
model = app _ config . get _ model ( model _ label )
except LookupError :
raise CommandError ( &quot; Unknown model : % s . % s &quot; % ( app _ label , model _ label ) )
app _ list _ value = app _ list . setdefault ( app _ config , &#91; &#93; )
if app _ list _ value is not None :
if model not in app _ list _ value :
app _ list _ value . append ( model )
except ValueError :
if primary _ keys :
raise CommandError ( &quot; You can only use --pks option with one model &quot; )
app _ label = label
try :
app _ config = apps . get _ app _ config ( app _ label )
except LookupError :
raise CommandError ( &quot; Unknown application : % s &quot; % app _ label )
if app _ config . models _ module is None or app _ config in excluded _ apps :
continue
app _ list &#91; app _ config &#93; = None
if format not in serializers . get _ public _ serializer _ formats ( ) :
try :
serializers . get _ serializer ( format )
except serializers . SerializerDoesNotExist :
pass
raise CommandError ( &quot; Unknown serialization format : % s &quot; % format )
def get _ objects ( ) :
for model in sort _ dependencies ( app _ list . items ( ) ) :
if model in excluded _ models :
continue
if not model . _ meta . proxy and router . allow _ migrate ( using , model ) :
if use _ base _ manager :
objects = model . _ base _ manager
else :
objects = model . _ default _ manager
queryset = objects . using ( using ) . order _ by ( model . _ meta . pk . name )
if primary _ keys :
queryset = queryset . filter ( pk _ _ in = primary _ keys )
for obj in queryset . iterator ( ) :
yield obj
try :
self . stdout . ending = None
stream = open ( output , &apos; w &apos; ) if output else None
try :
serializers . serialize ( format , get _ objects ( ) , indent = indent , use _ natural _ foreign _ keys = use _ natural _ foreign _ keys , use _ natural _ primary _ keys = use _ natural _ primary _ keys , stream = stream or self . stdout )
finally :
if stream :
stream . close ( )
except Exception as e :
if show _ traceback :
raise
raise CommandError ( &quot; Unable to serialize database : % s &quot; % e )
def sort _ dependencies ( app _ list ) :
model _ dependencies = &#91; &#93;
models = set ( )
for app _ config , model _ list in app _ list :
if model _ list is None :
model _ list = app _ config . get _ models ( )
for model in model _ list :
models . add ( model )
if hasattr ( model , &apos; natural _ key &apos; ) :
deps = getattr ( model . natural _ key , &apos; dependencies &apos; , &#91; &#93; )
if deps :
deps = &#91; apps . get _ model ( dep ) for dep in deps &#93;
else :
deps = &#91; &#93;
for field in model . _ meta . fields :
if hasattr ( field . rel , &apos; to &apos; ) :
rel _ model = field . rel . to
if hasattr ( rel _ model , &apos; natural _ key &apos; ) and rel _ model ! = model :
deps . append ( rel _ model )
for field in model . _ meta . many _ to _ many :
if field . rel . through . _ meta . auto _ created :
rel _ model = field . rel . to
if hasattr ( rel _ model , &apos; natural _ key &apos; ) and rel _ model ! = model :
deps . append ( rel _ model )
model _ dependencies . append ( ( model , deps ) )
model _ dependencies . reverse ( )
model _ list = &#91; &#93;
while model _ dependencies :
skipped = &#91; &#93;
changed = False
while model _ dependencies :
model , deps = model _ dependencies . pop ( )
found = True
for candidate in ( ( d not in models or d in model _ list ) for d in deps ) :
if not candidate :
found = False
if found :
model _ list . append ( model )
changed = True
else :
skipped . append ( ( model , deps ) )
if not changed :
raise CommandError ( &quot; Can &apos;t resolve dependencies for % s in serialized app list . &quot; % &apos; , &apos; . join ( &apos; % s . % s &apos; % ( model . _ meta . app _ label , model . _ meta . object _ name ) for model , deps in sorted ( skipped , key = lambda obj : obj &#91; 0 &#93; . _ _ name _ _ ) ) )
model _ dependencies = skipped
return model _ list
import sys
from importlib import import _ module
from django . apps import apps
from django . db import connections , router , transaction , DEFAULT _ DB _ ALIAS
from django . core . management import call _ command
from django . core . management . base import BaseCommand , CommandError
from django . core . management . color import no _ style
from django . core . management . sql import sql _ flush , emit _ post _ migrate _ signal
from django . utils . six . moves import input
from django . utils import six
class Command ( BaseCommand ) :
help = ( &apos; Removes ALL DATA from the database , including data added during &apos; &apos; migrations . unmigrated apps will also have their initial _ data &apos; &apos; fixture reloaded . does not achieve a &quot; fresh install &quot; state . &apos; )
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; --noinput &apos; , action = &apos; store _ false &apos; , dest = &apos; interactive &apos; , default = True , help = &apos; Tells Django to NOT prompt the user for input of any kind . &apos; )
parser . add _ argument ( &apos; --database &apos; , action = &apos; store &apos; , dest = &apos; database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to flush . defaults to the &quot; default &quot; database . &apos; )
parser . add _ argument ( &apos; --no-initial-data &apos; , action = &apos; store _ false &apos; , dest = &apos; load _ initial _ data &apos; , default = True , help = &apos; Tells Django not to load any initial data after database synchronization . &apos; )
def handle ( self , * * options ) :
database = options . get ( &apos; database &apos; )
connection = connections &#91; database &#93;
verbosity = options . get ( &apos; verbosity &apos; )
interactive = options . get ( &apos; interactive &apos; )
reset _ sequences = options . get ( &apos; reset _ sequences &apos; , True )
allow _ cascade = options . get ( &apos; allow _ cascade &apos; , False )
inhibit _ post _ migrate = options . get ( &apos; inhibit _ post _ migrate &apos; , False )
self . style = no _ style ( )
for app _ config in apps . get _ app _ configs ( ) :
try :
import _ module ( &apos; .management &apos; , app _ config . name )
except ImportError :
pass
sql _ list = sql _ flush ( self . style , connection , only _ django = True , reset _ sequences = reset _ sequences , allow _ cascade = allow _ cascade )
if interactive :
confirm = input ( &quot; &quot; &quot; You have requested a flush of the database . this will IRREVERSIBLY DESTROY all data currently in the % r database , and return each table to an empty state . are you sure you want to do this ? type &apos; yes &apos; to continue , or &apos; no &apos; to cancel : &quot; &quot; &quot; % connection . settings _ dict &#91; &apos; NAME &apos; &#93; )
else :
confirm = &apos; yes&apos;
if confirm = = &apos; yes &apos; :
try :
with transaction . atomic ( using = database , savepoint = connection . features . can _ rollback _ ddl ) :
with connection . cursor ( ) as cursor :
for sql in sql _ list :
cursor . execute ( sql )
except Exception as e :
new _ msg = ( &quot; Database % s couldn &apos;t be flushed . possible reasons : \ n &quot; &quot; * The database isn &apos;t running or isn &apos;t configured correctly . \ n &quot; &quot; * At least one of the expected database tables doesn &apos;t exist . \ n &quot; &quot; * The SQL was invalid . \ n &quot; &quot; hint : look at the output of &apos; django-admin.py sqlflush &apos; . that &apos;s the SQL this command wasn &apos;t able to run . \ n &quot; &quot; The full error : % s &quot; ) % ( connection . settings _ dict &#91; &apos; NAME &apos; &#93; , e )
six . reraise ( CommandError , CommandError ( new _ msg ) , sys . exc _ info ( ) &#91; 2 &#93; )
if not inhibit _ post _ migrate :
self . emit _ post _ migrate ( verbosity , interactive , database )
if options . get ( &apos; load _ initial _ data &apos; ) :
call _ command ( &apos; loaddata &apos; , &apos; initial _ data &apos; , * * options )
else :
self . stdout . write ( &quot; Flush cancelled . \ n &quot; )
@ staticmethod
def emit _ post _ migrate ( verbosity , interactive , database ) :
all _ models = &#91; &#93;
for app _ config in apps . get _ app _ configs ( ) :
all _ models . extend ( router . get _ migratable _ models ( app _ config , database , include _ auto _ created = True ) )
emit _ post _ migrate _ signal ( set ( all _ models ) , verbosity , interactive , database )
from _ _ future _ _ import unicode _ literals
from collections import OrderedDict
import keyword
import re
from django . core . management . base import BaseCommand , CommandError
from django . db import connections , DEFAULT _ DB _ ALIAS
class Command ( BaseCommand ) :
help = &quot; Introspects the database tables in the given database and outputs a Django model module . &quot;
requires _ system _ checks = False
db _ module = &apos; django.db&apos;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; --database &apos; , action = &apos; store &apos; , dest = &apos; database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to &apos; &apos; introspect . defaults to using the &quot; default &quot; database . &apos; )
def handle ( self , * * options ) :
try :
for line in self . handle _ inspection ( options ) :
self . stdout . write ( &quot; % s \ n &quot; % line )
except NotImplementedError :
raise CommandError ( &quot; Database inspection isn &apos;t supported for the currently selected database backend . &quot; )
def handle _ inspection ( self , options ) :
connection = connections &#91; options &#91; &apos; database &apos; &#93; &#93;
table _ name _ filter = options . get ( &apos; table _ name _ filter &apos; )
table2model = lambda table _ name : re . sub ( r &apos; &#91; ^ a-zA-Z0-9 &#93; &apos; , &apos; &apos; , table _ name . title ( ) )
strip _ prefix = lambda s : s &#91; 1 : &#93; if s . startswith ( &quot; u &apos; &quot; ) else s
with connection . cursor ( ) as cursor :
yield &quot; # This is an auto-generated Django model module . &quot;
yield &quot; # You &apos;ll have to do the following manually to clean this up : &quot;
yield &quot; # * Rearrange models &apos; order &quot;
yield &quot; # * Make sure each model has one field with primary _ key = True &quot;
yield &quot; # * Remove `managed = False` lines if you wish to allow Django to create , modify , and delete the table &quot;
yield &quot; # Feel free to rename the models , but don &apos;t rename db _ table values or field names . &quot;
yield &quot; # &quot;
yield &quot; # Also note : you &apos;ll have to insert the output of &apos; django-admin.py sqlcustom &#91; app _ label &#93; &apos; &quot;
yield &quot; # into your database . &quot;
yield &quot; from _ _ future _ _ import unicode _ literals &quot;
yield &apos; &apos;
yield &apos; from % s import models &apos; % self . db _ module
known _ models = &#91; &#93;
for table _ name in connection . introspection . table _ names ( cursor ) :
if table _ name _ filter is not None and callable ( table _ name _ filter ) :
if not table _ name _ filter ( table _ name ) :
continue
yield &apos; &apos;
yield &apos; &apos;
yield &apos; class % s ( models.Model ) : &apos; % table2model ( table _ name )
known _ models . append ( table2model ( table _ name ) )
try :
relations = connection . introspection . get _ relations ( cursor , table _ name )
except NotImplementedError :
relations = { }
try :
indexes = connection . introspection . get _ indexes ( cursor , table _ name )
except NotImplementedError :
indexes = { }
used _ column _ names = &#91; &#93;
for i , row in enumerate ( connection . introspection . get _ table _ description ( cursor , table _ name ) ) :
COMMENT _ notes = &#91; &#93;
extra _ params = OrderedDict ( )
column _ name = row &#91; 0 &#93;
is _ relation = i in relations
att _ name , params , notes = self . normalize _ col _ name ( column _ name , used _ column _ names , is _ relation )
extra _ params . update ( params )
COMMENT _ notes . extend ( notes )
used _ column _ names . append ( att _ name )
if column _ name in indexes :
if indexes &#91; column _ name &#93; &#91; &apos; primary _ key &apos; &#93; :
extra _ params &#91; &apos; primary _ key &apos; &#93; = True
elif indexes &#91; column _ name &#93; &#91; &apos; unique &apos; &#93; :
extra _ params &#91; &apos; unique &apos; &#93; = True
if is _ relation :
rel _ to = &quot; self &quot; if relations &#91; i &#93; &#91; 1 &#93; = = table _ name else table2model ( relations &#91; i &#93; &#91; 1 &#93; )
if rel _ to in known _ models :
field _ type = &apos; ForeignKey ( % s &apos; % rel _ to
else :
field _ type = &quot; ForeignKey ( &apos; % s &apos; &quot; % rel _ to
else :
field _ type , field _ params , field _ notes = self . get _ field _ type ( connection , table _ name , row )
extra _ params . update ( field _ params )
COMMENT _ notes . extend ( field _ notes )
field _ type + = &apos; ( &apos;
if att _ name = = &apos; id &apos; and extra _ params = = { &apos; primary _ key &apos; : true } :
if field _ type = = &apos; AutoField ( &apos; :
continue
elif field _ type = = &apos; IntegerField ( &apos; and not connection . features . can _ introspect _ autofield :
COMMENT _ notes . append ( &apos; AutoField ? &apos; )
if row &#91; 6 &#93; :
if field _ type = = &apos; BooleanField ( &apos; :
field _ type = &apos; NullBooleanField ( &apos;
else :
extra _ params &#91; &apos; blank &apos; &#93; = True
if field _ type not in ( &apos; TextField ( &apos; , &apos; CharField ( &apos; ) :
extra _ params &#91; &apos; null &apos; &#93; = True
field _ desc = &apos; % s = % s % s &apos; % ( att _ name , &apos; &apos; if &apos; .&apos; in field _ type else &apos; models . &apos; , field _ type , )
if extra _ params :
if not field _ desc . endswith ( &apos; ( &apos; ) :
field _ desc + = &apos; , &apos;
field _ desc + = &apos; , &apos; . join ( &#91; &apos; % s = % s &apos; % ( k , strip _ prefix ( repr ( v ) ) ) for k , v in extra _ params . items ( ) &#93; )
field _ desc + = &apos; ) &apos;
if comment _ notes :
field _ desc + = &apos; # &apos; + &apos; &apos; . join ( comment _ notes )
yield &apos; % s &apos; % field _ desc
for meta _ line in self . get _ meta ( table _ name ) :
yield meta _ line
def normalize _ col _ name ( self , col _ name , used _ column _ names , is _ relation ) :
field _ params = { }
field _ notes = &#91; &#93;
new _ name = col _ name . lower ( )
if new _ name ! = col _ name :
field _ notes . append ( &apos; Field name made lowercase . &apos; )
if is _ relation :
if new _ name . endswith ( &apos; _ id &apos; ) :
new _ name = new _ name &#91; : - 3 &#93;
else :
field _ params &#91; &apos; db _ column &apos; &#93; = col _ name
new _ name , num _ repl = re . subn ( r &apos; \ W &apos; , &apos; _ &apos; , new _ name )
if num _ repl &gt; 0 :
field _ notes . append ( &apos; Field renamed to remove unsuitable characters . &apos; )
if new _ name . find ( &apos; _ _ &apos; ) &gt; = 0 :
while new _ name . find ( &apos; _ _ &apos; ) &gt; = 0 :
new _ name = new _ name . replace ( &apos; _ _ &apos; , &apos; _ &apos; )
if col _ name . lower ( ) . find ( &apos; _ _ &apos; ) &gt; = 0 :
field _ notes . append ( &quot; Field renamed because it contained more than one &apos; _ &apos; in a row . &quot; )
if new _ name . startswith ( &apos; _ &apos; ) :
new _ name = &apos; field % s &apos; % new _ name
field _ notes . append ( &quot; Field renamed because it started with &apos; _ &apos; . &quot; )
if new _ name . endswith ( &apos; _ &apos; ) :
new _ name = &apos; % sfield &apos; % new _ name
field _ notes . append ( &quot; Field renamed because it ended with &apos; _ &apos; . &quot; )
if keyword . iskeyword ( new _ name ) :
new _ name + = &apos; _ field&apos;
field _ notes . append ( &apos; Field renamed because it was a Python reserved word . &apos; )
if new _ name &#91; 0 &#93; . isdigit ( ) :
new _ name = &apos; number _ % s &apos; % new _ name
field _ notes . append ( &quot; Field renamed because it wasn &apos;t a valid Python identifier . &quot; )
if new _ name in used _ column _ names :
num = 0
while &apos; % s _ % d &apos; % ( new _ name , num ) in used _ column _ names :
num + = 1
new _ name = &apos; % s _ % d &apos; % ( new _ name , num )
field _ notes . append ( &apos; Field renamed because of name conflict . &apos; )
if col _ name ! = new _ name and field _ notes :
field _ params &#91; &apos; db _ column &apos; &#93; = col _ name
return new _ name , field _ params , field _ notes
def get _ field _ type ( self , connection , table _ name , row ) :
field _ params = OrderedDict ( )
field _ notes = &#91; &#93;
try :
field _ type = connection . introspection . get _ field _ type ( row &#91; 1 &#93; , row )
except KeyError :
field _ type = &apos; TextField&apos;
field _ notes . append ( &apos; This field type is a guess . &apos; )
if type ( field _ type ) is tuple :
field _ type , new _ params = field _ type
field _ params . update ( new _ params )
if field _ type = = &apos; CharField &apos; and row &#91; 3 &#93; :
field _ params &#91; &apos; max _ length &apos; &#93; = int ( row &#91; 3 &#93; )
if field _ type = = &apos; DecimalField &apos; :
if row &#91; 4 &#93; is None or row &#91; 5 &#93; is None :
field _ notes . append ( &apos; max _ digits and decimal _ places have been guessed , as this &apos; &apos; database handles decimal fields as float &apos; )
field _ params &#91; &apos; max _ digits &apos; &#93; = row &#91; 4 &#93; if row &#91; 4 &#93; is not None else 10
field _ params &#91; &apos; decimal _ places &apos; &#93; = row &#91; 5 &#93; if row &#91; 5 &#93; is not None else 5
else :
field _ params &#91; &apos; max _ digits &apos; &#93; = row &#91; 4 &#93;
field _ params &#91; &apos; decimal _ places &apos; &#93; = row &#91; 5 &#93;
return field _ type , field _ params , field _ notes
def get _ meta ( self , table _ name ) :
return &#91; &quot; &quot; , &quot; class Meta : &quot; , &quot; managed = False &quot; , &quot; db _ table = &apos; % s &apos; &quot; % table _ name &#93;
from _ _ future _ _ import unicode _ literals
import glob
import gzip
import os
import warnings
import zipfile
from django . apps import apps
from django . conf import settings
from django . core import serializers
from django . core . management . base import BaseCommand , CommandError
from django . core . management . color import no _ style
from django . db import ( connections , router , transaction , DEFAULT _ DB _ ALIAS , IntegrityError , DatabaseError )
from django . utils import lru _ cache
from django . utils . encoding import force _ text
from django . utils . functional import cached _ property
from django . utils . _ os import upath
from itertools import product
try :
import bz2
has _ bz2 = True
except ImportError :
has _ bz2 = False
class Command ( BaseCommand ) :
help = &apos; Installs the named fixture ( s ) in the database . &apos;
missing _ args _ message = ( &quot; No database fixture specified . Please provide the &quot; &quot; path of at least one fixture in the command line . &quot; )
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; args &apos; , metavar = &apos; fixture &apos; , nargs = &apos; + &apos; , help = &apos; Fixture labels . &apos; )
parser . add _ argument ( &apos; --database &apos; , action = &apos; store &apos; , dest = &apos; database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a specific database to load &apos; &apos; fixtures into . defaults to the &quot; default &quot; database . &apos; )
parser . add _ argument ( &apos; --app &apos; , action = &apos; store &apos; , dest = &apos; app _ label &apos; , default = None , help = &apos; Only look for fixtures in the specified app . &apos; )
parser . add _ argument ( &apos; --ignorenonexistent &apos; , &apos; -i &apos; , action = &apos; store _ true &apos; , dest = &apos; ignore &apos; , default = False , help = &apos; Ignores entries in the serialized data for fields that do not &apos; &apos; currently exist on the model . &apos; )
def handle ( self , * fixture _ labels , * * options ) :
self . ignore = options . get ( &apos; ignore &apos; )
self . using = options . get ( &apos; database &apos; )
self . app _ label = options . get ( &apos; app _ label &apos; )
self . hide _ empty = options . get ( &apos; hide _ empty &apos; , False )
self . verbosity = options . get ( &apos; verbosity &apos; )
with transaction . atomic ( using = self . using ) :
self . loaddata ( fixture _ labels )
if transaction . get _ autocommit ( self . using ) :
connections &#91; self . using &#93; . close ( )
def loaddata ( self , fixture _ labels ) :
connection = connections &#91; self . using &#93;
self . fixture _ count = 0
self . loaded _ object _ count = 0
self . fixture _ object _ count = 0
self . models = set ( )
self . serialization _ formats = serializers . get _ public _ serializer _ formats ( )
self . compression _ formats = { None : ( open , &apos; rb &apos; ) , &apos; gz &apos; : ( gzip . GzipFile , &apos; rb &apos; ) , &apos; zip &apos; : ( SingleZipReader , &apos; r &apos; ) , }
if has _ bz2 :
self . compression _ formats &#91; &apos; bz2 &apos; &#93; = ( bz2 . BZ2File , &apos; r &apos; )
with connection . constraint _ checks _ disabled ( ) :
for fixture _ label in fixture _ labels :
self . load _ label ( fixture _ label )
table _ names = &#91; model . _ meta . db _ table for model in self . models &#93;
try :
connection . check _ constraints ( table _ names = table _ names )
except Exception as e :
e . args = ( &quot; Problem installing fixtures : % s &quot; % e , )
raise
if self . loaded _ object _ count &gt; 0 :
sequence _ sql = connection . ops . sequence _ reset _ sql ( no _ style ( ) , self . models )
if sequence _ sql :
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Resetting sequences \ n &quot; )
with connection . cursor ( ) as cursor :
for line in sequence _ sql :
cursor . execute ( line )
if self . verbosity &gt; = 1 :
if self . fixture _ count = = 0 and self . hide _ empty :
pass
elif self . fixture _ object _ count = = self . loaded _ object _ count :
self . stdout . write ( &quot; Installed % d object ( s ) from % d fixture ( s ) &quot; % ( self . loaded _ object _ count , self . fixture _ count ) )
else :
self . stdout . write ( &quot; Installed % d object ( s ) ( of % d ) from % d fixture ( s ) &quot; % ( self . loaded _ object _ count , self . fixture _ object _ count , self . fixture _ count ) )
def load _ label ( self , fixture _ label ) :
for fixture _ file , fixture _ dir , fixture _ name in self . find _ fixtures ( fixture _ label ) :
_ , ser _ fmt , cmp _ fmt = self . parse _ name ( os . path . basename ( fixture _ file ) )
open _ method , mode = self . compression _ formats &#91; cmp _ fmt &#93;
fixture = open _ method ( fixture _ file , mode )
try :
self . fixture _ count + = 1
objects _ in _ fixture = 0
loaded _ objects _ in _ fixture = 0
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Installing % s fixture &apos; % s &apos; from % s . &quot; % ( ser _ fmt , fixture _ name , humanize ( fixture _ dir ) ) )
objects = serializers . deserialize ( ser _ fmt , fixture , using = self . using , ignorenonexistent = self . ignore )
for obj in objects :
objects _ in _ fixture + = 1
if router . allow _ migrate ( self . using , obj . object . _ _ class _ _ ) :
loaded _ objects _ in _ fixture + = 1
self . models . add ( obj . object . _ _ class _ _ )
try :
obj . save ( using = self . using )
except ( DatabaseError , IntegrityError ) as e :
e . args = ( &quot; Could not load % ( app _ label ) s . % ( object _ name ) s ( pk = % ( pk ) s ) : % ( error _ msg ) s &quot; % { &apos; app _ label &apos; : obj . object . _ meta . app _ label , &apos; object _ name &apos; : obj . object . _ meta . object _ name , &apos; pk &apos; : obj . object . pk , &apos; error _ msg &apos; : force _ text ( e ) } , )
raise
self . loaded _ object _ count + = loaded _ objects _ in _ fixture
self . fixture _ object _ count + = objects _ in _ fixture
except Exception as e :
if not isinstance ( e , CommandError ) :
e . args = ( &quot; Problem installing fixture &apos; % s &apos; : % s &quot; % ( fixture _ file , e ) , )
raise
finally :
fixture . close ( )
if objects _ in _ fixture = = 0 :
warnings . warn ( &quot; No fixture data found for &apos; % s &apos; . ( file format may be &quot; &quot; invalid . ) &quot; % fixture _ name , RuntimeWarning )
@ lru _ cache . lru _ cache ( maxsize = None )
def find _ fixtures ( self , fixture _ label ) :
fixture _ name , ser _ fmt , cmp _ fmt = self . parse _ name ( fixture _ label )
databases = &#91; self . using , None &#93;
cmp _ fmts = list ( self . compression _ formats . keys ( ) ) if cmp _ fmt is None else &#91; cmp _ fmt &#93;
ser _ fmts = serializers . get _ public _ serializer _ formats ( ) if ser _ fmt is None else &#91; ser _ fmt &#93;
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Loading &apos; % s &apos; fixtures ... &quot; % fixture _ name )
if os . path . isabs ( fixture _ name ) :
fixture _ dirs = &#91; os . path . dirname ( fixture _ name ) &#93;
fixture _ name = os . path . basename ( fixture _ name )
else :
fixture _ dirs = self . fixture _ dirs
if os . path . sep in fixture _ name :
fixture _ dirs = &#91; os . path . join ( dir _ , os . path . dirname ( fixture _ name ) ) for dir _ in fixture _ dirs &#93;
fixture _ name = os . path . basename ( fixture _ name )
suffixes = ( &apos; .&apos; . join ( ext for ext in combo if ext ) for combo in product ( databases , ser _ fmts , cmp _ fmts ) )
targets = set ( &apos; .&apos; . join ( ( fixture _ name , suffix ) ) for suffix in suffixes )
fixture _ files = &#91; &#93;
for fixture _ dir in fixture _ dirs :
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Checking % s for fixtures ... &quot; % humanize ( fixture _ dir ) )
fixture _ files _ in _ dir = &#91; &#93;
for candidate in glob . iglob ( os . path . join ( fixture _ dir , fixture _ name + &apos; * &apos; ) ) :
if os . path . basename ( candidate ) in targets :
fixture _ files _ in _ dir . append ( ( candidate , fixture _ dir , fixture _ name ) )
if self . verbosity &gt; = 2 and not fixture _ files _ in _ dir :
self . stdout . write ( &quot; No fixture &apos; % s &apos; in % s . &quot; % ( fixture _ name , humanize ( fixture _ dir ) ) )
if len ( fixture _ files _ in _ dir ) &gt; 1 :
raise CommandError ( &quot; Multiple fixtures named &apos; % s &apos; in % s . Aborting . &quot; % ( fixture _ name , humanize ( fixture _ dir ) ) )
fixture _ files . extend ( fixture _ files _ in _ dir )
if fixture _ name ! = &apos; initial _ data &apos; and not fixture _ files :
warnings . warn ( &quot; No fixture named &apos; % s &apos; found . &quot; % fixture _ name )
return fixture _ files
@ cached _ property
def fixture _ dirs ( self ) :
dirs = &#91; &#93;
for app _ config in apps . get _ app _ configs ( ) :
if self . app _ label and app _ config . label ! = self . app _ label :
continue
app _ dir = os . path . join ( app _ config . path , &apos; fixtures &apos; )
if os . path . isdir ( app _ dir ) :
dirs . append ( app _ dir )
dirs . extend ( list ( settings . fixture _ DIRS ) )
dirs . append ( &apos; &apos; )
dirs = &#91; upath ( os . path . abspath ( os . path . realpath ( d ) ) ) for d in dirs &#93;
return dirs
def parse _ name ( self , fixture _ name ) :
parts = fixture _ name . rsplit ( &apos; .&apos; , 2 )
if len ( parts ) &gt; 1 and parts &#91; - 1 &#93; in self . compression _ formats :
cmp _ fmt = parts &#91; - 1 &#93;
parts = parts &#91; : - 1 &#93;
else :
cmp _ fmt = None
if len ( parts ) &gt; 1 :
if parts &#91; - 1 &#93; in self . serialization _ formats :
ser _ fmt = parts &#91; - 1 &#93;
parts = parts &#91; : - 1 &#93;
else :
raise CommandError ( &quot; Problem installing fixture &apos; % s &apos; : % s is not a known &quot; &quot; serialization format . &quot; % ( &apos; &apos; . join ( parts &#91; : - 1 &#93; ) , parts &#91; - 1 &#93; ) )
else :
ser _ fmt = None
name = &apos; .&apos; . join ( parts )
return name , ser _ fmt , cmp _ fmt
class SingleZipReader ( zipfile . zipfile ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
zipfile . zipfile . _ _ init _ _ ( self , * args , * * kwargs )
if len ( self . namelist ( ) ) ! = 1 :
raise ValueError ( &quot; Zip-compressed fixtures must contain one file . &quot; )
def read ( self ) :
return zipfile . zipfile . read ( self , self . namelist ( ) &#91; 0 &#93; )
def humanize ( dirname ) :
return &quot; &apos; % s &apos; &quot; % dirname if dirname else &apos; absolute path&apos;
from _ _ future _ _ import unicode _ literals
import fnmatch
import glob
import io
import os
import re
import sys
from itertools import dropwhile
import django
from django . core . management . base import CommandError , BaseCommand
from django . core . management . utils import ( handle _ extensions , find _ command , popen _ wrapper )
from django . utils . encoding import force _ str
from django . utils . functional import total _ ordering
from django . utils import six
from django . utils . text import get _ text _ list
from django . utils . jslex import prepare _ js _ for _ gettext
plural _ forms _ re = re . compile ( r &apos; ^ ( ? p &lt; value &gt; &quot; Plural-Forms . + ? \ \ n &quot; ) \ s * $ &apos; , re . MULTILINE &#124; re . DOTALL )
status _ OK = 0
def check _ programs ( * programs ) :
for program in programs :
if find _ command ( program ) is None :
raise CommandError ( &quot; Can &apos;t find % s . make sure you have GNU &quot; &quot; gettext tools 0.15 or newer installed . &quot; % program )
@ total _ ordering
class TranslatableFile ( object ) :
def _ _ init _ _ ( self , dirpath , file _ name , locale _ dir ) :
self . file = file _ name
self . dirpath = dirpath
self . locale _ dir = locale _ dir
def _ _ repr _ _ ( self ) :
return &quot; &lt; TranslatableFile : % s &gt; &quot; % os . sep . join ( &#91; self . dirpath , self . file &#93; )
def _ _ eq _ _ ( self , other ) :
return self . path = = other . path
def _ _ lt _ _ ( self , other ) :
return self . path &lt; other . path
@ property
def path ( self ) :
return os . path . join ( self . dirpath , self . file )
def process ( self , command , domain ) :
from django . conf import settings
from django . utils . translation import templatize
if command . verbosity &gt; 1 :
command . stdout . write ( &apos; processing file % s in % s \ n &apos; % ( self . file , self . dirpath ) )
_ , file _ ext = os . path . splitext ( self . file )
if domain = = &apos; djangojs &apos; and file _ ext in command . extensions :
is _ templatized = True
orig _ file = os . path . join ( self . dirpath , self . file )
with io . open ( orig _ file , encoding = settings . file _ CHARSET ) as fp :
src _ data = fp . read ( )
src _ data = prepare _ js _ for _ gettext ( src _ data )
thefile = &apos; % s.c &apos; % self . file
work _ file = os . path . join ( self . dirpath , thefile )
with io . open ( work _ file , &quot; w &quot; , encoding = &apos; utf-8 &apos; ) as fp :
fp . write ( src _ data )
args = &#91; &apos; xgettext &apos; , &apos; -d &apos; , domain , &apos; --language = C &apos; , &apos; --keyword = gettext _ noop &apos; , &apos; --keyword = gettext _ lazy &apos; , &apos; --keyword = ngettext _ lazy : 1,2 &apos; , &apos; --keyword = pgettext : 1c , 2 &apos; , &apos; --keyword = npgettext : 1c , 2,3 &apos; , &apos; --output = - &apos; &#93; + command . xgettext _ options
args . append ( work _ file )
elif domain = = &apos; django &apos; and ( file _ ext = = &apos; .py &apos; or file _ ext in command . extensions ) :
thefile = self . file
orig _ file = os . path . join ( self . dirpath , self . file )
is _ templatized = file _ ext in command . extensions
if is _ templatized :
with io . open ( orig _ file , &apos; r &apos; , encoding = settings . file _ CHARSET ) as fp :
src _ data = fp . read ( )
thefile = &apos; % s.py &apos; % self . file
content = templatize ( src _ data , orig _ file &#91; 2 : &#93; )
with io . open ( os . path . join ( self . dirpath , thefile ) , &quot; w &quot; , encoding = &apos; utf-8 &apos; ) as fp :
fp . write ( content )
work _ file = os . path . join ( self . dirpath , thefile )
args = &#91; &apos; xgettext &apos; , &apos; -d &apos; , domain , &apos; --language = Python &apos; , &apos; --keyword = gettext _ noop &apos; , &apos; --keyword = gettext _ lazy &apos; , &apos; --keyword = ngettext _ lazy : 1,2 &apos; , &apos; --keyword = ugettext _ noop &apos; , &apos; --keyword = ugettext _ lazy &apos; , &apos; --keyword = ungettext _ lazy : 1,2 &apos; , &apos; --keyword = pgettext : 1c , 2 &apos; , &apos; --keyword = npgettext : 1c , 2,3 &apos; , &apos; --keyword = pgettext _ lazy : 1c , 2 &apos; , &apos; --keyword = npgettext _ lazy : 1c , 2,3 &apos; , &apos; --output = - &apos; &#93; + command . xgettext _ options
args . append ( work _ file )
else :
return
msgs , errors , status = popen _ wrapper ( args )
if errors :
if status ! = STATUS _ OK :
if is _ templatized :
os . unlink ( work _ file )
raise CommandError ( &quot; errors happened while running xgettext on % s \ n % s &quot; % ( self . file , errors ) )
elif command . verbosity &gt; 0 :
command . stdout . write ( errors )
if msgs :
if six . PY2 :
msgs = msgs . decode ( &apos; utf-8 &apos; )
potfile = os . path . join ( self . locale _ dir , &apos; % s.pot &apos; % str ( domain ) )
if is _ templatized :
if os . name = = &apos; nt &apos; :
old = &apos; # : &apos; + work _ file
new = &apos; # : &apos; + orig _ file
else :
old = &apos; # : &apos; + work _ file &#91; 2 : &#93;
new = &apos; # : &apos; + orig _ file &#91; 2 : &#93;
msgs = msgs . replace ( old , new )
write _ pot _ file ( potfile , msgs )
if is _ templatized :
os . unlink ( work _ file )
def write _ pot _ file ( potfile , msgs ) :
if os . path . exists ( potfile ) :
msgs = &apos; \ n &apos; . join ( dropwhile ( len , msgs . split ( &apos; \ n &apos; ) ) )
else :
msgs = msgs . replace ( &apos; charset = CHARSET &apos; , &apos; charset = UTF-8 &apos; )
with io . open ( potfile , &apos; a &apos; , encoding = &apos; utf-8 &apos; ) as fp :
fp . write ( msgs )
class Command ( BaseCommand ) :
help = ( &quot; Runs over the entire source tree of the current directory and &quot; &quot; pulls out all strings marked for translation . it creates ( or updates ) a message &quot; &quot; file in the conf / locale ( in the django tree ) or locale ( for projects and &quot; &quot; applications ) directory . \ n \ nYou must run this command with one of either the &quot; &quot; --locale , --exclude or --all options . &quot; )
requires _ system _ checks = False
leave _ locale _ alone = True
msgmerge _ options = &#91; &apos; -q &apos; , &apos; --previous &apos; &#93;
msguniq _ options = &#91; &apos; --to-code = utf-8 &apos; &#93;
msgattrib _ options = &#91; &apos; --no-obsolete &apos; &#93;
xgettext _ options = &#91; &apos; --from-code = UTF-8 &apos; , &apos; --add-comments = Translators &apos; &#93;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; --locale &apos; , &apos; -l &apos; , default = &#91; &#93; , dest = &apos; locale &apos; , action = &apos; append &apos; , help = &apos; Creates or updates the message files for the given locale ( s ) ( e.g. pt _ BR ) . &apos; &apos; can be used multiple times . &apos; )
parser . add _ argument ( &apos; --exclude &apos; , &apos; -x &apos; , default = &#91; &#93; , dest = &apos; exclude &apos; , action = &apos; append &apos; , help = &apos; Locales to exclude . default is none . can be used multiple times . &apos; )
parser . add _ argument ( &apos; --domain &apos; , &apos; -d &apos; , default = &apos; django &apos; , dest = &apos; domain &apos; , help = &apos; The domain of the message files ( default : &quot; Django &quot; ) . &apos; )
parser . add _ argument ( &apos; --all &apos; , &apos; -a &apos; , action = &apos; store _ true &apos; , dest = &apos; all &apos; , default = False , help = &apos; Updates the message files for all existing locales . &apos; )
parser . add _ argument ( &apos; --extension &apos; , &apos; -e &apos; , dest = &apos; extensions &apos; , help = &apos; The file extension ( s ) to examine ( default : &quot; html , txt &quot; , or &quot; js &quot; &apos; &apos; if the domain is &quot; djangojs &quot; ) . separate multiple extensions with &apos; &apos; commas , or use -e multiple times . &apos; , action = &apos; append &apos; )
parser . add _ argument ( &apos; --symlinks &apos; , &apos; -s &apos; , action = &apos; store _ true &apos; , dest = &apos; symlinks &apos; , default = False , help = &apos; Follows symlinks to directories when examining &apos; &apos; source code and templates for translation strings . &apos; )
parser . add _ argument ( &apos; --ignore &apos; , &apos; -i &apos; , action = &apos; append &apos; , dest = &apos; ignore _ patterns &apos; , default = &#91; &#93; , metavar = &apos; PATTERN &apos; , help = &apos; Ignore files or directories matching this glob-style pattern . &apos; &apos; use multiple times to ignore more . &apos; )
parser . add _ argument ( &apos; --no-default-ignore &apos; , action = &apos; store _ false &apos; , dest = &apos; use _ default _ ignore _ patterns &apos; , default = True , help = &quot; Don &apos;t ignore the common glob-style patterns &apos; CVS &apos; , &apos; . * &apos; , &apos; * ~ &apos; and &apos; * .pyc &apos; . &quot; )
parser . add _ argument ( &apos; --no-wrap &apos; , action = &apos; store _ true &apos; , dest = &apos; no _ wrap &apos; , default = False , help = &quot; Don &apos;t break long message lines into several lines . &quot; )
parser . add _ argument ( &apos; --no-location &apos; , action = &apos; store _ true &apos; , dest = &apos; no _ location &apos; , default = False , help = &quot; Don &apos;t write &apos; # : filename : line &apos; lines . &quot; )
parser . add _ argument ( &apos; --no-obsolete &apos; , action = &apos; store _ true &apos; , dest = &apos; no _ obsolete &apos; , default = False , help = &quot; Remove obsolete message strings . &quot; )
parser . add _ argument ( &apos; --keep-pot &apos; , action = &apos; store _ true &apos; , dest = &apos; keep _ pot &apos; , default = False , help = &quot; Keep .pot file after making messages . Useful when debugging . &quot; )
def handle ( self , * args , * * options ) :
locale = options . get ( &apos; locale &apos; )
exclude = options . get ( &apos; exclude &apos; )
self . domain = options . get ( &apos; domain &apos; )
self . verbosity = options . get ( &apos; verbosity &apos; )
process _ all = options . get ( &apos; all &apos; )
extensions = options . get ( &apos; extensions &apos; )
self . symlinks = options . get ( &apos; symlinks &apos; )
ignore _ patterns = options . get ( &apos; ignore _ patterns &apos; )
if options . get ( &apos; use _ default _ ignore _ patterns &apos; ) :
ignore _ patterns + = &#91; &apos; CVS &apos; , &apos; . * &apos; , &apos; * ~ &apos; , &apos; * .pyc &apos; &#93;
self . ignore _ patterns = list ( set ( ignore _ patterns ) )
if options . get ( &apos; no _ wrap &apos; ) :
self . msgmerge _ options = self . msgmerge _ options &#91; : &#93; + &#91; &apos; --no-wrap &apos; &#93;
self . msguniq _ options = self . msguniq _ options &#91; : &#93; + &#91; &apos; --no-wrap &apos; &#93;
self . msgattrib _ options = self . msgattrib _ options &#91; : &#93; + &#91; &apos; --no-wrap &apos; &#93;
self . xgettext _ options = self . xgettext _ options &#91; : &#93; + &#91; &apos; --no-wrap &apos; &#93;
if options . get ( &apos; no _ location &apos; ) :
self . msgmerge _ options = self . msgmerge _ options &#91; : &#93; + &#91; &apos; --no-location &apos; &#93;
self . msguniq _ options = self . msguniq _ options &#91; : &#93; + &#91; &apos; --no-location &apos; &#93;
self . msgattrib _ options = self . msgattrib _ options &#91; : &#93; + &#91; &apos; --no-location &apos; &#93;
self . xgettext _ options = self . xgettext _ options &#91; : &#93; + &#91; &apos; --no-location &apos; &#93;
self . no _ obsolete = options . get ( &apos; no _ obsolete &apos; )
self . keep _ pot = options . get ( &apos; keep _ pot &apos; )
if self . domain not in ( &apos; django &apos; , &apos; djangojs &apos; ) :
raise CommandError ( &quot; currently makemessages only supports domains &quot; &quot; &apos; django &apos; and &apos; djangojs &apos; &quot; )
if self . domain = = &apos; djangojs &apos; :
exts = extensions if extensions else &#91; &apos; js &apos; &#93;
else :
exts = extensions if extensions else &#91; &apos; html &apos; , &apos; txt &apos; &#93;
self . extensions = handle _ extensions ( exts )
if ( locale is None and not exclude and not process _ all ) or self . domain is None :
raise CommandError ( &quot; Type &apos; % s help % s &apos; for usage information . &quot; % ( os . path . basename ( sys . argv &#91; 0 &#93; ) , sys . argv &#91; 1 &#93; ) )
from django . conf import settings
if settings . configured :
settings . use _ I18N = True
else :
settings . configure ( USE _ I18N = True )
if self . verbosity &gt; 1 :
self . stdout . write ( &apos; examining files with the extensions : % s \ n &apos; % get _ text _ list ( list ( self . extensions ) , &apos; and &apos; ) )
self . invoked _ for _ django = False
self . locale _ paths = &#91; &#93;
self . default _ locale _ path = None
if os . path . isdir ( os . path . join ( &apos; conf &apos; , &apos; locale &apos; ) ) :
self . locale _ paths = &#91; os . path . abspath ( os . path . join ( &apos; conf &apos; , &apos; locale &apos; ) ) &#93;
self . default _ locale _ path = self . locale _ paths &#91; 0 &#93;
self . invoked _ for _ django = True
else :
self . locale _ paths . extend ( list ( settings . locale _ PATHS ) )
if os . path . isdir ( &apos; locale &apos; ) :
self . locale _ paths . append ( os . path . abspath ( &apos; locale &apos; ) )
if self . locale _ paths :
self . default _ locale _ path = self . locale _ paths &#91; 0 &#93;
if not os . path . exists ( self . default _ locale _ path ) :
os . makedirs ( self . default _ locale _ path )
locale _ dirs = filter ( os . path . isdir , glob . glob ( &apos; % s / * &apos; % self . default _ locale _ path ) )
all _ locales = map ( os . path . basename , locale _ dirs )
if process _ all :
locales = all _ locales
else :
locales = locale or all _ locales
locales = set ( locales ) - set ( exclude )
if locales :
check _ programs ( &apos; msguniq &apos; , &apos; msgmerge &apos; , &apos; msgattrib &apos; )
check _ programs ( &apos; xgettext &apos; )
try :
potfiles = self . build _ potfiles ( )
for locale in locales :
if self . verbosity &gt; 0 :
self . stdout . write ( &quot; processing locale % s \ n &quot; % locale )
for potfile in potfiles :
self . write _ po _ file ( potfile , locale )
finally :
if not self . keep _ pot :
self . remove _ potfiles ( )
def build _ potfiles ( self ) :
file _ list = self . find _ files ( &quot; . &quot; )
self . remove _ potfiles ( )
for f in file _ list :
try :
f . process ( self , self . domain )
except UnicodeDecodeError :
self . stdout . write ( &quot; UnicodeDecodeError : skipped file % s in % s &quot; % ( f . file , f . dirpath ) )
potfiles = &#91; &#93;
for path in self . locale _ paths :
potfile = os . path . join ( path , &apos; % s.pot &apos; % str ( self . domain ) )
if not os . path . exists ( potfile ) :
continue
args = &#91; &apos; msguniq &apos; &#93; + self . msguniq _ options + &#91; potfile &#93;
msgs , errors , status = popen _ wrapper ( args )
if six . PY2 :
msgs = msgs . decode ( &apos; utf-8 &apos; )
if errors :
if status ! = STATUS _ OK :
raise CommandError ( &quot; errors happened while running msguniq \ n % s &quot; % errors )
elif self . verbosity &gt; 0 :
self . stdout . write ( errors )
with io . open ( potfile , &apos; w &apos; , encoding = &apos; utf-8 &apos; ) as fp :
fp . write ( msgs )
potfiles . append ( potfile )
return potfiles
def remove _ potfiles ( self ) :
for path in self . locale _ paths :
pot _ path = os . path . join ( path , &apos; % s.pot &apos; % str ( self . domain ) )
if os . path . exists ( pot _ path ) :
os . unlink ( pot _ path )
def find _ files ( self , root ) :
def is _ ignored ( path , ignore _ patterns ) :
filename = os . path . basename ( path )
ignore = lambda pattern : fnmatch . fnmatchcase ( filename , pattern )
return any ( ignore ( pattern ) for pattern in ignore _ patterns )
dir _ suffix = &apos; % s * &apos; % os . sep
norm _ patterns = &#91; p &#91; : - len ( dir _ suffix ) &#93; if p . endswith ( dir _ suffix ) else p for p in self . ignore _ patterns &#93;
all _ files = &#91; &#93;
for dirpath , dirnames , filenames in os . walk ( root , topdown = True , followlinks = self . symlinks ) :
for dirname in dirnames &#91; : &#93; :
if is _ ignored ( os . path . normpath ( os . path . join ( dirpath , dirname ) ) , norm _ patterns ) :
dirnames . remove ( dirname )
if self . verbosity &gt; 1 :
self . stdout . write ( &apos; ignoring directory % s \ n &apos; % dirname )
elif dirname = = &apos; locale &apos; :
dirnames . remove ( dirname )
self . locale _ paths . insert ( 0 , os . path . join ( os . path . abspath ( dirpath ) , dirname ) )
for filename in filenames :
file _ path = os . path . normpath ( os . path . join ( dirpath , filename ) )
if is _ ignored ( file _ path , self . ignore _ patterns ) :
if self . verbosity &gt; 1 :
self . stdout . write ( &apos; ignoring file % s in % s \ n &apos; % ( filename , dirpath ) )
else :
locale _ dir = None
for path in self . locale _ paths :
if os . path . abspath ( dirpath ) . startswith ( os . path . dirname ( path ) ) :
locale _ dir = path
break
if not locale _ dir :
locale _ dir = self . default _ locale _ path
if not locale _ dir :
raise CommandError ( &quot; Unable to find a locale path to store translations for file % s &quot; % file _ path )
all _ files . append ( TranslatableFile ( dirpath , filename , locale _ dir ) )
return sorted ( all _ files )
def write _ po _ file ( self , potfile , locale ) :
basedir = os . path . join ( os . path . dirname ( potfile ) , locale , &apos; LC _ MESSAGES &apos; )
if not os . path . isdir ( basedir ) :
os . makedirs ( basedir )
pofile = os . path . join ( basedir , &apos; % s.po &apos; % str ( self . domain ) )
if os . path . exists ( pofile ) :
args = &#91; &apos; msgmerge &apos; &#93; + self . msgmerge _ options + &#91; pofile , potfile &#93;
msgs , errors , status = popen _ wrapper ( args )
if six . PY2 :
msgs = msgs . decode ( &apos; utf-8 &apos; )
if errors :
if status ! = STATUS _ OK :
raise CommandError ( &quot; errors happened while running msgmerge \ n % s &quot; % errors )
elif self . verbosity &gt; 0 :
self . stdout . write ( errors )
else :
with io . open ( potfile , &apos; r &apos; , encoding = &apos; utf-8 &apos; ) as fp :
msgs = fp . read ( )
if not self . invoked _ for _ django :
msgs = self . copy _ plural _ forms ( msgs , locale )
msgs = msgs . replace ( &quot; # . # - # - # - # - # % s.pot ( PACKAGE VERSION ) # - # - # - # - # \ n &quot; % self . domain , &quot; &quot; )
with io . open ( pofile , &apos; w &apos; , encoding = &apos; utf-8 &apos; ) as fp :
fp . write ( msgs )
if self . no _ obsolete :
args = &#91; &apos; msgattrib &apos; &#93; + self . msgattrib _ options + &#91; &apos; -o &apos; , pofile , pofile &#93;
msgs , errors , status = popen _ wrapper ( args )
if errors :
if status ! = STATUS _ OK :
raise CommandError ( &quot; errors happened while running msgattrib \ n % s &quot; % errors )
elif self . verbosity &gt; 0 :
self . stdout . write ( errors )
def copy _ plural _ forms ( self , msgs , locale ) :
Django _ dir = os . path . normpath ( os . path . join ( os . path . dirname ( django . _ _ file _ _ ) ) )
if self . domain = = &apos; djangojs &apos; :
domains = ( &apos; djangojs &apos; , &apos; django &apos; )
else :
domains = ( &apos; django &apos; , )
for domain in domains :
Django _ po = os . path . join ( django _ dir , &apos; conf &apos; , &apos; locale &apos; , locale , &apos; LC _ MESSAGES &apos; , &apos; % s.po &apos; % domain )
if os . path . exists ( django _ po ) :
with io . open ( django _ po , &apos; r &apos; , encoding = &apos; utf-8 &apos; ) as fp :
m = plural _ forms _ re . search ( fp . read ( ) )
if m :
plural _ form _ line = force _ str ( m . Group ( &apos; value &apos; ) )
if self . verbosity &gt; 1 :
self . stdout . write ( &quot; copying plural forms : % s \ n &quot; % plural _ form _ line )
lines = &#91; &#93;
found = False
for line in msgs . split ( &apos; \ n &apos; ) :
if not found and ( not line or plural _ forms _ re . search ( line ) ) :
line = &apos; % s \ n &apos; % plural _ form _ line
found = True
lines . append ( line )
msgs = &apos; \ n &apos; . join ( lines )
break
return msgs
import sys
import os
import operator
from django . apps import apps
from django . core . management . base import BaseCommand , CommandError
from django . db . migrations import Migration
from django . db . migrations . loader import MigrationLoader
from django . db . migrations . autodetector import MigrationAutodetector
from django . db . migrations . questioner import MigrationQuestioner , InteractiveMigrationQuestioner
from django . db . migrations . state import ProjectState
from django . db . migrations . writer import MigrationWriter
from django . utils . six . moves import reduce
class Command ( BaseCommand ) :
help = &quot; Creates new migration ( s ) for apps . &quot;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; args &apos; , metavar = &apos; app _ label &apos; , nargs = &apos; * &apos; , help = &apos; Specify the app label ( s ) to create migrations for . &apos; )
parser . add _ argument ( &apos; --dry-run &apos; , action = &apos; store _ true &apos; , dest = &apos; dry _ run &apos; , default = False , help = &quot; Just show what migrations would be made ; don &apos;t actually write them . &quot; )
parser . add _ argument ( &apos; --merge &apos; , action = &apos; store _ true &apos; , dest = &apos; merge &apos; , default = False , help = &quot; Enable fixing of migration conflicts . &quot; )
parser . add _ argument ( &apos; --empty &apos; , action = &apos; store _ true &apos; , dest = &apos; empty &apos; , default = False , help = &quot; Create an empty migration . &quot; )
parser . add _ argument ( &apos; --noinput &apos; , action = &apos; store _ false &apos; , dest = &apos; interactive &apos; , default = True , help = &apos; Tells Django to NOT prompt the user for input of any kind . &apos; )
def handle ( self , * app _ labels , * * options ) :
self . verbosity = options . get ( &apos; verbosity &apos; )
self . interactive = options . get ( &apos; interactive &apos; )
self . dry _ run = options . get ( &apos; dry _ run &apos; , False )
self . merge = options . get ( &apos; merge &apos; , False )
self . empty = options . get ( &apos; empty &apos; , False )
app _ labels = set ( app _ labels )
bad _ app _ labels = set ( )
for app _ label in app _ labels :
try :
apps . get _ app _ config ( app _ label )
except LookupError :
bad _ app _ labels . add ( app _ label )
if bad _ app _ labels :
for app _ label in bad _ app _ labels :
self . stderr . write ( &quot; App &apos; % s &apos; could not be found . is it in INSTALLED _ APPS ? &quot; % app _ label )
sys . exit ( 2 )
loader = MigrationLoader ( None , ignore _ no _ migrations = True )
conflicts = loader . detect _ conflicts ( )
if conflicts and not self . merge :
name _ str = &quot; ; &quot; . join ( &quot; % s in % s &quot; % ( &quot; , &quot; . join ( names ) , app ) for app , names in conflicts . items ( ) )
raise CommandError ( &quot; Conflicting migrations detected ( % s ) . \ nTo fix them run &apos; python manage.py makemigrations --merge &apos; &quot; % name _ str )
if self . merge and not conflicts :
self . stdout . write ( &quot; No conflicts detected to merge . &quot; )
return
if self . merge and conflicts :
return self . handle _ merge ( loader , conflicts )
autodetector = MigrationAutodetector ( loader . project _ state ( ) , ProjectState . from _ apps ( apps ) , InteractiveMigrationQuestioner ( specified _ apps = app _ labels , dry _ run = self . dry _ run ) , )
if self . empty :
if not app _ labels :
raise CommandError ( &quot; You must supply at least one app label when using --empty . &quot; )
changes = dict ( ( app , &#91; Migration ( &quot; custom &quot; , app ) &#93; ) for app in app _ labels )
changes = autodetector . arrange _ for _ graph ( changes , loader . graph )
self . write _ migration _ files ( changes )
return
changes = autodetector . changes ( graph = loader . graph , trim _ to _ apps = app _ labels or None , convert _ apps = app _ labels or None , )
if not changes and self . verbosity &gt; = 1 :
if len ( app _ labels ) = = 1 :
self . stdout . write ( &quot; No changes detected in app &apos; % s &apos; &quot; % app _ labels . pop ( ) )
elif len ( app _ labels ) &gt; 1 :
self . stdout . write ( &quot; No changes detected in apps &apos; % s &apos; &quot; % ( &quot; &apos; , &apos; &quot; . join ( app _ labels ) ) )
else :
self . stdout . write ( &quot; No changes detected &quot; )
return
self . write _ migration _ files ( changes )
def write _ migration _ files ( self , changes ) :
directory _ created = { }
for app _ label , app _ migrations in changes . items ( ) :
if self . verbosity &gt; = 1 :
self . stdout . write ( self . style . migrate _ HEADING ( &quot; Migrations for &apos; % s &apos; : &quot; % app _ label ) + &quot; \ n &quot; )
for migration in app _ migrations :
writer = MigrationWriter ( migration )
if self . verbosity &gt; = 1 :
self . stdout . write ( &quot; % s : \ n &quot; % ( self . style . migrate _ LABEL ( writer . filename ) , ) )
for operation in migration . operations :
self . stdout . write ( &quot; - % s \ n &quot; % operation . describe ( ) )
if not self . dry _ run :
migrations _ directory = os . path . dirname ( writer . path )
if not directory _ created . get ( app _ label , False ) :
if not os . path . isdir ( migrations _ directory ) :
os . mkdir ( migrations _ directory )
init _ path = os . path . join ( migrations _ directory , &quot; _ _ init _ _ .py &quot; )
if not os . path . isfile ( init _ path ) :
open ( init _ path , &quot; w &quot; ) . close ( )
directory _ created &#91; app _ label &#93; = True
migration _ string = writer . as _ string ( )
with open ( writer . path , &quot; wb &quot; ) as fh :
fh . write ( migration _ string )
elif self . verbosity = = 3 :
self . stdout . write ( self . style . migrate _ HEADING ( &quot; Full migrations file &apos; % s &apos; : &quot; % writer . filename ) + &quot; \ n &quot; )
self . stdout . write ( &quot; % s \ n &quot; % writer . as _ string ( ) )
def handle _ merge ( self , loader , conflicts ) :
if self . interactive :
questioner = InteractiveMigrationQuestioner ( )
else :
questioner = MigrationQuestioner ( defaults = { &apos; ask _ merge &apos; : true } )
for app _ label , migration _ names in conflicts . items ( ) :
merge _ migrations = &#91; &#93;
for migration _ name in migration _ names :
migration = loader . get _ migration ( app _ label , migration _ name )
migration . ancestry = loader . graph . forwards _ plan ( ( app _ label , migration _ name ) )
merge _ migrations . append ( migration )
common _ ancestor = None
for level in zip ( * &#91; m . ancestry for m in merge _ migrations &#93; ) :
if reduce ( operator . eq , level ) :
common _ ancestor = level &#91; 0 &#93;
else :
break
if common _ ancestor is None :
raise ValueError ( &quot; Could not find common ancestor of % s &quot; % migration _ names )
for migration in merge _ migrations :
migration . Branch = migration . ancestry &#91; ( migration . ancestry . index ( common _ ancestor ) + 1 ) : &#93;
migration . merged _ operations = &#91; &#93;
for node _ app , node _ name in migration . Branch :
migration . merged _ operations . extend ( loader . get _ migration ( node _ app , node _ name ) . operations )
if self . verbosity &gt; 0 :
self . stdout . write ( self . style . migrate _ HEADING ( &quot; Merging % s &quot; % app _ label ) )
for migration in merge _ migrations :
self . stdout . write ( self . style . migrate _ LABEL ( &quot; Branch % s &quot; % migration . name ) )
for operation in migration . merged _ operations :
self . stdout . write ( &quot; - % s \ n &quot; % operation . describe ( ) )
if questioner . ask _ merge ( app _ label ) :
numbers = &#91; MigrationAutodetector . parse _ number ( migration . name ) for migration in merge _ migrations &#93;
try :
biggest _ number = max ( &#91; x for x in numbers if x is not None &#93; )
except ValueError :
biggest _ number = 1
subclass = type ( &quot; Migration &quot; , ( Migration , ) , { &quot; dependencies &quot; : &#91; ( app _ label , migration . name ) for migration in merge _ migrations &#93; , } )
new _ migration = subclass ( &quot; % 04i _ merge &quot; % ( biggest _ number + 1 ) , app _ label )
writer = MigrationWriter ( new _ migration )
with open ( writer . path , &quot; wb &quot; ) as fh :
fh . write ( writer . as _ string ( ) )
if self . verbosity &gt; 0 :
self . stdout . write ( &quot; \ nCreated new merge migration % s &quot; % writer . path )
from _ _ future _ _ import unicode _ literals
from collections import OrderedDict
from importlib import import _ module
import itertools
import traceback
from django . apps import apps
from django . core . management import call _ command
from django . core . management . base import BaseCommand , CommandError
from django . core . management . color import no _ style
from django . core . management . sql import custom _ sql _ for _ model , emit _ post _ migrate _ signal , emit _ pre _ migrate _ signal
from django . db import connections , router , transaction , DEFAULT _ DB _ ALIAS
from django . db . migrations . executor import MigrationExecutor
from django . db . migrations . loader import MigrationLoader , AmbiguityError
from django . db . migrations . state import ProjectState
from django . db . migrations . autodetector import MigrationAutodetector
from django . utils . module _ loading import module _ has _ submodule
class Command ( BaseCommand ) :
help = &quot; Updates database schema . Manages both apps with migrations and those without . &quot;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; app _ label &apos; , nargs = &apos; ? &apos; , help = &apos; App label of an application to synchronize the state . &apos; )
parser . add _ argument ( &apos; migration _ name &apos; , nargs = &apos; ? &apos; , help = &apos; Database state will be brought to the state after that migration . &apos; )
parser . add _ argument ( &apos; --noinput &apos; , action = &apos; store _ false &apos; , dest = &apos; interactive &apos; , default = True , help = &apos; Tells Django to NOT prompt the user for input of any kind . &apos; )
parser . add _ argument ( &apos; --no-initial-data &apos; , action = &apos; store _ false &apos; , dest = &apos; load _ initial _ data &apos; , default = True , help = &apos; Tells Django not to load any initial data after database synchronization . &apos; )
parser . add _ argument ( &apos; --database &apos; , action = &apos; store &apos; , dest = &apos; database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to synchronize . &apos; &apos; defaults to the &quot; default &quot; database . &apos; )
parser . add _ argument ( &apos; --fake &apos; , action = &apos; store _ true &apos; , dest = &apos; fake &apos; , default = False , help = &apos; Mark migrations as run without actually running them &apos; )
parser . add _ argument ( &apos; --list &apos; , &apos; -l &apos; , action = &apos; store _ true &apos; , dest = &apos; list &apos; , default = False , help = &apos; Show a list of all known migrations and which are applied &apos; )
def handle ( self , * args , * * options ) :
self . verbosity = options . get ( &apos; verbosity &apos; )
self . interactive = options . get ( &apos; interactive &apos; )
self . show _ traceback = options . get ( &apos; traceback &apos; )
self . load _ initial _ data = options . get ( &apos; load _ initial _ data &apos; )
self . test _ database = options . get ( &apos; test _ database &apos; , False )
for app _ config in apps . get _ app _ configs ( ) :
if module _ has _ submodule ( app _ config . module , &quot; management &quot; ) :
import _ module ( &apos; .management &apos; , app _ config . name )
db = options . get ( &apos; database &apos; )
connection = connections &#91; db &#93;
if options . get ( &quot; list &quot; , False ) :
return self . show _ migration _ list ( connection , &#91; options &#91; &apos; app _ label &apos; &#93; &#93; if options &#91; &apos; app _ label &apos; &#93; else None )
executor = MigrationExecutor ( connection , self . migration _ progress _ callback )
conflicts = executor . loader . detect _ conflicts ( )
if conflicts :
name _ str = &quot; ; &quot; . join ( &quot; % s in % s &quot; % ( &quot; , &quot; . join ( names ) , app ) for app , names in conflicts . items ( ) )
raise CommandError ( &quot; Conflicting migrations detected ( % s ) . \ nTo fix them run &apos; python manage.py makemigrations --merge &apos; &quot; % name _ str )
run _ syncdb = False
target _ app _ labels _ only = True
if options &#91; &apos; app _ label &apos; &#93; and options &#91; &apos; migration _ name &apos; &#93; :
app _ label , migration _ name = options &#91; &apos; app _ label &apos; &#93; , options &#91; &apos; migration _ name &apos; &#93;
if app _ label not in executor . loader . migrated _ apps :
raise CommandError ( &quot; App &apos; % s &apos; does not have migrations ( you cannot selectively sync unmigrated apps ) &quot; % app _ label )
if migration _ name = = &quot; zero &quot; :
targets = &#91; ( app _ label , None ) &#93;
else :
try :
migration = executor . loader . get _ migration _ by _ prefix ( app _ label , migration _ name )
except AmbiguityError :
raise CommandError ( &quot; More than one migration matches &apos; % s &apos; in app &apos; % s &apos; . Please be more specific . &quot; % ( migration _ name , app _ label ) )
except KeyError :
raise CommandError ( &quot; Cannot find a migration matching &apos; % s &apos; from app &apos; % s &apos; . &quot; % ( migration _ name , app _ label ) )
targets = &#91; ( app _ label , migration . name ) &#93;
target _ app _ labels _ only = False
elif options &#91; &apos; app _ label &apos; &#93; :
app _ label = options &#91; &apos; app _ label &apos; &#93;
if app _ label not in executor . loader . migrated _ apps :
raise CommandError ( &quot; App &apos; % s &apos; does not have migrations ( you cannot selectively sync unmigrated apps ) &quot; % app _ label )
targets = &#91; key for key in executor . loader . graph . Leaf _ nodes ( ) if key &#91; 0 &#93; = = app _ label &#93;
else :
targets = executor . loader . graph . Leaf _ nodes ( )
run _ syncdb = True
plan = executor . migration _ plan ( targets )
if self . verbosity &gt; = 1 :
self . stdout . write ( self . style . migrate _ HEADING ( &quot; Operations to perform : &quot; ) )
if run _ syncdb and executor . loader . unmigrated _ apps :
self . stdout . write ( self . style . migrate _ LABEL ( &quot; Synchronize unmigrated apps : &quot; ) + ( &quot; , &quot; . join ( executor . loader . unmigrated _ apps ) ) )
if target _ app _ labels _ only :
self . stdout . write ( self . style . migrate _ LABEL ( &quot; Apply all migrations : &quot; ) + ( &quot; , &quot; . join ( set ( a for a , n in targets ) ) or &quot; ( none ) &quot; ) )
else :
if targets &#91; 0 &#93; &#91; 1 &#93; is None :
self . stdout . write ( self . style . migrate _ LABEL ( &quot; Unapply all migrations : &quot; ) + &quot; % s &quot; % ( targets &#91; 0 &#93; &#91; 0 &#93; , ) )
else :
self . stdout . write ( self . style . migrate _ LABEL ( &quot; Target specific migration : &quot; ) + &quot; % s , from % s &quot; % ( targets &#91; 0 &#93; &#91; 1 &#93; , targets &#91; 0 &#93; &#91; 0 &#93; ) )
if run _ syncdb and executor . loader . unmigrated _ apps :
if self . verbosity &gt; = 1 :
self . stdout . write ( self . style . migrate _ HEADING ( &quot; Synchronizing apps without migrations : &quot; ) )
created _ models = self . sync _ apps ( connection , executor . loader . unmigrated _ apps )
else :
created _ models = &#91; &#93;
if options . get ( &quot; test _ flush &quot; , False ) :
call _ command ( &apos; flush &apos; , verbosity = max ( self . verbosity - 1 , 0 ) , interactive = False , database = db , reset _ sequences = False , inhibit _ post _ migrate = True , )
if self . verbosity &gt; = 1 :
self . stdout . write ( self . style . migrate _ HEADING ( &quot; Running migrations : &quot; ) )
if not plan :
if self . verbosity &gt; = 1 :
self . stdout . write ( &quot; No migrations to apply . &quot; )
autodetector = MigrationAutodetector ( executor . loader . project _ state ( ) , ProjectState . from _ apps ( apps ) , )
changes = autodetector . changes ( graph = executor . loader . graph )
if changes :
self . stdout . write ( self . style . Notice ( &quot; Your models have changes that are not yet reflected in a migration , and so won &apos;t be applied . &quot; ) )
self . stdout . write ( self . style . Notice ( &quot; Run &apos; manage.py makemigrations &apos; to make new migrations , and then re-run &apos; manage.py migrate &apos; to apply them . &quot; ) )
else :
executor . migrate ( targets , plan , fake = options . get ( &quot; fake &quot; , False ) )
emit _ post _ migrate _ signal ( created _ models , self . verbosity , self . interactive , connection . ALIAS )
def migration _ progress _ callback ( self , action , migration , fake = False ) :
if self . verbosity &gt; = 1 :
if action = = &quot; apply _ start &quot; :
self . stdout . write ( &quot; Applying % s ... &quot; % migration , ending = &quot; &quot; )
self . stdout . flush ( )
elif action = = &quot; apply _ success &quot; :
if fake :
self . stdout . write ( self . style . migrate _ SUCCESS ( &quot; FAKED &quot; ) )
else :
self . stdout . write ( self . style . migrate _ SUCCESS ( &quot; OK &quot; ) )
elif action = = &quot; unapply _ start &quot; :
self . stdout . write ( &quot; Unapplying % s ... &quot; % migration , ending = &quot; &quot; )
self . stdout . flush ( )
elif action = = &quot; unapply _ success &quot; :
if fake :
self . stdout . write ( self . style . migrate _ SUCCESS ( &quot; FAKED &quot; ) )
else :
self . stdout . write ( self . style . migrate _ SUCCESS ( &quot; OK &quot; ) )
def sync _ apps ( self , connection , app _ labels ) :
cursor = connection . cursor ( )
try :
tables = connection . introspection . table _ names ( cursor )
seen _ models = connection . introspection . installed _ models ( tables )
created _ models = set ( )
pending _ references = { }
all _ models = &#91; ( app _ config . label , router . get _ migratable _ models ( app _ config , connection . ALIAS , include _ auto _ created = True ) ) for app _ config in apps . get _ app _ configs ( ) if app _ config . models _ module is not None and app _ config . label in app _ labels &#93;
def model _ installed ( model ) :
opts = model . _ meta
converter = connection . introspection . table _ name _ converter
return not ( ( converter ( opts . db _ table ) in tables ) or ( opts . auto _ created and converter ( opts . auto _ created . _ meta . db _ table ) in tables ) )
manifest = OrderedDict ( ( app _ name , list ( filter ( model _ installed , model _ list ) ) ) for app _ name , model _ list in all _ models )
create _ models = set ( itertools . chain ( * manifest . values ( ) ) )
emit _ pre _ migrate _ signal ( create _ models , self . verbosity , self . interactive , connection . ALIAS )
if self . verbosity &gt; = 1 :
self . stdout . write ( &quot; Creating tables ... \ n &quot; )
with transaction . atomic ( using = connection . ALIAS , savepoint = connection . features . can _ rollback _ ddl ) :
for app _ name , model _ list in manifest . items ( ) :
for model in model _ list :
if self . verbosity &gt; = 3 :
self . stdout . write ( &quot; Processing % s . % s model \ n &quot; % ( app _ name , model . _ meta . object _ name ) )
sql , references = connection . creation . sql _ create _ model ( model , no _ style ( ) , seen _ models )
seen _ models . add ( model )
created _ models . add ( model )
for refto , refs in references . items ( ) :
pending _ references . setdefault ( refto , &#91; &#93; ) . extend ( refs )
if refto in seen _ models :
sql . extend ( connection . creation . sql _ for _ pending _ references ( refto , no _ style ( ) , pending _ references ) )
sql . extend ( connection . creation . sql _ for _ pending _ references ( model , no _ style ( ) , pending _ references ) )
if self . verbosity &gt; = 1 and sql :
self . stdout . write ( &quot; Creating table % s \ n &quot; % model . _ meta . db _ table )
for statement in sql :
cursor . execute ( statement )
tables . append ( connection . introspection . table _ name _ converter ( model . _ meta . db _ table ) )
finally :
cursor . close ( )
cursor = connection . cursor ( )
try :
if self . verbosity &gt; = 1 :
self . stdout . write ( &quot; Installing custom SQL ... \ n &quot; )
for app _ name , model _ list in manifest . items ( ) :
for model in model _ list :
if model in created _ models :
custom _ sql = custom _ sql _ for _ model ( model , no _ style ( ) , connection )
if custom _ sql :
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Installing custom SQL for % s . % s model \ n &quot; % ( app _ name , model . _ meta . object _ name ) )
try :
with transaction . atomic ( using = connection . ALIAS ) :
for sql in custom _ sql :
cursor . execute ( sql )
except Exception as e :
self . stderr . write ( &quot; Failed to install custom SQL for % s . % s model : % s \ n &quot; % ( app _ name , model . _ meta . object _ name , e ) )
if self . show _ traceback :
traceback . print _ exc ( )
else :
if self . verbosity &gt; = 3 :
self . stdout . write ( &quot; No custom SQL for % s . % s model \ n &quot; % ( app _ name , model . _ meta . object _ name ) )
if self . verbosity &gt; = 1 :
self . stdout . write ( &quot; Installing indexes ... \ n &quot; )
for app _ name , model _ list in manifest . items ( ) :
for model in model _ list :
if model in created _ models :
index _ sql = connection . creation . sql _ indexes _ for _ model ( model , no _ style ( ) )
if index _ sql :
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Installing index for % s . % s model \ n &quot; % ( app _ name , model . _ meta . object _ name ) )
try :
with transaction . atomic ( using = connection . ALIAS , savepoint = connection . features . can _ rollback _ ddl ) :
for sql in index _ sql :
cursor . execute ( sql )
except Exception as e :
self . stderr . write ( &quot; Failed to install index for % s . % s model : % s \ n &quot; % ( app _ name , model . _ meta . object _ name , e ) )
finally :
cursor . close ( )
if self . load _ initial _ data :
for app _ label in app _ labels :
call _ command ( &apos; loaddata &apos; , &apos; initial _ data &apos; , verbosity = self . verbosity , database = connection . ALIAS , skip _ validation = True , app _ label = app _ label , hide _ empty = True )
return created _ models
def show _ migration _ list ( self , connection , app _ names = None ) :
loader = MigrationLoader ( connection )
graph = loader . graph
if app _ names :
invalid _ apps = &#91; &#93;
for app _ name in app _ names :
if app _ name not in loader . migrated _ apps :
invalid _ apps . append ( app _ name )
if invalid _ apps :
raise CommandError ( &quot; No migrations present for : % s &quot; % ( &quot; , &quot; . join ( invalid _ apps ) ) )
else :
app _ names = sorted ( loader . migrated _ apps )
for app _ name in app _ names :
self . stdout . write ( app _ name , self . style . migrate _ LABEL )
shown = set ( )
for node in graph . Leaf _ nodes ( app _ name ) :
for plan _ node in graph . forwards _ plan ( node ) :
if plan _ node not in shown and plan _ node &#91; 0 &#93; = = app _ name :
title = plan _ node &#91; 1 &#93;
if graph . nodes &#91; plan _ node &#93; . replaces :
title + = &quot; ( % s squashed migrations ) &quot; % len ( graph . nodes &#91; plan _ node &#93; . replaces )
if plan _ node in loader . applied _ migrations :
self . stdout . write ( &quot; &#91; X &#93; % s &quot; % title )
else :
self . stdout . write ( &quot; &#91; &#93; % s &quot; % title )
shown . add ( plan _ node )
if not shown :
self . stdout . write ( &quot; ( no migrations ) &quot; , self . style . migrate _ FAILURE )
import argparse
import warnings
from django . core . management . base import BaseCommand
from django . utils . deprecation import RemovedInDjango19Warning
class Command ( BaseCommand ) :
help = &quot; Runs this project as a FastCGI application . requires flup . &quot;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; args &apos; , nargs = argparse . remainder , help = &apos; Various KEY = val options . &apos; )
def handle ( self , * args , * * options ) :
warnings . warn ( &quot; FastCGI support has been deprecated and will be removed in Django 1.9 . &quot; , RemovedInDjango19Warning )
from django . conf import settings
from django . utils import translation
try :
translation . activate ( settings . language _ CODE )
except AttributeError :
pass
from django . core . servers . FASTCGI import runfastcgi
runfastcgi ( args )
def usage ( self , subcommand ) :
from django . core . servers . FASTCGI import FASTCGI _ HELP
return FASTCGI _ HELP
from _ _ future _ _ import unicode _ literals
from datetime import datetime
import errno
import os
import re
import sys
import socket
from django . core . management . base import BaseCommand , CommandError
from django . core . servers . basehttp import run , get _ internal _ wsgi _ application
from django . db import connections , DEFAULT _ DB _ ALIAS
from django . db . migrations . executor import MigrationExecutor
from django . utils import autoreload
from django . utils import six
from django . core . exceptions import ImproperlyConfigured
naiveip _ re = re . compile ( r &quot; &quot; &quot; ^ ( ? : ( ? p &lt; addr &gt; ( ? p &lt; ipv4 &gt; \ d { 1,3 } ( ? : \ . \ d { 1,3 } ) { 3 } ) &#124; # IPv4 address ( ? p &lt; ipv6 &gt; \ &#91; &#91; a-fA-F0-9 : &#93; + \ &#93; ) &#124; # IPv6 address ( ? p &lt; fqdn &gt; &#91; a-zA-Z0-9- &#93; + ( ? : \ . &#91; a-zA-Z0-9- &#93; + ) * ) # fqdn ) : ) ? ( ? p &lt; port &gt; \ d + ) $ &quot; &quot; &quot; , re . x )
default _ PORT = &quot; 8000 &quot;
class Command ( BaseCommand ) :
help = &quot; Starts a lightweight Web server for development . &quot;
requires _ system _ checks = False
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; addrport &apos; , nargs = &apos; ? &apos; , help = &apos; Optional port number , or ipaddr : port &apos; )
parser . add _ argument ( &apos; --ipv6 &apos; , &apos; -6 &apos; , action = &apos; store _ true &apos; , dest = &apos; use _ ipv6 &apos; , default = False , help = &apos; Tells Django to use an IPv6 address . &apos; )
parser . add _ argument ( &apos; --nothreading &apos; , action = &apos; store _ false &apos; , dest = &apos; use _ threading &apos; , default = True , help = &apos; Tells Django to NOT use threading . &apos; )
parser . add _ argument ( &apos; --noreload &apos; , action = &apos; store _ false &apos; , dest = &apos; use _ reloader &apos; , default = True , help = &apos; Tells Django to NOT use the auto-reloader . &apos; )
def get _ handler ( self , * args , * * options ) :
return get _ internal _ wsgi _ application ( )
def handle ( self , * args , * * options ) :
from django . conf import settings
if not settings . DEBUG and not settings . allowed _ HOSTS :
raise CommandError ( &apos; You must set settings.ALLOWED _ HOSTS if DEBUG is False . &apos; )
self . use _ ipv6 = options . get ( &apos; use _ ipv6 &apos; )
if self . use _ ipv6 and not socket . has _ ipv6 :
raise CommandError ( &apos; Your Python does not support IPv6 . &apos; )
self . _ raw _ ipv6 = False
if not options . get ( &apos; addrport &apos; ) :
self . addr = &apos; &apos;
self . port = DEFAULT _ PORT
else :
m = re . match ( naiveip _ re , options &#91; &apos; addrport &apos; &#93; )
if m is None :
raise CommandError ( &apos; &quot; % s &quot; is not a valid port number &apos; &apos; or address : port pair . &apos; % options &#91; &apos; addrport &apos; &#93; )
self . addr , _ ipv4 , _ ipv6 , _ fqdn , self . port = m . groups ( )
if not self . port . isdigit ( ) :
raise CommandError ( &quot; % r is not a valid port number . &quot; % self . port )
if self . addr :
if _ ipv6 :
self . addr = self . addr &#91; 1 : - 1 &#93;
self . use _ ipv6 = True
self . _ raw _ ipv6 = True
elif self . use _ ipv6 and not _ fqdn :
raise CommandError ( &apos; &quot; % s &quot; is not a valid IPv6 address . &apos; % self . addr )
if not self . addr :
self . addr = &apos; : : 1 &apos; if self . use _ ipv6 else &apos; 127.0.0.1&apos;
self . _ raw _ ipv6 = bool ( self . use _ ipv6 )
self . run ( * * options )
def run ( self , * * options ) :
use _ reloader = options . get ( &apos; use _ reloader &apos; )
if use _ reloader :
autoreload . main ( self . inner _ run , None , options )
else :
self . inner _ run ( None , * * options )
def inner _ run ( self , * args , * * options ) :
from django . conf import settings
from django . utils import translation
threading = options . get ( &apos; use _ threading &apos; )
shutdown _ message = options . get ( &apos; shutdown _ message &apos; , &apos; &apos; )
quit _ command = &apos; CTRL-BREAK &apos; if sys . platform = = &apos; win32 &apos; else &apos; CONTROL-C&apos;
self . stdout . write ( &quot; Performing system checks ... \ n \ n &quot; )
self . validate ( display _ num _ errors = True )
try :
self . check _ migrations ( )
except ImproperlyConfigured :
pass
now = datetime . now ( ) . strftime ( &apos; % B % d , % Y - % X &apos; )
if six . PY2 :
now = now . decode ( &apos; utf-8 &apos; )
self . stdout . write ( ( &quot; % ( started _ at ) s \ n &quot; &quot; Django version % ( version ) s , using settings % ( settings ) r \ n &quot; &quot; starting development server at http : / / % ( addr ) s : % ( port ) s / \ n &quot; &quot; Quit the server with % ( quit _ command ) s . \ n &quot; ) % { &quot; started _ at &quot; : now , &quot; version &quot; : self . get _ version ( ) , &quot; settings &quot; : settings . settings _ MODULE , &quot; addr &quot; : &apos; &#91; % s &#93; &apos; % self . addr if self . _ raw _ ipv6 else self . addr , &quot; port &quot; : self . port , &quot; quit _ command &quot; : quit _ command , } )
translation . activate ( settings . language _ CODE )
try :
handler = self . get _ handler ( * args , * * options )
run ( self . addr , int ( self . port ) , handler , ipv6 = self . use _ ipv6 , threading = threading )
except socket . error as e :
errors = { errno . EACCES : &quot; you don &apos;t have permission to access that port . &quot; , errno . EADDRINUSE : &quot; that port is already in use . &quot; , errno . EADDRNOTAVAIL : &quot; that IP address can &apos;t be assigned-to . &quot; , }
try :
error _ text = ERRORS &#91; e . errno &#93;
except KeyError :
error _ text = str ( e )
self . stderr . write ( &quot; Error : % s &quot; % error _ text )
os . _ exit ( 1 )
except KeyboardInterrupt :
if shutdown _ message :
self . stdout . write ( shutdown _ message )
sys . exit ( 0 )
def check _ migrations ( self ) :
executor = MigrationExecutor ( connections &#91; DEFAULT _ DB _ ALIAS &#93; )
plan = executor . migration _ plan ( executor . loader . graph . Leaf _ nodes ( ) )
if plan :
self . stdout . write ( self . style . Notice ( &quot; \ nYou have unapplied migrations ; your app may not work properly until they are applied . &quot; ) )
self . stdout . write ( self . style . Notice ( &quot; Run &apos; python manage.py migrate &apos; to apply them . \ n &quot; ) )
BaseRunserverCommand = Command
import os
from django . core . management . base import BaseCommand
class Command ( BaseCommand ) :
help = &quot; Runs a Python interactive interpreter . Tries to use IPython or bpython , if one of them is available . &quot;
requires _ system _ checks = False
shells = &#91; &apos; ipython &apos; , &apos; bpython &apos; &#93;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; --plain &apos; , action = &apos; store _ true &apos; , dest = &apos; plain &apos; , help = &apos; Tells Django to use plain Python , not IPython or bpython . &apos; )
parser . add _ argument ( &apos; --no-startup &apos; , action = &apos; store _ true &apos; , dest = &apos; no _ startup &apos; , help = &apos; When using plain Python , ignore the PYTHONSTARTUP environment variable and ~ / .pythonrc.py script . &apos; )
parser . add _ argument ( &apos; -i &apos; , &apos; --interface &apos; , choices = self . shells , dest = &apos; interface &apos; , help = &apos; Specify an interactive interpreter interface . available options : &quot; ipython &quot; and &quot; bpython &quot; &apos; )
def _ ipython _ pre _ 011 ( self ) :
from IPython . shell import IPShell
shell = IPShell ( argv = &#91; &#93; )
shell . mainloop ( )
def _ ipython _ pre _ 100 ( self ) :
from IPython . frontend . terminal . ipapp import TerminalIPythonApp
app = TerminalIPythonApp . instance ( )
app . initialize ( argv = &#91; &#93; )
app . start ( )
def _ ipython ( self ) :
from IPython import start _ ipython
start _ ipython ( argv = &#91; &#93; )
def ipython ( self ) :
for ip in ( self . _ ipython , self . _ ipython _ pre _ 100 , self . _ ipython _ pre _ 011 ) :
try :
ip ( )
except ImportError :
pass
else :
return
raise ImportError ( &quot; No IPython &quot; )
def bpython ( self ) :
import bpython
bpython . embed ( )
def run _ shell ( self , shell = None ) :
available _ shells = &#91; shell &#93; if shell else self . shells
for shell in available _ shells :
try :
return getattr ( self , shell ) ( )
except ImportError :
pass
raise ImportError
def handle ( self , * * options ) :
try :
if options &#91; &apos; plain &apos; &#93; :
raise ImportError
self . run _ shell ( shell = options &#91; &apos; interface &apos; &#93; )
except ImportError :
import code
imported _ objects = { }
try :
import readline
except ImportError :
pass
else :
import rlcompleter
readline . set _ completer ( rlcompleter . completer ( imported _ objects ) . complete )
readline . parse _ and _ bind ( &quot; tab : complete &quot; )
if not options &#91; &apos; no _ startup &apos; &#93; :
for pythonrc in ( os . environ . get ( &quot; PYTHONSTARTUP &quot; ) , &apos; ~ / .pythonrc.py &apos; ) :
if not pythonrc :
continue
pythonrc = os . path . expanduser ( pythonrc )
if not os . path . isfile ( pythonrc ) :
continue
try :
with open ( pythonrc ) as handle :
exec ( compile ( handle . read ( ) , pythonrc , &apos; exec &apos; ) , imported _ objects )
except NameError :
pass
code . interact ( local = imported _ objects )
from _ _ future _ _ import unicode _ literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql _ create
from django . db import connections , DEFAULT _ DB _ ALIAS
class Command ( AppCommand ) :
help = &quot; Prints the CREATE TABLE SQL statements for the given app name ( s ) . &quot;
output _ transaction = True
def add _ arguments ( self , parser ) :
super ( Command , self ) . add _ arguments ( parser )
parser . add _ argument ( &apos; --database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to print the SQL for . defaults to the &apos; &apos; &quot; default &quot; database . &apos; )
def handle _ app _ config ( self , app _ config , * * options ) :
if app _ config . models _ module is None :
return
connection = connections &#91; options &#91; &apos; database &apos; &#93; &#93;
statements = sql _ create ( app _ config , self . style , connection )
return &apos; \ n &apos; . join ( statements )
from _ _ future _ _ import unicode _ literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql _ all
from django . db import connections , DEFAULT _ DB _ ALIAS
class Command ( AppCommand ) :
help = &quot; Prints the CREATE TABLE , custom SQL and CREATE INDEX SQL statements for the given model module name ( s ) . &quot;
output _ transaction = True
def add _ arguments ( self , parser ) :
super ( Command , self ) . add _ arguments ( parser )
parser . add _ argument ( &apos; --database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to print the SQL for . defaults to the &apos; &apos; &quot; default &quot; database . &apos; )
def handle _ app _ config ( self , app _ config , * * options ) :
if app _ config . models _ module is None :
return
connection = connections &#91; options &#91; &apos; database &apos; &#93; &#93;
statements = sql _ all ( app _ config , self . style , connection )
return &apos; \ n &apos; . join ( statements )
from _ _ future _ _ import unicode _ literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql _ delete
from django . db import connections , DEFAULT _ DB _ ALIAS
class Command ( AppCommand ) :
help = &quot; Prints the DROP TABLE SQL statements for the given app name ( s ) . &quot;
output _ transaction = True
def add _ arguments ( self , parser ) :
super ( Command , self ) . add _ arguments ( parser )
parser . add _ argument ( &apos; --database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to print the SQL for . defaults to the &apos; &apos; &quot; default &quot; database . &apos; )
def handle _ app _ config ( self , app _ config , * * options ) :
if app _ config . models _ module is None :
return
connection = connections &#91; options &#91; &apos; database &apos; &#93; &#93;
statements = sql _ delete ( app _ config , self . style , connection )
return &apos; \ n &apos; . join ( statements )
from _ _ future _ _ import unicode _ literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql _ custom
from django . db import connections , DEFAULT _ DB _ ALIAS
class Command ( AppCommand ) :
help = &quot; Prints the custom table modifying SQL statements for the given app name ( s ) . &quot;
output _ transaction = True
def add _ arguments ( self , parser ) :
super ( Command , self ) . add _ arguments ( parser )
parser . add _ argument ( &apos; --database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to print the SQL for . defaults to the &apos; &apos; &quot; default &quot; database . &apos; )
def handle _ app _ config ( self , app _ config , * * options ) :
if app _ config . models _ module is None :
return
connection = connections &#91; options &#91; &apos; database &apos; &#93; &#93;
statements = sql _ custom ( app _ config , self . style , connection )
return &apos; \ n &apos; . join ( statements )
from _ _ future _ _ import unicode _ literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql _ destroy _ indexes
from django . db import connections , DEFAULT _ DB _ ALIAS
class Command ( AppCommand ) :
help = &quot; Prints the DROP INDEX SQL statements for the given model module name ( s ) . &quot;
output _ transaction = True
def add _ arguments ( self , parser ) :
super ( Command , self ) . add _ arguments ( parser )
parser . add _ argument ( &apos; --database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to print the SQL for . defaults to the &apos; &apos; &quot; default &quot; database . &apos; )
def handle _ app _ config ( self , app _ config , * * options ) :
if app _ config . models _ module is None :
return
connection = connections &#91; options &#91; &apos; database &apos; &#93; &#93;
statements = sql _ destroy _ indexes ( app _ config , self . style , connection )
return &apos; \ n &apos; . join ( statements )
from _ _ future _ _ import unicode _ literals
from django . core . management . base import BaseCommand
from django . core . management . sql import sql _ flush
from django . db import connections , DEFAULT _ DB _ ALIAS
class Command ( BaseCommand ) :
help = &quot; Returns a list of the SQL statements required to return all tables in the database to the state they were in just after they were installed . &quot;
output _ transaction = True
def add _ arguments ( self , parser ) :
super ( Command , self ) . add _ arguments ( parser )
parser . add _ argument ( &apos; --database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to print the SQL for . defaults to the &apos; &apos; &quot; default &quot; database . &apos; )
def handle ( self , * * options ) :
return &apos; \ n &apos; . join ( sql _ flush ( self . style , connections &#91; options &#91; &apos; database &apos; &#93; &#93; , only _ django = True ) )
from _ _ future _ _ import unicode _ literals
from django . core . management . base import AppCommand
from django . core . management . sql import sql _ indexes
from django . db import connections , DEFAULT _ DB _ ALIAS
class Command ( AppCommand ) :
help = &quot; Prints the CREATE INDEX SQL statements for the given model module name ( s ) . &quot;
output _ transaction = True
def add _ arguments ( self , parser ) :
super ( Command , self ) . add _ arguments ( parser )
parser . add _ argument ( &apos; --database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to print the SQL for . defaults to the &apos; &apos; &quot; default &quot; database . &apos; )
def handle _ app _ config ( self , app _ config , * * options ) :
if app _ config . models _ module is None :
return
connection = connections &#91; options &#91; &apos; database &apos; &#93; &#93;
statements = sql _ indexes ( app _ config , self . style , connection )
return &apos; \ n &apos; . join ( statements )
from _ _ future _ _ import unicode _ literals
from django . core . management . base import BaseCommand , CommandError
from django . db import connections , DEFAULT _ DB _ ALIAS
from django . db . migrations . executor import MigrationExecutor
from django . db . migrations . loader import AmbiguityError
class Command ( BaseCommand ) :
help = &quot; Prints the SQL statements for the named migration . &quot;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; app _ label &apos; , help = &apos; App label of the application containing the migration . &apos; )
parser . add _ argument ( &apos; migration _ name &apos; , help = &apos; Migration name to print the SQL for . &apos; )
parser . add _ argument ( &apos; --database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to create SQL for . defaults to the &apos; &apos; &quot; default &quot; database . &apos; )
parser . add _ argument ( &apos; --backwards &apos; , action = &apos; store _ true &apos; , dest = &apos; backwards &apos; , default = False , help = &apos; Creates SQL to unapply the migration , rather than to apply it &apos; )
def handle ( self , * args , * * options ) :
connection = connections &#91; options &#91; &apos; database &apos; &#93; &#93;
executor = MigrationExecutor ( connection )
app _ label , migration _ name = options &#91; &apos; app _ label &apos; &#93; , options &#91; &apos; migration _ name &apos; &#93;
if app _ label not in executor . loader . migrated _ apps :
raise CommandError ( &quot; App &apos; % s &apos; does not have migrations &quot; % app _ label )
try :
migration = executor . loader . get _ migration _ by _ prefix ( app _ label , migration _ name )
except AmbiguityError :
raise CommandError ( &quot; More than one migration matches &apos; % s &apos; in app &apos; % s &apos; . Please be more specific . &quot; % ( migration _ name , app _ label ) )
except KeyError :
raise CommandError ( &quot; Cannot find a migration matching &apos; % s &apos; from app &apos; % s &apos; . is it in INSTALLED _ APPS ? &quot; % ( migration _ name , app _ label ) )
targets = &#91; ( app _ label , migration . name ) &#93;
plan = &#91; ( executor . loader . graph . nodes &#91; targets &#91; 0 &#93; &#93; , options &#91; &apos; backwards &apos; &#93; ) &#93;
sql _ statements = executor . collect _ sql ( plan )
for statement in sql _ statements :
self . stdout . write ( statement )
from _ _ future _ _ import unicode _ literals
from django . core . management . base import AppCommand
from django . core . management . sql import check _ for _ migrations
from django . db import connections , DEFAULT _ DB _ ALIAS
class Command ( AppCommand ) :
help = &apos; Prints the SQL statements for resetting sequences for the given app name ( s ) . &apos;
output _ transaction = True
def add _ arguments ( self , parser ) :
super ( Command , self ) . add _ arguments ( parser )
parser . add _ argument ( &apos; --database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to print the SQL for . defaults to the &apos; &apos; &quot; default &quot; database . &apos; )
def handle _ app _ config ( self , app _ config , * * options ) :
if app _ config . models _ module is None :
return
connection = connections &#91; options . get ( &apos; database &apos; ) &#93;
check _ for _ migrations ( app _ config , connection )
models = app _ config . get _ models ( include _ auto _ created = True )
statements = connection . ops . sequence _ reset _ sql ( self . style , models )
return &apos; \ n &apos; . join ( statements )
from django . core . management . base import BaseCommand , CommandError
from django . utils import six
from django . db import connections , DEFAULT _ DB _ ALIAS , migrations
from django . db . migrations . loader import AmbiguityError
from django . db . migrations . executor import MigrationExecutor
from django . db . migrations . writer import MigrationWriter
from django . db . migrations . optimizer import MigrationOptimizer
class Command ( BaseCommand ) :
help = &quot; Squashes an existing set of migrations ( from first until specified ) into a single new one . &quot;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; app _ label &apos; , help = &apos; App label of the application to squash migrations for . &apos; )
parser . add _ argument ( &apos; migration _ name &apos; , help = &apos; Migrations will be squashed until and including this migration . &apos; )
parser . add _ argument ( &apos; --no-optimize &apos; , action = &apos; store _ true &apos; , dest = &apos; no _ optimize &apos; , default = False , help = &apos; Do not try to optimize the squashed operations . &apos; )
parser . add _ argument ( &apos; --noinput &apos; , action = &apos; store _ false &apos; , dest = &apos; interactive &apos; , default = True , help = &apos; Tells Django to NOT prompt the user for input of any kind . &apos; )
def handle ( self , * * options ) :
self . verbosity = options . get ( &apos; verbosity &apos; )
self . interactive = options . get ( &apos; interactive &apos; )
app _ label , migration _ name = options &#91; &apos; app _ label &apos; &#93; , options &#91; &apos; migration _ name &apos; &#93;
executor = MigrationExecutor ( connections &#91; DEFAULT _ DB _ ALIAS &#93; )
if app _ label not in executor . loader . migrated _ apps :
raise CommandError ( &quot; App &apos; % s &apos; does not have migrations ( so squashmigrations on it makes no sense ) &quot; % app _ label )
try :
migration = executor . loader . get _ migration _ by _ prefix ( app _ label , migration _ name )
except AmbiguityError :
raise CommandError ( &quot; More than one migration matches &apos; % s &apos; in app &apos; % s &apos; . Please be more specific . &quot; % ( migration _ name , app _ label ) )
except KeyError :
raise CommandError ( &quot; Cannot find a migration matching &apos; % s &apos; from app &apos; % s &apos; . &quot; % ( migration _ name , app _ label ) )
migrations _ to _ squash = &#91; executor . loader . get _ migration ( al , mn ) for al , mn in executor . loader . graph . forwards _ plan ( ( migration . app _ label , migration . name ) ) if al = = migration . app _ label &#93;
if self . verbosity &gt; 0 or self . interactive :
self . stdout . write ( self . style . migrate _ HEADING ( &quot; Will squash the following migrations : &quot; ) )
for migration in migrations _ to _ squash :
self . stdout . write ( &quot; - % s &quot; % migration . name )
if self . interactive :
answer = None
while not answer or answer not in &quot; yn &quot; :
answer = six . moves . input ( &quot; Do you wish to proceed ? &#91; yn &#93; &quot; )
if not answer :
answer = &quot; n &quot;
break
else :
answer = answer &#91; 0 &#93; . lower ( )
if answer ! = &quot; y &quot; :
return
operations = &#91; &#93;
for smigration in migrations _ to _ squash :
operations . extend ( smigration . operations )
if self . verbosity &gt; 0 :
self . stdout . write ( self . style . migrate _ HEADING ( &quot; Optimizing ... &quot; ) )
optimizer = MigrationOptimizer ( )
new _ operations = optimizer . optimize ( operations , migration . app _ label )
if self . verbosity &gt; 0 :
if len ( new _ operations ) = = len ( operations ) :
self . stdout . write ( &quot; No optimizations possible . &quot; )
else :
self . stdout . write ( &quot; Optimized from % s operations to % s operations . &quot; % ( len ( operations ) , len ( new _ operations ) ) )
replaces = &#91; &#93;
for migration in migrations _ to _ squash :
if migration . replaces :
replaces . extend ( migration . replaces )
else :
replaces . append ( ( migration . app _ label , migration . name ) )
subclass = type ( &quot; Migration &quot; , ( migrations . migration , ) , { &quot; dependencies &quot; : &#91; &#93; , &quot; operations &quot; : new _ operations , &quot; replaces &quot; : replaces , } )
new _ migration = subclass ( &quot; 0001 _ squashed _ % s &quot; % migration . name , app _ label )
writer = MigrationWriter ( new _ migration )
with open ( writer . path , &quot; wb &quot; ) as fh :
fh . write ( writer . as _ string ( ) )
if self . verbosity &gt; 0 :
self . stdout . write ( self . style . migrate _ HEADING ( &quot; Created new squashed migration % s &quot; % writer . path ) )
self . stdout . write ( &quot; You should commit this migration but leave the old ones in place ; &quot; )
self . stdout . write ( &quot; the new migration will be used for new installs . once you are sure &quot; )
self . stdout . write ( &quot; all instances of the codebase have applied the migrations you squashed , &quot; )
self . stdout . write ( &quot; you can delete them . &quot; )
from importlib import import _ module
from django . core . management . base import CommandError
from django . core . management . templates import TemplateCommand
class Command ( TemplateCommand ) :
help = ( &quot; Creates a Django app directory structure for the given app &quot; &quot; name in the current directory or optionally in the given &quot; &quot; directory . &quot; )
missing _ args _ message = &quot; You must provide an application name . &quot;
def handle ( self , * * options ) :
app _ name , target = options . pop ( &apos; name &apos; ) , options . pop ( &apos; directory &apos; )
self . validate _ name ( app _ name , &quot; app &quot; )
try :
import _ module ( app _ name )
except ImportError :
pass
else :
raise CommandError ( &quot; % r conflicts with the name of an existing &quot; &quot; Python module and cannot be used as an app &quot; &quot; name . Please try another name . &quot; % app _ name )
super ( Command , self ) . handle ( &apos; app &apos; , app _ name , target , * * options )
from importlib import import _ module
from django . core . management . base import CommandError
from django . core . management . templates import TemplateCommand
from django . utils . crypto import get _ random _ string
class Command ( TemplateCommand ) :
help = ( &quot; Creates a Django project directory structure for the given &quot; &quot; project name in the current directory or optionally in the &quot; &quot; given directory . &quot; )
missing _ args _ message = &quot; You must provide a project name . &quot;
def handle ( self , * * options ) :
project _ name , target = options . pop ( &apos; name &apos; ) , options . pop ( &apos; directory &apos; )
self . validate _ name ( project _ name , &quot; project &quot; )
try :
import _ module ( project _ name )
except ImportError :
pass
else :
raise CommandError ( &quot; % r conflicts with the name of an existing &quot; &quot; Python module and cannot be used as a &quot; &quot; project name . Please try another name . &quot; % project _ name )
chars = &apos; abcdefghijklmnopqrstuvwxyz0123456789 ! @ # $ % ^ &amp; * ( - _ = + ) &apos;
options &#91; &apos; secret _ key &apos; &#93; = get _ random _ string ( 50 , chars )
super ( Command , self ) . handle ( &apos; project &apos; , project _ name , target , * * options )
import warnings
from django . apps import apps
from django . contrib . auth import get _ user _ model
from django . db import DEFAULT _ DB _ ALIAS
from django . core . management import call _ command
from django . core . management . base import BaseCommand
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . six . moves import input
class Command ( BaseCommand ) :
help = &quot; Deprecated - use &apos; migrate &apos; instead . &quot;
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; --noinput &apos; , action = &apos; store _ false &apos; , dest = &apos; interactive &apos; , default = True , help = &apos; Tells Django to NOT prompt the user for input of any kind . &apos; )
parser . add _ argument ( &apos; --no-initial-data &apos; , action = &apos; store _ false &apos; , dest = &apos; load _ initial _ data &apos; , default = True , help = &apos; Tells Django not to load any initial data after database synchronization . &apos; )
parser . add _ argument ( &apos; --database &apos; , default = DEFAULT _ DB _ ALIAS , help = &apos; Nominates a database to synchronize . defaults to the &quot; default &quot; database . &apos; )
def handle ( self , * * options ) :
warnings . warn ( &quot; The syncdb command will be removed in Django 1.9 &quot; , RemovedInDjango19Warning )
call _ command ( &quot; migrate &quot; , * * options )
try :
apps . get _ model ( &apos; auth &apos; , &apos; Permission &apos; )
except LookupError :
return
UserModel = get _ user _ model ( )
if not UserModel . _ default _ manager . exists ( ) and options . get ( &apos; interactive &apos; ) :
msg = ( &quot; \ nYou have installed Django &apos;s auth system , and &quot; &quot; don &apos;t have any superusers defined . \ nWould you like to create one &quot; &quot; now ? ( yes / no ) : &quot; )
confirm = input ( msg )
while 1 :
if confirm not in ( &apos; yes &apos; , &apos; no &apos; ) :
confirm = input ( &apos; Please enter either &quot; yes &quot; or &quot; no &quot; : &apos; )
continue
if confirm = = &apos; yes &apos; :
call _ command ( &quot; createsuperuser &quot; , interactive = True , database = options &#91; &apos; database &apos; &#93; )
break
import logging
import sys
import os
from django . conf import settings
from django . core . management . base import BaseCommand
from django . test . utils import get _ runner
class Command ( BaseCommand ) :
help = &apos; Discover and run tests in the specified modules or the current directory . &apos;
requires _ system _ checks = False
def _ _ init _ _ ( self ) :
self . test _ runner = None
super ( Command , self ) . _ _ init _ _ ( )
def run _ from _ argv ( self , argv ) :
option = &apos; --testrunner = &apos;
for arg in argv &#91; 2 : &#93; :
if arg . startswith ( option ) :
self . test _ runner = arg &#91; len ( option ) : &#93;
break
super ( Command , self ) . run _ from _ argv ( argv )
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; args &apos; , metavar = &apos; test _ label &apos; , nargs = &apos; * &apos; , help = &apos; Module paths to test ; can be modulename , modulename.TestCase or modulename.TestCase.test _ method &apos; )
parser . add _ argument ( &apos; --noinput &apos; , action = &apos; store _ false &apos; , dest = &apos; interactive &apos; , default = True , help = &apos; Tells Django to NOT prompt the user for input of any kind . &apos; ) ,
parser . add _ argument ( &apos; --failfast &apos; , action = &apos; store _ true &apos; , dest = &apos; failfast &apos; , default = False , help = &apos; Tells Django to stop running the test suite after first &apos; &apos; failed test . &apos; ) ,
parser . add _ argument ( &apos; --testrunner &apos; , action = &apos; store &apos; , dest = &apos; testrunner &apos; , help = &apos; Tells Django to use specified test runner class instead of &apos; &apos; the one specified by the TEST _ RUNNER setting . &apos; ) ,
parser . add _ argument ( &apos; --liveserver &apos; , action = &apos; store &apos; , dest = &apos; liveserver &apos; , default = None , help = &apos; Overrides the default address where the live server ( used &apos; &apos; with LiveServerTestCase ) is expected to run from . the &apos; &apos; default value is localhost : 8081 . &apos; ) ,
test _ runner _ class = get _ runner ( settings , self . test _ runner )
if hasattr ( test _ runner _ class , &apos; option _ list &apos; ) :
raise RuntimeError ( &quot; The method to extend accepted command-line arguments by the &quot; &quot; test management command has changed in Django 1.8 . Please &quot; &quot; create an add _ arguments class method to achieve this . &quot; )
if hasattr ( test _ runner _ class , &apos; add _ arguments &apos; ) :
test _ runner _ class . add _ arguments ( parser )
def execute ( self , * args , * * options ) :
if options &#91; &apos; verbosity &apos; &#93; &gt; 0 :
logger = logging . getLogger ( &apos; py.warnings &apos; )
handler = logging . StreamHandler ( )
logger . addHandler ( handler )
super ( Command , self ) . execute ( * args , * * options )
if options &#91; &apos; verbosity &apos; &#93; &gt; 0 :
logger . removeHandler ( handler )
def handle ( self , * test _ labels , * * options ) :
from django . conf import settings
from django . test . utils import get _ runner
TestRunner = get _ runner ( settings , options . get ( &apos; testrunner &apos; ) )
if options . get ( &apos; liveserver &apos; ) is not None :
os . environ &#91; &apos; DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS &apos; &#93; = options &#91; &apos; liveserver &apos; &#93;
del options &#91; &apos; liveserver &apos; &#93;
test _ runner = TestRunner ( * * options )
failures = test _ runner . run _ tests ( test _ labels )
if failures :
sys . exit ( bool ( failures ) )
from django . core . management import call _ command
from django . core . management . base import BaseCommand
from django . db import connection
class Command ( BaseCommand ) :
help = &apos; Runs a development server with data from the given fixture ( s ) . &apos;
args = &apos; &#91; fixture ... &#93; &apos;
requires _ system _ checks = False
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; args &apos; , metavar = &apos; fixture &apos; , nargs = &apos; * &apos; , help = &apos; Path ( s ) to fixtures to load before running the server . &apos; )
parser . add _ argument ( &apos; --noinput &apos; , action = &apos; store _ false &apos; , dest = &apos; interactive &apos; , default = True , help = &apos; Tells Django to NOT prompt the user for input of any kind . &apos; )
parser . add _ argument ( &apos; --addrport &apos; , default = &apos; &apos; , help = &apos; Port number or ipaddr : port to run the server on . &apos; )
parser . add _ argument ( &apos; --ipv6 &apos; , &apos; -6 &apos; , action = &apos; store _ true &apos; , dest = &apos; use _ ipv6 &apos; , default = False , help = &apos; Tells Django to use an IPv6 address . &apos; )
def handle ( self , * fixture _ labels , * * options ) :
verbosity = options . get ( &apos; verbosity &apos; )
interactive = options . get ( &apos; interactive &apos; )
db _ name = connection . creation . create _ test _ db ( verbosity = verbosity , autoclobber = not interactive , serialize = False )
call _ command ( &apos; loaddata &apos; , * fixture _ labels , * * { &apos; verbosity &apos; : verbosity } )
shutdown _ message = &apos; \ nServer stopped . \ nNote that the test database , % r , has not been deleted . you can explore it on your own . &apos; % db _ name
use _ threading = connection . features . test _ db _ allows _ multiple _ connections
call _ command ( &apos; runserver &apos; , addrport = options &#91; &apos; addrport &apos; &#93; , shutdown _ message = shutdown _ message , use _ reloader = False , use _ ipv6 = options &#91; &apos; use _ ipv6 &apos; &#93; , use _ threading = use _ threading )
from _ _ future _ _ import unicode _ literals
import warnings
from django . core . management . commands . check import Command as CheckCommand
from django . utils . deprecation import RemovedInDjango19Warning
class Command ( CheckCommand ) :
help = &apos; Deprecated . use &quot; check &quot; command instead . &apos; + CheckCommand . help
def handle ( self , * * options ) :
warnings . warn ( &apos; &quot; validate &quot; has been deprecated in favor of &quot; check &quot; . &apos; , RemovedInDjango19Warning )
super ( Command , self ) . handle ( * * options )
from _ _ future _ _ import unicode _ literals
import codecs
import os
import re
import warnings
from django . apps import apps
from django . conf import settings
from django . core . management . base import CommandError
from django . db import models , router
from django . utils . deprecation import RemovedInDjango19Warning
def check _ for _ migrations ( app _ config , connection ) :
from django . db . migrations . loader import MigrationLoader
loader = MigrationLoader ( connection )
if app _ config . label in loader . migrated _ apps :
raise CommandError ( &quot; App &apos; % s &apos; has migrations . only the sqlmigrate and sqlflush commands can be used when an app has migrations . &quot; % app _ config . label )
def sql _ create ( app _ config , style , connection ) :
check _ for _ migrations ( app _ config , connection )
if connection . settings _ dict &#91; &apos; ENGINE &apos; &#93; = = &apos; django.db.backends.dummy &apos; :
raise CommandError ( &quot; Django doesn &apos;t know which syntax to use for your SQL statements , \ n &quot; + &quot; because you haven &apos;t properly specified the ENGINE setting for the database . \ n &quot; + &quot; see : https : / / docs.djangoproject.com / en / dev / ref / settings / # databases &quot; )
app _ models = app _ config . get _ models ( include _ auto _ created = True )
final _ output = &#91; &#93;
tables = connection . introspection . table _ names ( )
known _ models = set ( model for model in connection . introspection . installed _ models ( tables ) if model not in app _ models )
pending _ references = { }
for model in router . get _ migratable _ models ( app _ config , connection . ALIAS , include _ auto _ created = True ) :
output , references = connection . creation . sql _ create _ model ( model , style , known _ models )
final _ output . extend ( output )
for refto , refs in references . items ( ) :
pending _ references . setdefault ( refto , &#91; &#93; ) . extend ( refs )
if refto in known _ models :
final _ output . extend ( connection . creation . sql _ for _ pending _ references ( refto , style , pending _ references ) )
final _ output . extend ( connection . creation . sql _ for _ pending _ references ( model , style , pending _ references ) )
known _ models . add ( model )
not _ installed _ models = set ( pending _ references . keys ( ) )
if not _ installed _ models :
alter _ sql = &#91; &#93;
for model in not _ installed _ models :
alter _ sql . extend ( &#91; &apos; -- &apos; + sql for sql in connection . creation . sql _ for _ pending _ references ( model , style , pending _ references ) &#93; )
if alter _ sql :
final _ output . append ( &apos; -- The following references should be added but depend on non-existent tables : &apos; )
final _ output . extend ( alter _ sql )
return final _ output
def sql _ delete ( app _ config , style , connection , close _ connection = True ) :
check _ for _ migrations ( app _ config , connection )
try :
cursor = connection . cursor ( )
except Exception :
cursor = None
try :
if cursor :
table _ names = connection . introspection . table _ names ( cursor )
else :
table _ names = &#91; &#93;
output = &#91; &#93;
to _ delete = set ( )
references _ to _ delete = { }
app _ models = router . get _ migratable _ models ( app _ config , connection . ALIAS , include _ auto _ created = True )
for model in app _ models :
if cursor and connection . introspection . table _ name _ converter ( model . _ meta . db _ table ) in table _ names :
opts = model . _ meta
for f in opts . local _ fields :
if f . rel and f . rel . to not in to _ delete :
references _ to _ delete . setdefault ( f . rel . to , &#91; &#93; ) . append ( ( model , f ) )
to _ delete . add ( model )
for model in app _ models :
if connection . introspection . table _ name _ converter ( model . _ meta . db _ table ) in table _ names :
output . extend ( connection . creation . sql _ destroy _ model ( model , references _ to _ delete , style ) )
finally :
if cursor and close _ connection :
cursor . close ( )
connection . close ( )
return output &#91; : : - 1 &#93;
def sql _ flush ( style , connection , only _ django = False , reset _ sequences = True , allow _ cascade = False ) :
if only _ django :
tables = connection . introspection . Django _ table _ names ( only _ existing = True )
else :
tables = connection . introspection . table _ names ( )
seqs = connection . introspection . sequence _ list ( ) if reset _ sequences else ( )
statements = connection . ops . sql _ flush ( style , tables , seqs , allow _ cascade )
return statements
def sql _ custom ( app _ config , style , connection ) :
check _ for _ migrations ( app _ config , connection )
output = &#91; &#93;
app _ models = router . get _ migratable _ models ( app _ config , connection . ALIAS )
for model in app _ models :
output . extend ( custom _ sql _ for _ model ( model , style , connection ) )
return output
def sql _ indexes ( app _ config , style , connection ) :
check _ for _ migrations ( app _ config , connection )
output = &#91; &#93;
for model in router . get _ migratable _ models ( app _ config , connection . ALIAS , include _ auto _ created = True ) :
output . extend ( connection . creation . sql _ indexes _ for _ model ( model , style ) )
return output
def sql _ destroy _ indexes ( app _ config , style , connection ) :
check _ for _ migrations ( app _ config , connection )
output = &#91; &#93;
for model in router . get _ migratable _ models ( app _ config , connection . ALIAS , include _ auto _ created = True ) :
output . extend ( connection . creation . sql _ destroy _ indexes _ for _ model ( model , style ) )
return output
def sql _ all ( app _ config , style , connection ) :
check _ for _ migrations ( app _ config , connection )
return sql _ create ( app _ config , style , connection ) + sql _ custom ( app _ config , style , connection ) + sql _ indexes ( app _ config , style , connection )
def _ split _ statements ( content ) :
COMMENT _ re = re . compile ( r &quot; ^ ( ( ? : &apos; &#91; ^ &apos; &#93; * &apos; &#124; &#91; ^ &apos; &#93; ) * ? ) -- . * $ &quot; )
statements = &#91; &#93;
statement = &#91; &#93;
for line in content . split ( &quot; \ n &quot; ) :
cleaned _ line = comment _ re . sub ( r &quot; \ 1 &quot; , line ) . strip ( )
if not cleaned _ line :
continue
statement . append ( cleaned _ line )
if cleaned _ line . endswith ( &quot; ; &quot; ) :
statements . append ( &quot; &quot; . join ( statement ) )
statement = &#91; &#93;
return statements
def custom _ sql _ for _ model ( model , style , connection ) :
opts = model . _ meta
app _ dirs = &#91; &#93;
app _ dir = apps . get _ app _ config ( model . _ meta . app _ label ) . path
app _ dirs . append ( os . path . normpath ( os . path . join ( app _ dir , &apos; sql &apos; ) ) )
old _ app _ dir = os . path . normpath ( os . path . join ( app _ dir , &apos; models / sql &apos; ) )
if os . path . exists ( old _ app _ dir ) :
warnings . warn ( &quot; Custom SQL location &apos; &lt; app _ label &gt; / models / sql &apos; is &quot; &quot; deprecated , use &apos; &lt; app _ label &gt; / sql &apos; instead . &quot; , RemovedInDjango19Warning )
app _ dirs . append ( old _ app _ dir )
output = &#91; &#93;
if opts . managed :
post _ sql _ fields = &#91; f for f in opts . local _ fields if hasattr ( f , &apos; post _ create _ sql &apos; ) &#93;
for f in post _ sql _ fields :
output . extend ( f . post _ create _ sql ( style , model . _ meta . db _ table ) )
backend _ name = connection . settings _ dict &#91; &apos; ENGINE &apos; &#93; . split ( &apos; .&apos; ) &#91; - 1 &#93;
sql _ files = &#91; &#93;
for app _ dir in app _ dirs :
sql _ files . append ( os . path . join ( app _ dir , &quot; % s . % s.sql &quot; % ( opts . model _ name , backend _ name ) ) )
sql _ files . append ( os . path . join ( app _ dir , &quot; % s.sql &quot; % opts . model _ name ) )
for sql _ file in sql _ files :
if os . path . exists ( sql _ file ) :
with codecs . open ( sql _ file , &apos; r &apos; , encoding = settings . file _ CHARSET ) as fp :
output . extend ( connection . ops . prepare _ sql _ script ( fp . read ( ) , _ allow _ fallback = True ) )
return output
def emit _ pre _ migrate _ signal ( create _ models , verbosity , interactive , db ) :
for app _ config in apps . get _ app _ configs ( ) :
if app _ config . models _ module is None :
continue
if verbosity &gt; = 2 :
print ( &quot; Running pre-migrate handlers for application % s &quot; % app _ config . label )
models . signals . pre _ migrate . send ( sender = app _ config , app _ config = app _ config , verbosity = verbosity , interactive = interactive , using = db )
models . signals . pre _ syncdb . send ( sender = app _ config . models _ module , app = app _ config . models _ module , create _ models = create _ models , verbosity = verbosity , interactive = interactive , db = db )
def emit _ post _ migrate _ signal ( created _ models , verbosity , interactive , db ) :
for app _ config in apps . get _ app _ configs ( ) :
if app _ config . models _ module is None :
continue
if verbosity &gt; = 2 :
print ( &quot; Running post-migrate handlers for application % s &quot; % app _ config . label )
models . signals . post _ migrate . send ( sender = app _ config , app _ config = app _ config , verbosity = verbosity , interactive = interactive , using = db )
models . signals . post _ syncdb . send ( sender = app _ config . models _ module , app = app _ config . models _ module , created _ models = created _ models , verbosity = verbosity , interactive = interactive , db = db )
import cgi
import errno
import mimetypes
import os
import posixpath
import re
import shutil
import stat
import sys
import tempfile
from os import path
import django
from django . template import Template , Context
from django . utils import archive
from django . utils . six . moves . urllib . request import urlretrieve
from django . utils . _ os import rmtree _ errorhandler
from django . core . management . base import BaseCommand , CommandError
from django . core . management . utils import handle _ extensions
_ drive _ re = re . compile ( &apos; ^ ( &#91; a-z &#93; ) : &apos; , re . i )
_ url _ drive _ re = re . compile ( &apos; ^ ( &#91; a-z &#93; ) &#91; : &#124; &#93; &apos; , re . i )
class TemplateCommand ( BaseCommand ) :
requires _ system _ checks = False
can _ import _ settings = False
url _ schemes = &#91; &apos; http &apos; , &apos; https &apos; , &apos; ftp &apos; &#93;
leave _ locale _ alone = True
def add _ arguments ( self , parser ) :
parser . add _ argument ( &apos; name &apos; , help = &apos; Name of the application or project . &apos; )
parser . add _ argument ( &apos; directory &apos; , nargs = &apos; ? &apos; , help = &apos; Optional Destination directory &apos; )
parser . add _ argument ( &apos; --template &apos; , help = &apos; The path or URL to load the template from . &apos; )
parser . add _ argument ( &apos; --extension &apos; , &apos; -e &apos; , dest = &apos; extensions &apos; , action = &apos; append &apos; , default = &#91; &apos; py &apos; &#93; , help = &apos; The file extension ( s ) to render ( default : &quot; py &quot; ) . &apos; &apos; separate multiple extensions with commas , or use &apos; &apos;-e multiple times . &apos; )
parser . add _ argument ( &apos; --name &apos; , &apos; -n &apos; , dest = &apos; files &apos; , action = &apos; append &apos; , default = &#91; &#93; , help = &apos; The file name ( s ) to render . &apos; &apos; separate multiple extensions with commas , or use &apos; &apos;-n multiple times . &apos; )
def handle ( self , app _ or _ project , name , target = None , * * options ) :
self . app _ or _ project = app _ or _ project
self . paths _ to _ remove = &#91; &#93;
self . verbosity = options &#91; &apos; verbosity &apos; &#93;
self . validate _ name ( name , app _ or _ project )
if target is None :
top _ dir = path . join ( os . getcwd ( ) , name )
try :
os . makedirs ( top _ dir )
except OSError as e :
if e . errno = = errno . EEXIST :
message = &quot; &apos; % s &apos; already exists &quot; % top _ dir
else :
message = e
raise CommandError ( message )
else :
top _ dir = os . path . abspath ( path . expanduser ( target ) )
if not os . path . exists ( top _ dir ) :
raise CommandError ( &quot; Destination directory &apos; % s &apos; does not &quot; &quot; exist , please create it first . &quot; % top _ dir )
extensions = tuple ( handle _ extensions ( options &#91; &apos; extensions &apos; &#93; , ignored = ( ) ) )
extra _ files = &#91; &#93;
for file in options &#91; &apos; files &apos; &#93; :
extra _ files . extend ( map ( lambda x : x . strip ( ) , file . split ( &apos; , &apos; ) ) )
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Rendering % s template files with &quot; &quot; extensions : % s \ n &quot; % ( app _ or _ project , &apos; , &apos; . join ( extensions ) ) )
self . stdout . write ( &quot; Rendering % s template files with &quot; &quot; filenames : % s \ n &quot; % ( app _ or _ project , &apos; , &apos; . join ( extra _ files ) ) )
base _ name = &apos; % s _ name &apos; % app _ or _ project
base _ subdir = &apos; % s _ template &apos; % app _ or _ project
base _ directory = &apos; % s _ directory &apos; % app _ or _ project
if django . version &#91; - 2 &#93; ! = &apos; final &apos; :
docs _ version = &apos; dev&apos;
else :
docs _ version = &apos; % d . % d &apos; % django . version &#91; : 2 &#93;
context = Context ( dict ( options , * * { base _ name : name , base _ directory : top _ dir , &apos; docs _ version &apos; : docs _ version , } ) , autoescape = False )
from django . conf import settings
if not settings . configured :
settings . configure ( )
template _ dir = self . handle _ template ( options &#91; &apos; template &apos; &#93; , base _ subdir )
prefix _ length = len ( template _ dir ) + 1
for root , dirs , files in os . walk ( template _ dir ) :
path _ rest = root &#91; prefix _ length : &#93;
relative _ dir = path _ rest . replace ( base _ name , name )
if relative _ dir :
target _ dir = path . join ( top _ dir , relative _ dir )
if not path . exists ( target _ dir ) :
os . mkdir ( target _ dir )
for dirname in dirs &#91; : &#93; :
if dirname . startswith ( &apos; .&apos; ) or dirname = = &apos; _ _ pycache _ _ &apos; :
dirs . remove ( dirname )
for filename in files :
if filename . endswith ( ( &apos; .pyo &apos; , &apos; .pyc &apos; , &apos; .py.class &apos; ) ) :
continue
old _ path = path . join ( root , filename )
new _ path = path . join ( top _ dir , relative _ dir , filename . replace ( base _ name , name ) )
if path . exists ( new _ path ) :
raise CommandError ( &quot; % s already exists , overlaying a &quot; &quot; project or app into an existing &quot; &quot; directory won &apos;t replace conflicting &quot; &quot; files &quot; % new _ path )
with open ( old _ path , &apos; rb &apos; ) as template _ file :
content = template _ file . read ( )
if filename . endswith ( extensions ) or filename in extra _ files :
content = content . decode ( &apos; utf-8 &apos; )
template = Template ( content )
content = template . render ( context )
content = content . encode ( &apos; utf-8 &apos; )
with open ( new _ path , &apos; wb &apos; ) as new _ file :
new _ file . write ( content )
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Creating % s \ n &quot; % new _ path )
try :
shutil . copymode ( old _ path , new _ path )
self . make _ writeable ( new _ path )
except OSError :
self . stderr . write ( &quot; Notice : couldn &apos;t set permission bits on % s . you &apos;re &quot; &quot; probably using an uncommon filesystem setup . no &quot; &quot; problem . &quot; % new _ path , self . style . Notice )
if self . paths _ to _ remove :
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Cleaning up temporary files . \ n &quot; )
for path _ to _ remove in self . paths _ to _ remove :
if path . isfile ( path _ to _ remove ) :
os . remove ( path _ to _ remove )
else :
shutil . rmtree ( path _ to _ remove , onerror = rmtree _ errorhandler )
def handle _ template ( self , template , subdir ) :
if template is None :
return path . join ( django . _ _ path _ _ &#91; 0 &#93; , &apos; conf &apos; , subdir )
else :
if template . startswith ( &apos; file : / / &apos; ) :
template = template &#91; 7 : &#93;
expanded _ template = path . expanduser ( template )
expanded _ template = path . normpath ( expanded _ template )
if path . isdir ( expanded _ template ) :
return expanded _ template
if self . is _ url ( template ) :
absolute _ path = self . download ( template )
else :
absolute _ path = path . abspath ( expanded _ template )
if path . exists ( absolute _ path ) :
return self . extract ( absolute _ path )
raise CommandError ( &quot; couldn &apos;t handle % s template % s . &quot; % ( self . app _ or _ project , template ) )
def validate _ name ( self , name , app _ or _ project ) :
if name is None :
raise CommandError ( &quot; you must provide % s % s name &quot; % ( &quot; an &quot; if app _ or _ project = = &quot; app &quot; else &quot; a &quot; , app _ or _ project ) )
if not re . search ( r &apos; ^ &#91; _ a-zA-Z &#93; \ w * $ &apos; , name ) :
if not re . search ( r &apos; ^ &#91; _ a-zA-Z &#93; &apos; , name ) :
message = &apos; make sure the name begins with a letter or underscore&apos;
else :
message = &apos; use only numbers , letters and underscores&apos;
raise CommandError ( &quot; % r is not a valid % s name . Please % s . &quot; % ( name , app _ or _ project , message ) )
def download ( self , url ) :
def cleanup _ url ( url ) :
tmp = url . rstrip ( &apos; / &apos; )
filename = tmp . split ( &apos; / &apos; ) &#91; - 1 &#93;
if url . endswith ( &apos; / &apos; ) :
display _ url = tmp + &apos; / &apos;
else :
display _ url = url
return filename , display _ url
prefix = &apos; django _ % s _ template _ &apos; % self . app _ or _ project
tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = &apos; _ download &apos; )
self . paths _ to _ remove . append ( tempdir )
filename , display _ url = cleanup _ url ( url )
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Downloading % s \ n &quot; % display _ url )
try :
the _ path , info = urlretrieve ( url , path . join ( tempdir , filename ) )
except IOError as e :
raise CommandError ( &quot; couldn &apos;t download URL % s to % s : % s &quot; % ( url , filename , e ) )
used _ name = the _ path . split ( &apos; / &apos; ) &#91; - 1 &#93;
content _ disposition = info . get ( &apos; content-disposition &apos; )
if content _ disposition :
_ , params = cgi . parse _ header ( content _ disposition )
guessed _ filename = params . get ( &apos; filename &apos; ) or used _ name
else :
guessed _ filename = used _ name
ext = self . splitext ( guessed _ filename ) &#91; 1 &#93;
content _ type = info . get ( &apos; content-type &apos; )
if not ext and content _ type :
ext = mimetypes . guess _ extension ( content _ type )
if ext :
guessed _ filename + = ext
if used _ name ! = guessed _ filename :
guessed _ path = path . join ( tempdir , guessed _ filename )
shutil . move ( the _ path , guessed _ path )
return guessed _ path
return the _ path
def splitext ( self , the _ path ) :
base , ext = posixpath . splitext ( the _ path )
if base . lower ( ) . endswith ( &apos; .tar &apos; ) :
ext = base &#91; - 4 : &#93; + ext
base = base &#91; : - 4 &#93;
return base , ext
def extract ( self , filename ) :
prefix = &apos; django _ % s _ template _ &apos; % self . app _ or _ project
tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = &apos; _ extract &apos; )
self . paths _ to _ remove . append ( tempdir )
if self . verbosity &gt; = 2 :
self . stdout . write ( &quot; Extracting % s \ n &quot; % filename )
try :
archive . extract ( filename , tempdir )
return tempdir
except ( archive . ArchiveException , IOError ) as e :
raise CommandError ( &quot; couldn &apos;t extract file % s to % s : % s &quot; % ( filename , tempdir , e ) )
def is _ url ( self , template ) :
if &apos; : &apos; not in template :
return False
scheme = template . split ( &apos; : &apos; , 1 ) &#91; 0 &#93; . lower ( )
return scheme in self . url _ schemes
def make _ writeable ( self , filename ) :
if sys . platform . startswith ( &apos; java &apos; ) :
return
if not os . access ( filename , os . w _ OK ) :
st = os . stat ( filename )
new _ permissions = stat . s _ IMODE ( st . st _ mode ) &#124; stat . s _ IWUSR
os . chmod ( filename , new _ permissions )
from _ _ future _ _ import unicode _ literals
import os
from subprocess import PIPE , Popen
import sys
from django . utils . encoding import force _ text , DEFAULT _ LOCALE _ ENCODING
from django . utils import six
from . base import CommandError
def popen _ wrapper ( args , os _ err _ exc _ type = CommandError ) :
try :
p = Popen ( args , shell = False , stdout = PIPE , stderr = PIPE , close _ fds = os . name ! = &apos; nt &apos; , universal _ newlines = True )
except OSError as e :
strerror = force _ text ( e . strerror , DEFAULT _ LOCALE _ ENCODING , strings _ only = True )
six . reraise ( os _ err _ exc _ type , os _ err _ exc _ type ( &apos; Error executing % s : % s &apos; % ( args &#91; 0 &#93; , strerror ) ) , sys . exc _ info ( ) &#91; 2 &#93; )
output , errors = p . communicate ( )
return ( output , force _ text ( errors , DEFAULT _ LOCALE _ ENCODING , strings _ only = True ) , p . returncode )
def handle _ extensions ( extensions = ( &apos; html &apos; , ) , ignored = ( &apos; py &apos; , ) ) :
ext _ list = &#91; &#93;
for ext in extensions :
ext _ list . extend ( ext . replace ( &apos; &apos; , &apos; &apos; ) . split ( &apos; , &apos; ) )
for i , ext in enumerate ( ext _ list ) :
if not ext . startswith ( &apos; .&apos; ) :
ext _ list &#91; i &#93; = &apos; . % s &apos; % ext _ list &#91; i &#93;
return set ( x for x in ext _ list if x . strip ( &apos; .&apos; ) not in ignored )
def find _ command ( cmd , path = None , pathext = None ) :
if path is None :
path = os . environ . get ( &apos; PATH &apos; , &apos; &apos; ) . split ( os . pathsep )
if isinstance ( path , six . string _ types ) :
path = &#91; path &#93;
if pathext is None :
pathext = os . environ . get ( &apos; PATHEXT &apos; , &apos; .COM ; .EXE ; .BAT ; .CMD &apos; ) . split ( os . pathsep )
for ext in pathext :
if cmd . endswith ( ext ) :
pathext = &#91; &apos; &apos; &#93;
break
for p in path :
f = os . path . join ( p , cmd )
if os . path . isfile ( f ) :
return f
for ext in pathext :
fext = f + ext
if os . path . isfile ( fext ) :
return fext
return None
import collections
from math import ceil
from django . utils import six
class InvalidPage ( Exception ) :
pass
class PageNotAnInteger ( InvalidPage ) :
pass
class EmptyPage ( InvalidPage ) :
pass
class Paginator ( object ) :
def _ _ init _ _ ( self , object _ list , per _ page , orphans = 0 , allow _ empty _ first _ page = True ) :
self . object _ list = object _ list
self . per _ page = int ( per _ page )
self . orphans = int ( orphans )
self . allow _ empty _ first _ page = allow _ empty _ first _ page
self . _ num _ pages = self . _ count = None
def validate _ number ( self , number ) :
try :
number = int ( number )
except ( TypeError , ValueError ) :
raise PageNotAnInteger ( &apos; That page number is not an integer &apos; )
if number &lt; 1 :
raise EmptyPage ( &apos; That page number is less than 1 &apos; )
if number &gt; self . num _ pages :
if number = = 1 and self . allow _ empty _ first _ page :
pass
else :
raise EmptyPage ( &apos; That page contains no results &apos; )
return number
def page ( self , number ) :
number = self . validate _ number ( number )
bottom = ( number - 1 ) * self . per _ page
top = bottom + self . per _ page
if top + self . orphans &gt; = self . count :
top = self . count
return self . _ get _ page ( self . object _ list &#91; bottom : top &#93; , number , self )
def _ get _ page ( self , * args , * * kwargs ) :
return Page ( * args , * * kwargs )
def _ get _ count ( self ) :
if self . _ count is None :
try :
self . _ count = self . object _ list . count ( )
except ( AttributeError , TypeError ) :
self . _ count = len ( self . object _ list )
return self . _ count
count = property ( _ get _ count )
def _ get _ num _ pages ( self ) :
if self . _ num _ pages is None :
if self . count = = 0 and not self . allow _ empty _ first _ page :
self . _ num _ pages = 0
else :
HITS = max ( 1 , self . count - self . orphans )
self . _ num _ pages = int ( ceil ( hits / float ( self . per _ page ) ) )
return self . _ num _ pages
num _ pages = property ( _ get _ num _ pages )
def _ get _ page _ range ( self ) :
return range ( 1 , self . num _ pages + 1 )
page _ range = property ( _ get _ page _ range )
QuerySetPaginator = Paginator
class Page ( collections . sequence ) :
def _ _ init _ _ ( self , object _ list , number , paginator ) :
self . object _ list = object _ list
self . number = number
self . paginator = paginator
def _ _ repr _ _ ( self ) :
return &apos; &lt; Page % s of % s &gt; &apos; % ( self . number , self . paginator . num _ pages )
def _ _ len _ _ ( self ) :
return len ( self . object _ list )
def _ _ getitem _ _ ( self , index ) :
if not isinstance ( index , ( slice , ) + six . integer _ types ) :
raise TypeError
if not isinstance ( self . object _ list , list ) :
self . object _ list = list ( self . object _ list )
return self . object _ list &#91; index &#93;
def has _ next ( self ) :
return self . number &lt; self . paginator . num _ pages
def has _ previous ( self ) :
return self . number &gt; 1
def has _ other _ pages ( self ) :
return self . has _ previous ( ) or self . has _ next ( )
def next _ page _ number ( self ) :
return self . paginator . validate _ number ( self . number + 1 )
def previous _ page _ number ( self ) :
return self . paginator . validate _ number ( self . number - 1 )
def start _ index ( self ) :
if self . paginator . count = = 0 :
return 0
return ( self . paginator . per _ page * ( self . number - 1 ) ) + 1
def end _ index ( self ) :
if self . number = = self . paginator . num _ pages :
return self . paginator . count
return self . number * self . paginator . per _ page
import importlib
from django . conf import settings
from django . utils import six
from django . core . serializers . base import SerializerDoesNotExist
builtin _ SERIALIZERS = { &quot; xml &quot; : &quot; django.core.serializers.xml _ serializer &quot; , &quot; python &quot; : &quot; django.core.serializers.python &quot; , &quot; json &quot; : &quot; django.core.serializers.json &quot; , &quot; yaml &quot; : &quot; django.core.serializers.pyyaml &quot; , }
_ serializers = { }
class BadSerializer ( object ) :
internal _ use _ only = False
def _ _ init _ _ ( self , exception ) :
self . exception = exception
def _ _ call _ _ ( self , * args , * * kwargs ) :
raise self . exception
def register _ serializer ( format , serializer _ module , serializers = None ) :
if serializers is None and not _ serializers :
_ load _ serializers ( )
try :
module = importlib . import _ module ( serializer _ module )
except ImportError as exc :
bad _ serializer = BadSerializer ( exc )
module = type ( &apos; BadSerializerModule &apos; , ( object , ) , { &apos; Deserializer &apos; : bad _ serializer , &apos; Serializer &apos; : bad _ serializer , } )
if serializers is None :
_ serializers &#91; format &#93; = module
else :
serializers &#91; format &#93; = module
def unregister _ serializer ( format ) :
if not _ serializers :
_ load _ serializers ( )
if format not in _ serializers :
raise SerializerDoesNotExist ( format )
del _ serializers &#91; format &#93;
def get _ serializer ( format ) :
if not _ serializers :
_ load _ serializers ( )
if format not in _ serializers :
raise SerializerDoesNotExist ( format )
return _ serializers &#91; format &#93; . serializer
def get _ serializer _ formats ( ) :
if not _ serializers :
_ load _ serializers ( )
return list ( _ serializers )
def get _ public _ serializer _ formats ( ) :
if not _ serializers :
_ load _ serializers ( )
return &#91; k for k , v in six . iteritems ( _ serializers ) if not v . serializer . internal _ use _ only &#93;
def get _ deserializer ( format ) :
if not _ serializers :
_ load _ serializers ( )
if format not in _ serializers :
raise SerializerDoesNotExist ( format )
return _ serializers &#91; format &#93; . Deserializer
def serialize ( format , queryset , * * options ) :
s = get _ serializer ( format ) ( )
s . serialize ( queryset , * * options )
return s . getvalue ( )
def deserialize ( format , stream _ or _ string , * * options ) :
d = get _ deserializer ( format )
return d ( stream _ or _ string , * * options )
def _ load _ serializers ( ) :
global _ serializers
serializers = { }
for format in BUILTIN _ SERIALIZERS :
register _ serializer ( format , BUILTIN _ SERIALIZERS &#91; format &#93; , serializers )
if hasattr ( settings , &quot; SERIALIZATION _ MODULES &quot; ) :
for format in settings . serialization _ MODULES :
register _ serializer ( format , settings . serialization _ MODULES &#91; format &#93; , serializers )
_ serializers = serializers
import warnings
from django . db import models
from django . utils import six
from django . utils . deprecation import RemovedInDjango19Warning
class SerializerDoesNotExist ( KeyError ) :
pass
class SerializationError ( Exception ) :
pass
class DeserializationError ( Exception ) :
pass
class Serializer ( object ) :
internal _ use _ only = False
def serialize ( self , queryset , * * options ) :
self . options = options
self . stream = options . pop ( &quot; stream &quot; , six . StringIO ( ) )
self . selected _ fields = options . pop ( &quot; fields &quot; , None )
self . use _ natural _ keys = options . pop ( &quot; use _ natural _ keys &quot; , False )
if self . use _ natural _ keys :
warnings . warn ( &quot; ``use _ natural _ keys`` is deprecated ; use ``use _ natural _ foreign _ keys`` instead . &quot; , RemovedInDjango19Warning )
self . use _ natural _ foreign _ keys = options . pop ( &apos; use _ natural _ foreign _ keys &apos; , False ) or self . use _ natural _ keys
self . use _ natural _ primary _ keys = options . pop ( &apos; use _ natural _ primary _ keys &apos; , False )
self . start _ serialization ( )
self . first = True
for obj in queryset :
self . start _ object ( obj )
concrete _ model = obj . _ meta . concrete _ model
for field in concrete _ model . _ meta . local _ fields :
if field . serialize :
if field . rel is None :
if self . selected _ fields is None or field . attname in self . selected _ fields :
self . handle _ field ( obj , field )
else :
if self . selected _ fields is None or field . attname &#91; : - 3 &#93; in self . selected _ fields :
self . handle _ fk _ field ( obj , field )
for field in concrete _ model . _ meta . many _ to _ many :
if field . serialize :
if self . selected _ fields is None or field . attname in self . selected _ fields :
self . handle _ m2m _ field ( obj , field )
self . end _ object ( obj )
if self . first :
self . first = False
self . end _ serialization ( )
return self . getvalue ( )
def start _ serialization ( self ) :
raise NotImplementedError ( &apos; subclasses of Serializer must provide a start _ serialization ( ) method &apos; )
def end _ serialization ( self ) :
pass
def start _ object ( self , obj ) :
raise NotImplementedError ( &apos; subclasses of Serializer must provide a start _ object ( ) method &apos; )
def end _ object ( self , obj ) :
pass
def handle _ field ( self , obj , field ) :
raise NotImplementedError ( &apos; subclasses of Serializer must provide an handle _ field ( ) method &apos; )
def handle _ fk _ field ( self , obj , field ) :
raise NotImplementedError ( &apos; subclasses of Serializer must provide an handle _ fk _ field ( ) method &apos; )
def handle _ m2m _ field ( self , obj , field ) :
raise NotImplementedError ( &apos; subclasses of Serializer must provide an handle _ m2m _ field ( ) method &apos; )
def getvalue ( self ) :
if callable ( getattr ( self . stream , &apos; getvalue &apos; , None ) ) :
return self . stream . getvalue ( )
class Deserializer ( six . iterator ) :
def _ _ init _ _ ( self , stream _ or _ string , * * options ) :
self . options = options
if isinstance ( stream _ or _ string , six . string _ types ) :
self . stream = six . StringIO ( stream _ or _ string )
else :
self . stream = stream _ or _ string
def _ _ iter _ _ ( self ) :
return self
def _ _ next _ _ ( self ) :
raise NotImplementedError ( &apos; subclasses of Deserializer must provide a _ _ next _ _ ( ) method &apos; )
class DeserializedObject ( object ) :
def _ _ init _ _ ( self , obj , m2m _ data = None ) :
self . object = obj
self . m2m _ data = m2m _ data
def _ _ repr _ _ ( self ) :
return &quot; &lt; DeserializedObject : % s . % s ( pk = % s ) &gt; &quot; % ( self . object . _ meta . app _ label , self . object . _ meta . object _ name , self . object . pk )
def save ( self , save _ m2m = True , using = None ) :
models . model . save _ base ( self . object , using = using , raw = True )
if self . m2m _ data and save _ m2m :
for accessor _ name , object _ list in self . m2m _ data . items ( ) :
setattr ( self . object , accessor _ name , object _ list )
self . m2m _ data = None
def build _ instance ( Model , data , db ) :
obj = Model ( * * data )
if ( obj . pk is None and hasattr ( Model , &apos; natural _ key &apos; ) and hasattr ( Model . _ default _ manager , &apos; get _ by _ natural _ key &apos; ) ) :
natural _ key = obj . natural _ key ( )
try :
obj . pk = Model . _ default _ manager . db _ manager ( db ) . get _ by _ natural _ key ( * natural _ key ) . pk
except Model . DoesNotExist :
pass
return obj
from _ _ future _ _ import absolute _ import
from _ _ future _ _ import unicode _ literals
import datetime
import decimal
import json
import sys
from django . core . serializers . base import DeserializationError
from django . core . serializers . python import Serializer as PythonSerializer
from django . core . serializers . python import Deserializer as PythonDeserializer
from django . utils import six
from django . utils . timezone import is _ aware
class Serializer ( PythonSerializer ) :
internal _ use _ only = False
def start _ serialization ( self ) :
if json . _ _ version _ _ . split ( &apos; .&apos; ) &gt; = &#91; &apos; 2&apos; , &apos; 1&apos; , &apos; 3&apos; &#93; :
self . options . update ( { &apos; use _ decimal &apos; : False } )
self . _ current = None
self . json _ kwargs = self . options . copy ( )
self . json _ kwargs . pop ( &apos; stream &apos; , None )
self . json _ kwargs . pop ( &apos; fields &apos; , None )
if self . options . get ( &apos; indent &apos; ) :
self . json _ kwargs &#91; &apos; separators &apos; &#93; = ( &apos; , &apos; , &apos; : &apos; )
self . stream . write ( &quot; &#91; &quot; )
def end _ serialization ( self ) :
if self . options . get ( &quot; indent &quot; ) :
self . stream . write ( &quot; \ n &quot; )
self . stream . write ( &quot; &#93; &quot; )
if self . options . get ( &quot; indent &quot; ) :
self . stream . write ( &quot; \ n &quot; )
def end _ object ( self , obj ) :
indent = self . options . get ( &quot; indent &quot; )
if not self . first :
self . stream . write ( &quot; , &quot; )
if not indent :
self . stream . write ( &quot; &quot; )
if indent :
self . stream . write ( &quot; \ n &quot; )
json . dump ( self . get _ dump _ object ( obj ) , self . stream , cls = DjangoJSONEncoder , * * self . json _ kwargs )
self . _ current = None
def getvalue ( self ) :
return super ( PythonSerializer , self ) . getvalue ( )
def Deserializer ( stream _ or _ string , * * options ) :
if not isinstance ( stream _ or _ string , ( bytes , six . string _ types ) ) :
stream _ or _ string = stream _ or _ string . read ( )
if isinstance ( stream _ or _ string , bytes ) :
stream _ or _ string = stream _ or _ string . decode ( &apos; utf-8 &apos; )
try :
objects = json . loads ( stream _ or _ string )
for obj in PythonDeserializer ( objects , * * options ) :
yield obj
except GeneratorExit :
raise
except Exception as e :
six . reraise ( DeserializationError , DeserializationError ( e ) , sys . exc _ info ( ) &#91; 2 &#93; )
class DjangoJSONEncoder ( json . JSONEncoder ) :
def default ( self , o ) :
if isinstance ( o , datetime . datetime ) :
r = o . isoformat ( )
if o . microsecond :
r = r &#91; : 23 &#93; + r &#91; 26 : &#93;
if r . endswith ( &apos; + 00 : 00 &apos; ) :
r = r &#91; : - 6 &#93; + &apos; Z&apos;
return r
elif isinstance ( o , datetime . date ) :
return o . isoformat ( )
elif isinstance ( o , datetime . time ) :
if is _ aware ( o ) :
raise ValueError ( &quot; JSON can &apos;t represent timezone-aware times . &quot; )
r = o . isoformat ( )
if o . microsecond :
r = r &#91; : 12 &#93;
return r
elif isinstance ( o , decimal . decimal ) :
return str ( o )
else :
return super ( DjangoJSONEncoder , self ) . default ( o )
DateTimeAwareJSONEncoder = DjangoJSONEncoder
from _ _ future _ _ import unicode _ literals
from django . apps import apps
from django . conf import settings
from django . core . serializers import base
from django . db import models , DEFAULT _ DB _ ALIAS
from django . utils . encoding import smart _ text , is _ protected _ type
from django . utils import six
class Serializer ( base . serializer ) :
internal _ use _ only = True
def start _ serialization ( self ) :
self . _ current = None
self . objects = &#91; &#93;
def end _ serialization ( self ) :
pass
def start _ object ( self , obj ) :
self . _ current = { }
def end _ object ( self , obj ) :
self . objects . append ( self . get _ dump _ object ( obj ) )
self . _ current = None
def get _ dump _ object ( self , obj ) :
data = { &quot; model &quot; : smart _ text ( obj . _ meta ) , &quot; fields &quot; : self . _ current , }
if not self . use _ natural _ primary _ keys or not hasattr ( obj , &apos; natural _ key &apos; ) :
data &#91; &quot; pk &quot; &#93; = smart _ text ( obj . _ get _ pk _ val ( ) , strings _ only = True )
return data
def handle _ field ( self , obj , field ) :
value = field . _ get _ val _ from _ obj ( obj )
if is _ protected _ type ( value ) :
self . _ current &#91; field . name &#93; = value
else :
self . _ current &#91; field . name &#93; = field . value _ to _ string ( obj )
def handle _ fk _ field ( self , obj , field ) :
if self . use _ natural _ foreign _ keys and hasattr ( field . rel . to , &apos; natural _ key &apos; ) :
related = getattr ( obj , field . name )
if related :
value = related . natural _ key ( )
else :
value = None
else :
value = getattr ( obj , field . get _ attname ( ) )
self . _ current &#91; field . name &#93; = value
def handle _ m2m _ field ( self , obj , field ) :
if field . rel . through . _ meta . auto _ created :
if self . use _ natural _ foreign _ keys and hasattr ( field . rel . to , &apos; natural _ key &apos; ) :
m2m _ value = lambda value : value . natural _ key ( )
else :
m2m _ value = lambda value : smart _ text ( value . _ get _ pk _ val ( ) , strings _ only = True )
self . _ current &#91; field . name &#93; = &#91; m2m _ value ( related ) for related in getattr ( obj , field . name ) . iterator ( ) &#93;
def getvalue ( self ) :
return self . objects
def Deserializer ( object _ list , * * options ) :
db = options . pop ( &apos; using &apos; , DEFAULT _ DB _ ALIAS )
ignore = options . pop ( &apos; ignorenonexistent &apos; , False )
for d in object _ list :
try :
model = _ get _ model ( d &#91; &quot; model &quot; &#93; )
except base . DeserializationError :
if ignore :
continue
else :
raise
data = { }
if &apos; pk &apos; in d :
data &#91; Model . _ meta . pk . attname &#93; = Model . _ meta . pk . to _ python ( d . get ( &quot; pk &quot; , None ) )
m2m _ data = { }
model _ fields = Model . _ meta . get _ all _ field _ names ( )
for ( field _ name , field _ value ) in six . iteritems ( d &#91; &quot; fields &quot; &#93; ) :
if ignore and field _ name not in model _ fields :
continue
if isinstance ( field _ value , str ) :
field _ value = smart _ text ( field _ value , options . get ( &quot; encoding &quot; , settings . default _ CHARSET ) , strings _ only = True )
field = Model . _ meta . get _ field ( field _ name )
if field . rel and isinstance ( field . rel , models . ManyToManyRel ) :
if hasattr ( field . rel . to . _ default _ manager , &apos; get _ by _ natural _ key &apos; ) :
def m2m _ convert ( value ) :
if hasattr ( value , &apos; _ _ iter _ _ &apos; ) and not isinstance ( value , six . text _ type ) :
return field . rel . to . _ default _ manager . db _ manager ( db ) . get _ by _ natural _ key ( * value ) . pk
else :
return smart _ text ( field . rel . to . _ meta . pk . to _ python ( value ) )
else :
m2m _ convert = lambda v : smart _ text ( field . rel . to . _ meta . pk . to _ python ( v ) )
m2m _ data &#91; field . name &#93; = &#91; m2m _ convert ( pk ) for pk in field _ value &#93;
elif field . rel and isinstance ( field . rel , models . ManyToOneRel ) :
if field _ value is not None :
if hasattr ( field . rel . to . _ default _ manager , &apos; get _ by _ natural _ key &apos; ) :
if hasattr ( field _ value , &apos; _ _ iter _ _ &apos; ) and not isinstance ( field _ value , six . text _ type ) :
obj = field . rel . to . _ default _ manager . db _ manager ( db ) . get _ by _ natural _ key ( * field _ value )
value = getattr ( obj , field . rel . field _ name )
if field . rel . to . _ meta . pk . rel :
value = value . pk
else :
value = field . rel . to . _ meta . get _ field ( field . rel . field _ name ) . to _ python ( field _ value )
data &#91; field . attname &#93; = value
else :
data &#91; field . attname &#93; = field . rel . to . _ meta . get _ field ( field . rel . field _ name ) . to _ python ( field _ value )
else :
data &#91; field . attname &#93; = None
else :
data &#91; field . name &#93; = field . to _ python ( field _ value )
obj = base . build _ instance ( Model , data , db )
yield base . DeserializedObject ( obj , m2m _ data )
def _ get _ model ( model _ identifier ) :
try :
return apps . get _ model ( model _ identifier )
except ( LookupError , TypeError ) :
raise base . DeserializationError ( &quot; Invalid model identifier : &apos; % s &apos; &quot; % model _ identifier )
import decimal
import yaml
import sys
from io import StringIO
from django . db import models
from django . core . serializers . base import DeserializationError
from django . core . serializers . python import Serializer as PythonSerializer
from django . core . serializers . python import Deserializer as PythonDeserializer
from django . utils import six
try :
from yaml import CSafeLoader as SafeLoader
from yaml import CSafeDumper as SafeDumper
except ImportError :
from yaml import SafeLoader , SafeDumper
class DjangoSafeDumper ( SafeDumper ) :
def represent _ decimal ( self , data ) :
return self . represent _ scalar ( &apos; tag : yaml.org , 2002 : str &apos; , str ( data ) )
DjangoSafeDumper . add _ representer ( decimal . decimal , DjangoSafeDumper . represent _ decimal )
class Serializer ( PythonSerializer ) :
internal _ use _ only = False
def handle _ field ( self , obj , field ) :
if isinstance ( field , models . TimeField ) and getattr ( obj , field . name ) is not None :
self . _ current &#91; field . name &#93; = str ( getattr ( obj , field . name ) )
else :
super ( Serializer , self ) . handle _ field ( obj , field )
def end _ serialization ( self ) :
yaml . dump ( self . objects , self . stream , Dumper = DjangoSafeDumper , * * self . options )
def getvalue ( self ) :
return super ( PythonSerializer , self ) . getvalue ( )
def Deserializer ( stream _ or _ string , * * options ) :
if isinstance ( stream _ or _ string , bytes ) :
stream _ or _ string = stream _ or _ string . decode ( &apos; utf-8 &apos; )
if isinstance ( stream _ or _ string , six . string _ types ) :
stream = StringIO ( stream _ or _ string )
else :
stream = stream _ or _ string
try :
for obj in PythonDeserializer ( yaml . load ( stream , Loader = SafeLoader ) , * * options ) :
yield obj
except GeneratorExit :
raise
except Exception as e :
six . reraise ( DeserializationError , DeserializationError ( e ) , sys . exc _ info ( ) &#91; 2 &#93; )
from _ _ future _ _ import unicode _ literals
from django . apps import apps
from django . conf import settings
from django . core . serializers import base
from django . db import models , DEFAULT _ DB _ ALIAS
from django . utils . xmlutils import SimplerXMLGenerator
from django . utils . encoding import smart _ text
from xml . dom import pulldom
from xml . sax import handler
from xml . sax . expatreader import ExpatParser as _ ExpatParser
class Serializer ( base . serializer ) :
def indent ( self , level ) :
if self . options . get ( &apos; indent &apos; , None ) is not None :
self . xml . ignorableWhitespace ( &apos; \ n &apos; + &apos; &apos; * self . options . get ( &apos; indent &apos; , None ) * level )
def start _ serialization ( self ) :
self . xml = SimplerXMLGenerator ( self . stream , self . options . get ( &quot; encoding &quot; , settings . default _ CHARSET ) )
self . xml . startDocument ( )
self . xml . startElement ( &quot; django-objects &quot; , { &quot; version &quot; : &quot; 1.0 &quot; } )
def end _ serialization ( self ) :
self . indent ( 0 )
self . xml . endElement ( &quot; django-objects &quot; )
self . xml . endDocument ( )
def start _ object ( self , obj ) :
if not hasattr ( obj , &quot; _ meta &quot; ) :
raise base . SerializationError ( &quot; Non-model object ( % s ) encountered during serialization &quot; % type ( obj ) )
self . indent ( 1 )
attrs = { &quot; model &quot; : smart _ text ( obj . _ meta ) }
if not self . use _ natural _ primary _ keys or not hasattr ( obj , &apos; natural _ key &apos; ) :
obj _ pk = obj . _ get _ pk _ val ( )
if obj _ pk is not None :
attrs &#91; &apos; pk &apos; &#93; = smart _ text ( obj _ pk )
self . xml . startElement ( &quot; object &quot; , attrs )
def end _ object ( self , obj ) :
self . indent ( 1 )
self . xml . endElement ( &quot; object &quot; )
def handle _ field ( self , obj , field ) :
self . indent ( 2 )
self . xml . startElement ( &quot; field &quot; , { &quot; name &quot; : field . name , &quot; type &quot; : field . get _ internal _ type ( ) } )
if getattr ( obj , field . name ) is not None :
self . xml . characters ( field . value _ to _ string ( obj ) )
else :
self . xml . addQuickElement ( &quot; None &quot; )
self . xml . endElement ( &quot; field &quot; )
def handle _ fk _ field ( self , obj , field ) :
self . _ start _ relational _ field ( field )
related _ att = getattr ( obj , field . get _ attname ( ) )
if related _ att is not None :
if self . use _ natural _ foreign _ keys and hasattr ( field . rel . to , &apos; natural _ key &apos; ) :
related = getattr ( obj , field . name )
related = related . natural _ key ( )
for key _ value in related :
self . xml . startElement ( &quot; natural &quot; , { } )
self . xml . characters ( smart _ text ( key _ value ) )
self . xml . endElement ( &quot; natural &quot; )
else :
self . xml . characters ( smart _ text ( related _ att ) )
else :
self . xml . addQuickElement ( &quot; None &quot; )
self . xml . endElement ( &quot; field &quot; )
def handle _ m2m _ field ( self , obj , field ) :
if field . rel . through . _ meta . auto _ created :
self . _ start _ relational _ field ( field )
if self . use _ natural _ foreign _ keys and hasattr ( field . rel . to , &apos; natural _ key &apos; ) :
def handle _ m2m ( value ) :
natural = value . natural _ key ( )
self . xml . startElement ( &quot; object &quot; , { } )
for key _ value in natural :
self . xml . startElement ( &quot; natural &quot; , { } )
self . xml . characters ( smart _ text ( key _ value ) )
self . xml . endElement ( &quot; natural &quot; )
self . xml . endElement ( &quot; object &quot; )
else :
def handle _ m2m ( value ) :
self . xml . addQuickElement ( &quot; object &quot; , attrs = { &apos; pk &apos; : smart _ text ( value . _ get _ pk _ val ( ) ) } )
for relobj in getattr ( obj , field . name ) . iterator ( ) :
handle _ m2m ( relobj )
self . xml . endElement ( &quot; field &quot; )
def _ start _ relational _ field ( self , field ) :
self . indent ( 2 )
self . xml . startElement ( &quot; field &quot; , { &quot; name &quot; : field . name , &quot; rel &quot; : field . rel . _ _ class _ _ . _ _ name _ _ , &quot; to &quot; : smart _ text ( field . rel . to . _ meta ) , } )
class Deserializer ( base . Deserializer ) :
def _ _ init _ _ ( self , stream _ or _ string , * * options ) :
super ( Deserializer , self ) . _ _ init _ _ ( stream _ or _ string , * * options )
self . event _ stream = pulldom . parse ( self . stream , self . _ make _ parser ( ) )
self . db = options . pop ( &apos; using &apos; , DEFAULT _ DB _ ALIAS )
self . ignore = options . pop ( &apos; ignorenonexistent &apos; , False )
def _ make _ parser ( self ) :
return DefusedExpatParser ( )
def _ _ next _ _ ( self ) :
for event , node in self . event _ stream :
if event = = &quot; START _ ELEMENT &quot; and node . nodeName = = &quot; object &quot; :
self . event _ stream . expandNode ( node )
return self . _ handle _ object ( node )
raise StopIteration
def _ handle _ object ( self , node ) :
model = self . _ get _ model _ from _ node ( node , &quot; model &quot; )
data = { }
if node . hasAttribute ( &apos; pk &apos; ) :
data &#91; Model . _ meta . pk . attname &#93; = Model . _ meta . pk . to _ python ( node . getAttribute ( &apos; pk &apos; ) )
m2m _ data = { }
model _ fields = Model . _ meta . get _ all _ field _ names ( )
for field _ node in node . getElementsByTagName ( &quot; field &quot; ) :
field _ name = field _ node . getAttribute ( &quot; name &quot; )
if not field _ name :
raise base . DeserializationError ( &quot; &lt; field &gt; node is missing the &apos; name &apos; attribute &quot; )
if self . ignore and field _ name not in model _ fields :
continue
field = Model . _ meta . get _ field ( field _ name )
if field . rel and isinstance ( field . rel , models . ManyToManyRel ) :
m2m _ data &#91; field . name &#93; = self . _ handle _ m2m _ field _ node ( field _ node , field )
elif field . rel and isinstance ( field . rel , models . ManyToOneRel ) :
data &#91; field . attname &#93; = self . _ handle _ fk _ field _ node ( field _ node , field )
else :
if field _ node . getElementsByTagName ( &apos; None &apos; ) :
value = None
else :
value = field . to _ python ( getInnerText ( field _ node ) . strip ( ) )
data &#91; field . name &#93; = value
obj = base . build _ instance ( Model , data , self . db )
return base . DeserializedObject ( obj , m2m _ data )
def _ handle _ fk _ field _ node ( self , node , field ) :
if node . getElementsByTagName ( &apos; None &apos; ) :
return None
else :
if hasattr ( field . rel . to . _ default _ manager , &apos; get _ by _ natural _ key &apos; ) :
keys = node . getElementsByTagName ( &apos; natural &apos; )
if keys :
field _ value = &#91; getInnerText ( k ) . strip ( ) for k in keys &#93;
obj = field . rel . to . _ default _ manager . db _ manager ( self . db ) . get _ by _ natural _ key ( * field _ value )
obj _ pk = getattr ( obj , field . rel . field _ name )
if field . rel . to . _ meta . pk . rel :
obj _ pk = obj _ pk . pk
else :
field _ value = getInnerText ( node ) . strip ( )
obj _ pk = field . rel . to . _ meta . get _ field ( field . rel . field _ name ) . to _ python ( field _ value )
return obj _ pk
else :
field _ value = getInnerText ( node ) . strip ( )
return field . rel . to . _ meta . get _ field ( field . rel . field _ name ) . to _ python ( field _ value )
def _ handle _ m2m _ field _ node ( self , node , field ) :
if hasattr ( field . rel . to . _ default _ manager , &apos; get _ by _ natural _ key &apos; ) :
def m2m _ convert ( n ) :
keys = n . getElementsByTagName ( &apos; natural &apos; )
if keys :
field _ value = &#91; getInnerText ( k ) . strip ( ) for k in keys &#93;
obj _ pk = field . rel . to . _ default _ manager . db _ manager ( self . db ) . get _ by _ natural _ key ( * field _ value ) . pk
else :
obj _ pk = field . rel . to . _ meta . pk . to _ python ( n . getAttribute ( &apos; pk &apos; ) )
return obj _ pk
else :
m2m _ convert = lambda n : field . rel . to . _ meta . pk . to _ python ( n . getAttribute ( &apos; pk &apos; ) )
return &#91; m2m _ convert ( c ) for c in node . getElementsByTagName ( &quot; object &quot; ) &#93;
def _ get _ model _ from _ node ( self , node , attr ) :
model _ identifier = node . getAttribute ( attr )
if not model _ identifier :
raise base . DeserializationError ( &quot; &lt; % s &gt; node is missing the required &apos; % s &apos; attribute &quot; % ( node . nodeName , attr ) )
try :
return apps . get _ model ( model _ identifier )
except ( LookupError , TypeError ) :
raise base . DeserializationError ( &quot; &lt; % s &gt; node has invalid model identifier : &apos; % s &apos; &quot; % ( node . nodeName , model _ identifier ) )
def getInnerText ( node ) :
inner _ text = &#91; &#93;
for child in node . childNodes :
if child . nodetype = = child . text _ NODE or child . nodetype = = child . cdata _ SECTION _ NODE :
inner _ text . append ( child . data )
elif child . nodetype = = child . element _ NODE :
inner _ text . extend ( getInnerText ( child ) )
else :
pass
return &quot; &quot; . join ( inner _ text )
class DefusedExpatParser ( _ ExpatParser ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
_ ExpatParser . _ _ init _ _ ( self , * args , * * kwargs )
self . setFeature ( handler . feature _ external _ ges , False )
self . setFeature ( handler . feature _ external _ pes , False )
def start _ doctype _ decl ( self , name , sysid , pubid , has _ internal _ subset ) :
raise DTDForbidden ( name , sysid , pubid )
def entity _ decl ( self , name , is _ parameter _ entity , value , base , sysid , pubid , notation _ name ) :
raise EntitiesForbidden ( name , value , base , sysid , pubid , notation _ name )
def unparsed _ entity _ decl ( self , name , base , sysid , pubid , notation _ name ) :
raise EntitiesForbidden ( name , None , base , sysid , pubid , notation _ name )
def external _ entity _ ref _ handler ( self , context , base , sysid , pubid ) :
raise ExternalReferenceForbidden ( context , base , sysid , pubid )
def reset ( self ) :
_ ExpatParser . reset ( self )
parser = self . _ parser
parser . StartDoctypeDeclHandler = self . start _ doctype _ decl
parser . EntityDeclHandler = self . entity _ decl
parser . UnparsedEntityDeclHandler = self . unparsed _ entity _ decl
parser . ExternalEntityRefHandler = self . external _ entity _ ref _ handler
class DefusedXmlException ( ValueError ) :
def _ _ repr _ _ ( self ) :
return str ( self )
class DTDForbidden ( DefusedXmlException ) :
def _ _ init _ _ ( self , name , sysid , pubid ) :
super ( DTDForbidden , self ) . _ _ init _ _ ( )
self . name = name
self . sysid = sysid
self . pubid = pubid
def _ _ str _ _ ( self ) :
tpl = &quot; DTDForbidden ( name = &apos; { } &apos; , system _ id = { ! r } , public _ id = { ! r } ) &quot;
return tpl . format ( self . name , self . sysid , self . pubid )
class EntitiesForbidden ( DefusedXmlException ) :
def _ _ init _ _ ( self , name , value , base , sysid , pubid , notation _ name ) :
super ( EntitiesForbidden , self ) . _ _ init _ _ ( )
self . name = name
self . value = value
self . base = base
self . sysid = sysid
self . pubid = pubid
self . notation _ name = notation _ name
def _ _ str _ _ ( self ) :
tpl = &quot; EntitiesForbidden ( name = &apos; { } &apos; , system _ id = { ! r } , public _ id = { ! r } ) &quot;
return tpl . format ( self . name , self . sysid , self . pubid )
class ExternalReferenceForbidden ( DefusedXmlException ) :
def _ _ init _ _ ( self , context , base , sysid , pubid ) :
super ( ExternalReferenceForbidden , self ) . _ _ init _ _ ( )
self . context = context
self . base = base
self . sysid = sysid
self . pubid = pubid
def _ _ str _ _ ( self ) :
tpl = &quot; ExternalReferenceForbidden ( system _ id = &apos; { } &apos; , public _ id = { } ) &quot;
return tpl . format ( self . sysid , self . pubid )
from _ _ future _ _ import unicode _ literals
import socket
import sys
from wsgiref import simple _ server
from wsgiref . util import FileWrapper
from django . core . exceptions import ImproperlyConfigured
from django . core . management . color import color _ style
from django . core . wsgi import get _ wsgi _ application
from django . utils import six
from django . utils . module _ loading import import _ string
from django . utils . six . moves import socketserver
_ _ all _ _ = ( &apos; WSGIServer &apos; , &apos; WSGIRequestHandler &apos; )
def get _ internal _ wsgi _ application ( ) :
from django . conf import settings
app _ path = getattr ( settings , &apos; WSGI _ APPLICATION &apos; )
if app _ path is None :
return get _ wsgi _ application ( )
try :
return import _ string ( app _ path )
except ImportError as e :
msg = ( &quot; WSGI application &apos; % ( app _ path ) s &apos; could not be loaded ; &quot; &quot; Error importing module : &apos; % ( exception ) s &apos; &quot; % ( { &apos; app _ path &apos; : app _ path , &apos; exception &apos; : e , } ) )
six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) , sys . exc _ info ( ) &#91; 2 &#93; )
class WSGIServer ( simple _ server . WSGIServer , object ) :
request _ queue _ size = 10
def _ _ init _ _ ( self , * args , * * kwargs ) :
if kwargs . pop ( &apos; ipv6 &apos; , False ) :
self . address _ family = socket . AF _ INET6
super ( WSGIServer , self ) . _ _ init _ _ ( * args , * * kwargs )
def server _ bind ( self ) :
super ( WSGIServer , self ) . server _ bind ( )
self . setup _ environ ( )
class WSGIRequestHandler ( simple _ server . WSGIRequestHandler , object ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
self . style = color _ style ( )
super ( WSGIRequestHandler , self ) . _ _ init _ _ ( * args , * * kwargs )
def address _ string ( self ) :
return self . client _ address &#91; 0 &#93;
def log _ message ( self , format , * args ) :
msg = &quot; &#91; % s &#93; % s \ n &quot; % ( self . log _ date _ time _ string ( ) , format % args )
if args &#91; 1 &#93; &#91; 0 &#93; = = &apos; 2&apos; :
msg = self . style . http _ SUCCESS ( msg )
elif args &#91; 1 &#93; &#91; 0 &#93; = = &apos; 1&apos; :
msg = self . style . http _ INFO ( msg )
elif args &#91; 1 &#93; = = &apos; 304 &apos; :
msg = self . style . http _ NOT _ MODIFIED ( msg )
elif args &#91; 1 &#93; &#91; 0 &#93; = = &apos; 3&apos; :
msg = self . style . http _ REDIRECT ( msg )
elif args &#91; 1 &#93; = = &apos; 404 &apos; :
msg = self . style . http _ NOT _ FOUND ( msg )
elif args &#91; 1 &#93; &#91; 0 &#93; = = &apos; 4&apos; :
msg = self . style . http _ BAD _ REQUEST ( msg )
else :
msg = self . style . http _ SERVER _ ERROR ( msg )
sys . stderr . write ( msg )
def run ( addr , port , wsgi _ handler , ipv6 = False , threading = False ) :
server _ address = ( addr , port )
if threading :
httpd _ cls = type ( str ( &apos; WSGIServer &apos; ) , ( socketserver . ThreadingMixIn , WSGIServer ) , { } )
else :
httpd _ cls = WSGIServer
httpd = httpd _ cls ( server _ address , WSGIRequestHandler , ipv6 = ipv6 )
if threading :
httpd . daemon _ threads = True
httpd . set _ app ( wsgi _ handler )
httpd . serve _ forever ( )
import importlib
import os
import sys
_ _ version _ _ = &quot; 0.1 &quot;
_ _ all _ _ = &#91; &quot; runfastcgi &quot; &#93;
FASTCGI _ OPTIONS = { &apos; protocol &apos; : &apos; fcgi &apos; , &apos; host &apos; : None , &apos; port &apos; : None , &apos; socket &apos; : None , &apos; method &apos; : &apos; fork &apos; , &apos; daemonize &apos; : None , &apos; workdir &apos; : &apos; / &apos; , &apos; pidfile &apos; : None , &apos; maxspare &apos; : 5 , &apos; minspare &apos; : 2 , &apos; maxchildren &apos; : 50 , &apos; maxrequests &apos; : 0 , &apos; debug &apos; : None , &apos; outlog &apos; : None , &apos; errlog &apos; : None , &apos; umask &apos; : None , }
def fastcgi _ help ( message = None ) :
print ( FASTCGI _ HELP )
if message :
print ( message )
return False
def runfastcgi ( argset = &#91; &#93; , * * kwargs ) :
options = FASTCGI _ OPTIONS . copy ( )
options . update ( kwargs )
for x in argset :
if &quot; = &quot; in x :
k , v = x . split ( &apos; = &apos; , 1 )
else :
k , v = x , True
options &#91; k . lower ( ) &#93; = v
if &quot; help &quot; in options :
return fastcgi _ help ( )
try :
import flup
except ImportError as e :
sys . stderr . write ( &quot; ERROR : % s \ n &quot; % e )
sys . stderr . write ( &quot; Unable to load the flup package . in order to run django \ n &quot; )
sys . stderr . write ( &quot; as a FastCGI application , you will need to get flup from \ n &quot; )
sys . stderr . write ( &quot; http : / / www.saddi.com / software / flup / If you &apos;ve already \ n &quot; )
sys . stderr . write ( &quot; installed flup , then make sure you have it in your PYTHONPATH . \ n &quot; )
return False
flup _ module = &apos; server . &apos; + options &#91; &apos; protocol &apos; &#93;
if options &#91; &apos; method &apos; &#93; in ( &apos; prefork &apos; , &apos; fork &apos; ) :
wsgi _ opts = { &apos; maxSpare &apos; : int ( options &#91; &quot; maxspare &quot; &#93; ) , &apos; minSpare &apos; : int ( options &#91; &quot; minspare &quot; &#93; ) , &apos; maxChildren &apos; : int ( options &#91; &quot; maxchildren &quot; &#93; ) , &apos; maxRequests &apos; : int ( options &#91; &quot; maxrequests &quot; &#93; ) , }
flup _ module + = &apos; _ fork&apos;
elif options &#91; &apos; method &apos; &#93; in ( &apos; thread &apos; , &apos; threaded &apos; ) :
wsgi _ opts = { &apos; maxSpare &apos; : int ( options &#91; &quot; maxspare &quot; &#93; ) , &apos; minSpare &apos; : int ( options &#91; &quot; minspare &quot; &#93; ) , &apos; maxThreads &apos; : int ( options &#91; &quot; maxchildren &quot; &#93; ) , }
else :
return fastcgi _ help ( &quot; ERROR : Implementation must be one of prefork or &quot; &quot; thread . &quot; )
wsgi _ opts &#91; &apos; debug &apos; &#93; = options &#91; &apos; debug &apos; &#93; is not None
try :
module = importlib . import _ module ( &apos; . % s &apos; % flup _ module , &apos; flup &apos; )
WSGIServer = module . WSGIServer
except Exception :
print ( &quot; Can &apos;t import flup . &quot; + flup _ module )
return False
from django . core . servers . basehttp import get _ internal _ wsgi _ application
if options &#91; &quot; host &quot; &#93; and options &#91; &quot; port &quot; &#93; and not options &#91; &quot; socket &quot; &#93; :
wsgi _ opts &#91; &apos; bindAddress &apos; &#93; = ( options &#91; &quot; host &quot; &#93; , int ( options &#91; &quot; port &quot; &#93; ) )
elif options &#91; &quot; socket &quot; &#93; and not options &#91; &quot; host &quot; &#93; and not options &#91; &quot; port &quot; &#93; :
wsgi _ opts &#91; &apos; bindAddress &apos; &#93; = options &#91; &quot; socket &quot; &#93;
elif not options &#91; &quot; socket &quot; &#93; and not options &#91; &quot; host &quot; &#93; and not options &#91; &quot; port &quot; &#93; :
wsgi _ opts &#91; &apos; bindAddress &apos; &#93; = None
else :
return fastcgi _ help ( &quot; Invalid combination of host , port , socket . &quot; )
if options &#91; &quot; daemonize &quot; &#93; is None :
daemonize = ( wsgi _ opts &#91; &apos; bindAddress &apos; &#93; is not None )
else :
if options &#91; &quot; daemonize &quot; &#93; . lower ( ) in ( &apos; true &apos; , &apos; yes &apos; , &apos; t &apos; ) :
daemonize = True
elif options &#91; &quot; daemonize &quot; &#93; . lower ( ) in ( &apos; false &apos; , &apos; no &apos; , &apos; f &apos; ) :
daemonize = False
else :
return fastcgi _ help ( &quot; ERROR : invalid option for daemonize &quot; &quot; parameter . &quot; )
daemon _ kwargs = { }
if options &#91; &apos; outlog &apos; &#93; :
daemon _ kwargs &#91; &apos; out _ log &apos; &#93; = options &#91; &apos; outlog &apos; &#93;
if options &#91; &apos; errlog &apos; &#93; :
daemon _ kwargs &#91; &apos; err _ log &apos; &#93; = options &#91; &apos; errlog &apos; &#93;
if options &#91; &apos; umask &apos; &#93; :
daemon _ kwargs &#91; &apos; umask &apos; &#93; = int ( options &#91; &apos; umask &apos; &#93; , 8 )
if daemonize :
from django . utils . daemonize import become _ daemon
become _ daemon ( our _ home _ dir = options &#91; &quot; workdir &quot; &#93; , * * daemon _ kwargs )
if options &#91; &quot; pidfile &quot; &#93; :
with open ( options &#91; &quot; pidfile &quot; &#93; , &quot; w &quot; ) as fp :
fp . write ( &quot; % d \ n &quot; % os . getpid ( ) )
WSGIServer ( get _ internal _ wsgi _ application ( ) , * * wsgi _ opts ) . run ( )
if _ _ name _ _ = = &apos; _ _ main _ _ &apos; :
runfastcgi ( sys . argv &#91; 1 : &#93; )
from django . dispatch import Signal
request _ started = Signal ( )
request _ finished = Signal ( )
got _ request _ exception = Signal ( providing _ args = &#91; &quot; request &quot; &#93; )
from _ _ future _ _ import unicode _ literals
import base64
import json
import time
import zlib
from django . conf import settings
from django . utils import baseconv
from django . utils . crypto import constant _ time _ compare , salted _ hmac
from django . utils . encoding import force _ bytes , force _ str , force _ text
from django . utils . module _ loading import import _ string
class BadSignature ( Exception ) :
pass
class SignatureExpired ( BadSignature ) :
pass
def b64 _ encode ( s ) :
return base64 . urlsafe _ b64encode ( s ) . strip ( b &apos; = &apos; )
def b64 _ decode ( s ) :
pad = b &apos; = &apos; * ( - len ( s ) % 4 )
return base64 . urlsafe _ b64decode ( s + pad )
def base64 _ hmac ( salt , value , key ) :
return b64 _ encode ( salted _ hmac ( salt , value , key ) . digest ( ) )
def get _ cookie _ signer ( salt = &apos; django.core.signing.get _ cookie _ signer &apos; ) :
signer = import _ string ( settings . signing _ BACKEND )
key = force _ bytes ( settings . secret _ KEY )
return Signer ( b &apos;django.http.cookies &apos; + key , salt = salt )
class JSONSerializer ( object ) :
def dumps ( self , obj ) :
return json . dumps ( obj , separators = ( &apos; , &apos; , &apos; : &apos; ) ) . encode ( &apos; latin-1 &apos; )
def loads ( self , data ) :
return json . loads ( data . decode ( &apos; latin-1 &apos; ) )
def dumps ( obj , key = None , salt = &apos; django.core.signing &apos; , serializer = JSONSerializer , compress = False ) :
data = serializer ( ) . dumps ( obj )
is _ compressed = False
if compress :
compressed = zlib . compress ( data )
if len ( compressed ) &lt; ( len ( data ) - 1 ) :
data = compressed
is _ compressed = True
base64d = b64 _ encode ( data )
if is _ compressed :
base64d = b &apos; . &apos; + base64d
return TimestampSigner ( key , salt = salt ) . sign ( base64d )
def loads ( s , key = None , salt = &apos; django.core.signing &apos; , serializer = JSONSerializer , max _ age = None ) :
base64d = force _ bytes ( TimestampSigner ( key , salt = salt ) . unsign ( s , max _ age = max _ age ) )
decompress = False
if base64d &#91; : 1 &#93; = = b &apos; . &apos; :
base64d = base64d &#91; 1 : &#93;
decompress = True
data = b64 _ decode ( base64d )
if decompress :
data = zlib . decompress ( data )
return serializer ( ) . loads ( data )
class Signer ( object ) :
def _ _ init _ _ ( self , key = None , sep = &apos; : &apos; , salt = None ) :
self . sep = force _ str ( sep )
self . key = key or settings . secret _ KEY
self . salt = force _ str ( salt or &apos; % s . % s &apos; % ( self . _ _ class _ _ . _ _ module _ _ , self . _ _ class _ _ . _ _ name _ _ ) )
def signature ( self , value ) :
signature = base64 _ hmac ( self . salt + &apos; signer &apos; , value , self . key )
return force _ str ( signature )
def sign ( self , value ) :
value = force _ str ( value )
return str ( &apos; % s % s % s &apos; ) % ( value , self . sep , self . signature ( value ) )
def unsign ( self , signed _ value ) :
signed _ value = force _ str ( signed _ value )
if self . sep not in signed _ value :
raise BadSignature ( &apos; No &quot; % s &quot; found in value &apos; % self . sep )
value , sig = signed _ value . rsplit ( self . sep , 1 )
if constant _ time _ compare ( sig , self . signature ( value ) ) :
return force _ text ( value )
raise BadSignature ( &apos; Signature &quot; % s &quot; does not match &apos; % sig )
class TimestampSigner ( Signer ) :
def timestamp ( self ) :
return baseconv . BASE62 . encode ( int ( time . time ( ) ) )
def sign ( self , value ) :
value = force _ str ( value )
value = str ( &apos; % s % s % s &apos; ) % ( value , self . sep , self . timestamp ( ) )
return super ( TimestampSigner , self ) . sign ( value )
def unsign ( self , value , max _ age = None ) :
result = super ( TimestampSigner , self ) . unsign ( value )
value , timestamp = result . rsplit ( self . sep , 1 )
timestamp = baseconv . BASE62 . decode ( timestamp )
if max _ age is not None :
age = time . time ( ) - timestamp
if age &gt; max _ age :
raise SignatureExpired ( &apos; Signature age % s &gt; % s seconds &apos; % ( age , max _ age ) )
return value
from _ _ future _ _ import unicode _ literals
import functools
from importlib import import _ module
import re
from threading import local
import warnings
from django . http import Http404
from django . core . exceptions import ImproperlyConfigured , ViewDoesNotExist
from django . utils . datastructures import MultiValueDict
from django . utils . deprecation import RemovedInDjango20Warning
from django . utils . encoding import force _ str , force _ text , iri _ to _ uri
from django . utils . functional import lazy
from django . utils . http import urlquote
from django . utils . module _ loading import module _ has _ submodule
from django . utils . regex _ helper import normalize
from django . utils import six , lru _ cache
from django . utils . translation import get _ language
_ prefixes = local ( )
_ urlconfs = local ( )
class ResolverMatch ( object ) :
def _ _ init _ _ ( self , func , args , kwargs , url _ name = None , app _ name = None , namespaces = None ) :
self . func = func
self . args = args
self . kwargs = kwargs
self . url _ name = url _ name
self . app _ name = app _ name
if namespaces :
self . namespaces = &#91; x for x in namespaces if x &#93;
else :
self . namespaces = &#91; &#93;
self . namespace = &apos; : &apos; . join ( self . namespaces )
if not hasattr ( func , &apos; _ _ name _ _ &apos; ) :
self . _ func _ path = &apos; .&apos; . join ( &#91; func . _ _ class _ _ . _ _ module _ _ , func . _ _ class _ _ . _ _ name _ _ &#93; )
else :
self . _ func _ path = &apos; .&apos; . join ( &#91; func . _ _ module _ _ , func . _ _ name _ _ &#93; )
view _ path = url _ name or self . _ func _ path
self . view _ name = &apos; : &apos; . join ( self . namespaces + &#91; view _ path &#93; )
def _ _ getitem _ _ ( self , index ) :
return ( self . func , self . args , self . kwargs ) &#91; index &#93;
def _ _ repr _ _ ( self ) :
return &quot; ResolverMatch ( func = % s , args = % s , kwargs = % s , url _ name = % s , app _ name = % s , namespaces = % s ) &quot; % ( self . _ func _ path , self . args , self . kwargs , self . url _ name , self . app _ name , self . namespaces )
class Resolver404 ( Http404 ) :
pass
class NoReverseMatch ( Exception ) :
pass
@ lru _ cache . lru _ cache ( maxsize = None )
def get _ callable ( lookup _ view , can _ fail = False ) :
if callable ( lookup _ view ) :
return lookup _ view
mod _ name , func _ name = get _ mod _ func ( lookup _ view )
if not func _ name :
if can _ fail :
return lookup _ view
else :
raise ImportError ( &quot; Could not import &apos; % s &apos; . the path must be fully qualified . &quot; % lookup _ view )
try :
mod = import _ module ( mod _ name )
except ImportError :
if can _ fail :
return lookup _ view
else :
parentmod , submod = get _ mod _ func ( mod _ name )
if submod and not module _ has _ submodule ( import _ module ( parentmod ) , submod ) :
raise ViewDoesNotExist ( &quot; Could not import &apos; % s &apos; . parent module % s does not exist . &quot; % ( lookup _ view , mod _ name ) )
else :
raise
else :
try :
view _ func = getattr ( mod , func _ name )
except AttributeError :
if can _ fail :
return lookup _ view
else :
raise ViewDoesNotExist ( &quot; Could not import &apos; % s &apos; . view does not exist in module % s . &quot; % ( lookup _ view , mod _ name ) )
else :
if not callable ( view _ func ) :
raise ViewDoesNotExist ( &quot; Could not import &apos; % s . % s &apos; . view is not callable . &quot; % ( mod _ name , func _ name ) )
return view _ func
@ lru _ cache . lru _ cache ( maxsize = None )
def get _ resolver ( urlconf ) :
if urlconf is None :
from django . conf import settings
urlconf = settings . root _ URLCONF
return RegexURLResolver ( r &apos; ^ / &apos; , urlconf )
@ lru _ cache . lru _ cache ( maxsize = None )
def get _ ns _ resolver ( ns _ pattern , resolver ) :
ns _ resolver = RegexURLResolver ( ns _ pattern , resolver . url _ patterns )
return RegexURLResolver ( r &apos; ^ / &apos; , &#91; ns _ resolver &#93; )
def get _ mod _ func ( callback ) :
try :
dot = callback . rindex ( &apos; .&apos; )
except ValueError :
return callback , &apos; &apos;
return callback &#91; : dot &#93; , callback &#91; dot + 1 : &#93;
class LocaleRegexProvider ( object ) :
def _ _ init _ _ ( self , regex ) :
self . _ regex = regex
self . _ regex _ dict = { }
@ property
def regex ( self ) :
language _ code = get _ language ( )
if language _ code not in self . _ regex _ dict :
if isinstance ( self . _ regex , six . string _ types ) :
regex = self . _ regex
else :
regex = force _ text ( self . _ regex )
try :
compiled _ regex = re . compile ( regex , re . unicode )
except re . error as e :
raise ImproperlyConfigured ( &apos; &quot; % s &quot; is not a valid regular expression : % s &apos; % ( regex , six . text _ type ( e ) ) )
self . _ regex _ dict &#91; language _ code &#93; = compiled _ regex
return self . _ regex _ dict &#91; language _ code &#93;
class RegexURLPattern ( LocaleRegexProvider ) :
def _ _ init _ _ ( self , regex , callback , default _ args = None , name = None ) :
LocaleRegexProvider . _ _ init _ _ ( self , regex )
if callable ( callback ) :
self . _ callback = callback
else :
self . _ callback = None
self . _ callback _ str = callback
self . default _ args = default _ args or { }
self . name = name
def _ _ repr _ _ ( self ) :
return force _ str ( &apos; &lt; % s % s % s &gt; &apos; % ( self . _ _ class _ _ . _ _ name _ _ , self . name , self . regex . pattern ) )
def add _ prefix ( self , prefix ) :
if not prefix or not hasattr ( self , &apos; _ callback _ str &apos; ) :
return
self . _ callback _ str = prefix + &apos; .&apos; + self . _ callback _ str
def resolve ( self , path ) :
match = self . regex . search ( path )
if match :
kwargs = match . groupdict ( )
if kwargs :
args = ( )
else :
args = match . groups ( )
kwargs . update ( self . default _ args )
return ResolverMatch ( self . callback , args , kwargs , self . name )
@ property
def callback ( self ) :
if self . _ callback is not None :
return self . _ callback
self . _ callback = get _ callable ( self . _ callback _ str )
return self . _ callback
class RegexURLResolver ( LocaleRegexProvider ) :
def _ _ init _ _ ( self , regex , urlconf _ name , default _ kwargs = None , app _ name = None , namespace = None ) :
LocaleRegexProvider . _ _ init _ _ ( self , regex )
self . urlconf _ name = urlconf _ name
if not isinstance ( urlconf _ name , six . string _ types ) :
self . _ urlconf _ module = self . urlconf _ name
self . callback = None
self . default _ kwargs = default _ kwargs or { }
self . namespace = namespace
self . app _ name = app _ name
self . _ reverse _ dict = { }
self . _ namespace _ dict = { }
self . _ app _ dict = { }
self . _ callback _ strs = set ( )
self . _ populated = False
def _ _ repr _ _ ( self ) :
if isinstance ( self . urlconf _ name , list ) and len ( self . urlconf _ name ) :
urlconf _ repr = &apos; &lt; % s list &gt; &apos; % self . urlconf _ name &#91; 0 &#93; . _ _ class _ _ . _ _ name _ _
else :
urlconf _ repr = repr ( self . urlconf _ name )
return str ( &apos; &lt; % s % s ( % s : % s ) % s &gt; &apos; ) % ( self . _ _ class _ _ . _ _ name _ _ , urlconf _ repr , self . app _ name , self . namespace , self . regex . pattern )
def _ populate ( self ) :
lookups = MultiValueDict ( )
namespaces = { }
apps = { }
language _ code = get _ language ( )
for pattern in reversed ( self . url _ patterns ) :
if hasattr ( pattern , &apos; _ callback _ str &apos; ) :
self . _ callback _ strs . add ( pattern . _ callback _ str )
elif hasattr ( pattern , &apos; _ callback &apos; ) :
callback = pattern . _ callback
if isinstance ( callback , functools . partial ) :
callback = callback . func
if not hasattr ( callback , &apos; _ _ name _ _ &apos; ) :
lookup _ str = callback . _ _ module _ _ + &quot; . &quot; + callback . _ _ class _ _ . _ _ name _ _
else :
lookup _ str = callback . _ _ module _ _ + &quot; . &quot; + callback . _ _ name _ _
self . _ callback _ strs . add ( lookup _ str )
p _ pattern = pattern . regex . pattern
if p _ pattern . startswith ( &apos; ^ &apos; ) :
p _ pattern = p _ pattern &#91; 1 : &#93;
if isinstance ( pattern , RegexURLResolver ) :
if pattern . namespace :
namespaces &#91; pattern . namespace &#93; = ( p _ pattern , pattern )
if pattern . app _ name :
apps . setdefault ( pattern . app _ name , &#91; &#93; ) . append ( pattern . namespace )
else :
parent _ pat = pattern . regex . pattern
for name in pattern . reverse _ dict :
for matches , pat , defaults in pattern . reverse _ dict . getlist ( name ) :
new _ matches = normalize ( parent _ pat + pat )
lookups . appendlist ( name , ( new _ matches , p _ pattern + pat , dict ( defaults , * * pattern . default _ kwargs ) ) )
for namespace , ( prefix , sub _ pattern ) in pattern . namespace _ dict . items ( ) :
namespaces &#91; namespace &#93; = ( p _ pattern + prefix , sub _ pattern )
for app _ name , namespace _ list in pattern . app _ dict . items ( ) :
apps . setdefault ( app _ name , &#91; &#93; ) . extend ( namespace _ list )
self . _ callback _ strs . update ( pattern . _ callback _ strs )
else :
bits = normalize ( p _ pattern )
lookups . appendlist ( pattern . callback , ( bits , p _ pattern , pattern . default _ args ) )
if pattern . name is not None :
lookups . appendlist ( pattern . name , ( bits , p _ pattern , pattern . default _ args ) )
self . _ reverse _ dict &#91; language _ code &#93; = lookups
self . _ namespace _ dict &#91; language _ code &#93; = namespaces
self . _ app _ dict &#91; language _ code &#93; = apps
self . _ populated = True
@ property
def reverse _ dict ( self ) :
language _ code = get _ language ( )
if language _ code not in self . _ reverse _ dict :
self . _ populate ( )
return self . _ reverse _ dict &#91; language _ code &#93;
@ property
def namespace _ dict ( self ) :
language _ code = get _ language ( )
if language _ code not in self . _ namespace _ dict :
self . _ populate ( )
return self . _ namespace _ dict &#91; language _ code &#93;
@ property
def app _ dict ( self ) :
language _ code = get _ language ( )
if language _ code not in self . _ app _ dict :
self . _ populate ( )
return self . _ app _ dict &#91; language _ code &#93;
def resolve ( self , path ) :
path = force _ text ( path )
tried = &#91; &#93;
match = self . regex . search ( path )
if match :
new _ path = path &#91; match . end ( ) : &#93;
for pattern in self . url _ patterns :
try :
sub _ match = pattern . resolve ( new _ path )
except Resolver404 as e :
sub _ tried = e . args &#91; 0 &#93; . get ( &apos; tried &apos; )
if sub _ tried is not None :
tried . extend ( &#91; pattern &#93; + t for t in sub _ tried )
else :
tried . append ( &#91; pattern &#93; )
else :
if sub _ match :
sub _ match _ dict = dict ( match . groupdict ( ) , * * self . default _ kwargs )
sub _ match _ dict . update ( sub _ match . kwargs )
return ResolverMatch ( sub _ match . func , sub _ match . args , sub _ match _ dict , sub _ match . url _ name , self . app _ name or sub _ match . app _ name , &#91; self . namespace &#93; + sub _ match . namespaces )
tried . append ( &#91; pattern &#93; )
raise Resolver404 ( { &apos; tried &apos; : tried , &apos; path &apos; : new _ path } )
raise Resolver404 ( { &apos; path &apos; : path } )
@ property
def urlconf _ module ( self ) :
try :
return self . _ urlconf _ module
except AttributeError :
self . _ urlconf _ module = import _ module ( self . urlconf _ name )
return self . _ urlconf _ module
@ property
def url _ patterns ( self ) :
patterns = getattr ( self . urlconf _ module , &quot; urlpatterns &quot; , self . urlconf _ module )
try :
iter ( patterns )
except TypeError :
msg = ( &quot; The included urlconf &apos; { name } &apos; does not appear to have any &quot; &quot; patterns in it . if you see valid patterns in the file then &quot; &quot; the issue is probably caused by a circular import . &quot; )
raise ImproperlyConfigured ( msg . format ( name = self . urlconf _ name ) )
return patterns
def resolve _ error _ handler ( self , view _ type ) :
callback = getattr ( self . urlconf _ module , &apos; handler % s &apos; % view _ type , None )
if not callback :
from django . conf import urls
callback = getattr ( urls , &apos; handler % s &apos; % view _ type )
return get _ callable ( callback ) , { }
def reverse ( self , lookup _ view , * args , * * kwargs ) :
return self . _ reverse _ with _ prefix ( lookup _ view , &apos; &apos; , * args , * * kwargs )
def _ reverse _ with _ prefix ( self , lookup _ view , _ prefix , * args , * * kwargs ) :
if args and kwargs :
raise ValueError ( &quot; Don &apos;t mix * args and * * kwargs in call to reverse ( ) ! &quot; )
text _ args = &#91; force _ text ( v ) for v in args &#93;
text _ kwargs = dict ( ( k , force _ text ( v ) ) for ( k , v ) in kwargs . items ( ) )
if not self . _ populated :
self . _ populate ( )
original _ lookup = lookup _ view
try :
if lookup _ view in self . _ callback _ strs :
lookup _ view = get _ callable ( lookup _ view , True )
except ( ImportError , AttributeError ) as e :
raise NoReverseMatch ( &quot; Error importing &apos; % s &apos; : % s . &quot; % ( lookup _ view , e ) )
else :
if not callable ( original _ lookup ) and callable ( lookup _ view ) :
warnings . warn ( &apos; Reversing by dotted path is deprecated ( % s ) . &apos; % original _ lookup , RemovedInDjango20Warning , stacklevel = 3 )
possibilities = self . reverse _ dict . getlist ( lookup _ view )
prefix _ norm , prefix _ args = normalize ( urlquote ( _ prefix ) ) &#91; 0 &#93;
for possibility , pattern , defaults in possibilities :
for result , params in possibility :
if args :
if len ( args ) ! = len ( params ) + len ( prefix _ args ) :
continue
candidate _ subs = dict ( zip ( prefix _ args + params , text _ args ) )
else :
if set ( kwargs . keys ( ) ) &#124; set ( defaults . keys ( ) ) ! = set ( params ) &#124; set ( defaults . keys ( ) ) &#124; set ( prefix _ args ) :
continue
matches = True
for k , v in defaults . items ( ) :
if kwargs . get ( k , v ) ! = v :
matches = False
break
if not matches :
continue
candidate _ subs = text _ kwargs
candidate _ pat = prefix _ norm . replace ( &apos; % &apos; , &apos; % % &apos; ) + result
if re . search ( &apos; ^ % s % s &apos; % ( prefix _ norm , pattern ) , candidate _ pat % candidate _ subs , re . unicode ) :
candidate _ subs = dict ( ( k , urlquote ( v ) ) for ( k , v ) in candidate _ subs . items ( ) )
return candidate _ pat % candidate _ subs
m = getattr ( lookup _ view , &apos; _ _ module _ _ &apos; , None )
n = getattr ( lookup _ view , &apos; _ _ name _ _ &apos; , None )
if m is not None and n is not None :
lookup _ view _ s = &quot; % s . % s &quot; % ( m , n )
else :
lookup _ view _ s = lookup _ view
patterns = &#91; pattern for ( possibility , pattern , defaults ) in possibilities &#93;
raise NoReverseMatch ( &quot; Reverse for &apos; % s &apos; with arguments &apos; % s &apos; and keyword &quot; &quot; arguments &apos; % s &apos; not found . % d pattern ( s ) tried : % s &quot; % ( lookup _ view _ s , args , kwargs , len ( patterns ) , patterns ) )
class LocaleRegexURLResolver ( RegexURLResolver ) :
def _ _ init _ _ ( self , urlconf _ name , default _ kwargs = None , app _ name = None , namespace = None ) :
super ( LocaleRegexURLResolver , self ) . _ _ init _ _ ( None , urlconf _ name , default _ kwargs , app _ name , namespace )
@ property
def regex ( self ) :
language _ code = get _ language ( )
if language _ code not in self . _ regex _ dict :
regex _ compiled = re . compile ( &apos; ^ % s / &apos; % language _ code , re . unicode )
self . _ regex _ dict &#91; language _ code &#93; = regex _ compiled
return self . _ regex _ dict &#91; language _ code &#93;
def resolve ( path , urlconf = None ) :
if urlconf is None :
urlconf = get _ urlconf ( )
return get _ resolver ( urlconf ) . resolve ( path )
def reverse ( viewname , urlconf = None , args = None , kwargs = None , prefix = None , current _ app = None ) :
if urlconf is None :
urlconf = get _ urlconf ( )
resolver = get _ resolver ( urlconf )
args = args or &#91; &#93;
kwargs = kwargs or { }
if prefix is None :
prefix = get _ script _ prefix ( )
if not isinstance ( viewname , six . string _ types ) :
view = viewname
else :
parts = viewname . split ( &apos; : &apos; )
parts . reverse ( )
view = parts &#91; 0 &#93;
path = parts &#91; 1 : &#93;
resolved _ path = &#91; &#93;
ns _ pattern = &apos; &apos;
while path :
ns = path . pop ( )
try :
app _ list = resolver . app _ dict &#91; ns &#93;
if current _ app and current _ app in app _ list :
ns = current _ app
elif ns not in app _ list :
ns = app _ list &#91; 0 &#93;
except KeyError :
pass
try :
extra , resolver = resolver . namespace _ dict &#91; ns &#93;
resolved _ path . append ( ns )
ns _ pattern = ns _ pattern + extra
except KeyError as key :
if resolved _ path :
raise NoReverseMatch ( &quot; % s is not a registered namespace inside &apos; % s &apos; &quot; % ( key , &apos; : &apos; . join ( resolved _ path ) ) )
else :
raise NoReverseMatch ( &quot; % s is not a registered namespace &quot; % key )
if ns _ pattern :
resolver = get _ ns _ resolver ( ns _ pattern , resolver )
return iri _ to _ uri ( resolver . _ reverse _ with _ prefix ( view , prefix , * args , * * kwargs ) )
reverse _ lazy = lazy ( reverse , str )
def clear _ url _ caches ( ) :
get _ callable . cache _ clear ( )
get _ resolver . cache _ clear ( )
get _ ns _ resolver . cache _ clear ( )
def set _ script _ prefix ( prefix ) :
if not prefix . endswith ( &apos; / &apos; ) :
prefix + = &apos; / &apos;
_ prefixes . value = prefix
def get _ script _ prefix ( ) :
return getattr ( _ prefixes , &quot; value &quot; , &apos; / &apos; )
def clear _ script _ prefix ( ) :
try :
del _ prefixes . value
except AttributeError :
pass
def set _ urlconf ( urlconf _ name ) :
if urlconf _ name :
_ urlconfs . value = urlconf _ name
else :
if hasattr ( _ urlconfs , &quot; value &quot; ) :
del _ urlconfs . value
def get _ urlconf ( default = None ) :
return getattr ( _ urlconfs , &quot; value &quot; , default )
def is _ valid _ path ( path , urlconf = None ) :
try :
resolve ( path , urlconf )
return True
except Resolver404 :
return False
from _ _ future _ _ import unicode _ literals
import re
from django . core . exceptions import ValidationError
from django . utils . deconstruct import deconstructible
from django . utils . translation import ugettext _ lazy as _ , ungettext _ lazy
from django . utils . encoding import force _ text
from django . utils . ipv6 import is _ valid _ ipv6 _ address
from django . utils import six
from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit
empty _ VALUES = ( None , &apos; &apos; , &#91; &#93; , ( ) , { } )
@ deconstructible
class RegexValidator ( object ) :
regex = &apos; &apos;
message = _ ( &apos; Enter a valid value . &apos; )
code = &apos; invalid&apos;
inverse _ match = False
flags = 0
def _ _ init _ _ ( self , regex = None , message = None , code = None , inverse _ match = None , flags = None ) :
if regex is not None :
self . regex = regex
if message is not None :
self . message = message
if code is not None :
self . code = code
if inverse _ match is not None :
self . inverse _ match = inverse _ match
if flags is not None :
self . flags = flags
if self . flags and not isinstance ( self . regex , six . string _ types ) :
raise TypeError ( &quot; If the flags are set , regex must be a regular expression string . &quot; )
if isinstance ( self . regex , six . string _ types ) :
self . regex = re . compile ( self . regex , self . flags )
def _ _ call _ _ ( self , value ) :
if not ( self . inverse _ match is not bool ( self . regex . search ( force _ text ( value ) ) ) ) :
raise ValidationError ( self . message , code = self . code )
def _ _ eq _ _ ( self , other ) :
return ( isinstance ( other , RegexValidator ) and self . regex . pattern = = other . regex . pattern and self . regex . flags = = other . regex . flags and ( self . message = = other . message ) and ( self . code = = other . code ) and ( self . inverse _ match = = other . inverse _ match ) )
def _ _ ne _ _ ( self , other ) :
return not ( self = = other )
@ deconstructible
class URLValidator ( RegexValidator ) :
regex = re . compile ( r &apos; ^ ( ? : &#91; A-Z0-9 \ . \ - &#93; * ) : / / &apos; r &apos; ( ? : ( ? : &#91; A-Z0-9 &#93; ( ? : &#91; A-Z0-9- &#93; { 0,61 } &#91; A-Z0-9 &#93; ) ? \ . ) + ( ? : &#91; A-Z &#93; { 2,6 } \ . ? &#124; &#91; A-Z0-9- &#93; { 2 , } ( ? &lt; ! - ) \ . ? ) &#124; &apos; r &apos;localhost &#124; &apos; r &apos; \ d { 1,3 } \ . \ d { 1,3 } \ . \ d { 1,3 } \ . \ d { 1,3 } &#124; &apos; r &apos; \ &#91; ? &#91; a-f0-9 &#93; * : &#91; a-f0-9 : &#93; + \ &#93; ? ) &apos; r &apos; ( ? : : \ d + ) ? &apos; r &apos; ( ? : / ? &#124; &#91; / ? &#93; \ S + ) $ &apos; , re . IGNORECASE )
message = _ ( &apos; Enter a valid URL . &apos; )
schemes = &#91; &apos; http &apos; , &apos; https &apos; , &apos; ftp &apos; , &apos; ftps &apos; &#93;
def _ _ init _ _ ( self , schemes = None , * * kwargs ) :
super ( URLValidator , self ) . _ _ init _ _ ( * * kwargs )
if schemes is not None :
self . schemes = schemes
def _ _ call _ _ ( self , value ) :
value = force _ text ( value )
scheme = value . split ( &apos; : / / &apos; ) &#91; 0 &#93; . lower ( )
if scheme not in self . schemes :
raise ValidationError ( self . message , code = self . code )
try :
super ( URLValidator , self ) . _ _ call _ _ ( value )
except ValidationError as e :
if value :
scheme , netloc , path , query , fragment = urlsplit ( value )
try :
netloc = netloc . encode ( &apos; idna &apos; ) . decode ( &apos; ascii &apos; )
except UnicodeError :
raise e
url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
super ( URLValidator , self ) . _ _ call _ _ ( url )
else :
raise
else :
url = value
def validate _ integer ( value ) :
try :
int ( value )
except ( ValueError , TypeError ) :
raise ValidationError ( _ ( &apos; Enter a valid integer . &apos; ) , code = &apos; invalid &apos; )
@ deconstructible
class EmailValidator ( object ) :
message = _ ( &apos; Enter a valid email address . &apos; )
code = &apos; invalid&apos;
user _ regex = re . compile ( r &quot; ( ^ &#91; - ! # $ % &amp; &apos; * + / = ? ^ _ ` { } &#124; ~ 0-9A-Z &#93; + ( \ . &#91; - ! # $ % &amp; &apos; * + / = ? ^ _ ` { } &#124; ~ 0-9A-Z &#93; + ) * $ &quot; r &apos; &#124; ^ &quot; ( &#91; \ 001- \ 010 \ 013 \ 014 \ 016- \ 037 ! # - \ &#91; \ &#93; - \ 177 &#93; &#124; \ \ &#91; \ 001- \ 011 \ 013 \ 014 \ 016- \ 177 &#93; ) * &quot; $ ) &apos; , re . IGNORECASE )
domain _ regex = re . compile ( r &apos; ( ? : &#91; A-Z0-9 &#93; ( ? : &#91; A-Z0-9- &#93; { 0,247 } &#91; A-Z0-9 &#93; ) ? \ . ) + ( ? : &#91; A-Z &#93; { 2,6 } &#124; &#91; A-Z0-9- &#93; { 2 , } ( ? &lt; ! - ) ) $ &apos; , re . IGNORECASE )
literal _ regex = re . compile ( r &apos; \ &#91; ( &#91; A-f0-9 : \ . &#93; + ) \ &#93; $ &apos; , re . IGNORECASE )
domain _ whitelist = &#91; &apos; localhost &apos; &#93;
def _ _ init _ _ ( self , message = None , code = None , whitelist = None ) :
if message is not None :
self . message = message
if code is not None :
self . code = code
if whitelist is not None :
self . domain _ whitelist = whitelist
def _ _ call _ _ ( self , value ) :
value = force _ text ( value )
if not value or &apos; @ &apos; not in value :
raise ValidationError ( self . message , code = self . code )
user _ part , domain _ part = value . rsplit ( &apos; @ &apos; , 1 )
if not self . user _ regex . match ( user _ part ) :
raise ValidationError ( self . message , code = self . code )
if ( domain _ part not in self . domain _ whitelist and not self . validate _ domain _ part ( domain _ part ) ) :
try :
domain _ part = domain _ part . encode ( &apos; idna &apos; ) . decode ( &apos; ascii &apos; )
if self . validate _ domain _ part ( domain _ part ) :
return
except UnicodeError :
pass
raise ValidationError ( self . message , code = self . code )
def validate _ domain _ part ( self , domain _ part ) :
if self . domain _ regex . match ( domain _ part ) :
return True
literal _ match = self . literal _ regex . match ( domain _ part )
if literal _ match :
ip _ address = literal _ match . Group ( 1 )
try :
validate _ ipv46 _ address ( ip _ address )
return True
except ValidationError :
pass
return False
def _ _ eq _ _ ( self , other ) :
return isinstance ( other , EmailValidator ) and ( self . domain _ whitelist = = other . domain _ whitelist ) and ( self . message = = other . message ) and ( self . code = = other . code )
validate _ email = EmailValidator ( )
slug _ re = re . compile ( r &apos; ^ &#91; -a-zA-Z0-9 _ &#93; + $ &apos; )
validate _ slug = RegexValidator ( slug _ re , _ ( &quot; Enter a valid &apos; slug &apos; consisting of letters , numbers , underscores or hyphens . &quot; ) , &apos; invalid &apos; )
ipv4 _ re = re . compile ( r &apos; ^ ( 25 &#91; 0-5 &#93; &#124; 2 &#91; 0-4 &#93; \ d &#124; &#91; 0-1 &#93; ? \ d ? \ d ) ( \ . ( 25 &#91; 0-5 &#93; &#124; 2 &#91; 0-4 &#93; \ d &#124; &#91; 0-1 &#93; ? \ d ? \ d ) ) { 3 } $ &apos; )
validate _ ipv4 _ address = RegexValidator ( ipv4 _ re , _ ( &apos; Enter a valid IPv4 address . &apos; ) , &apos; invalid &apos; )
def validate _ ipv6 _ address ( value ) :
if not is _ valid _ ipv6 _ address ( value ) :
raise ValidationError ( _ ( &apos; Enter a valid IPv6 address . &apos; ) , code = &apos; invalid &apos; )
def validate _ ipv46 _ address ( value ) :
try :
validate _ ipv4 _ address ( value )
except ValidationError :
try :
validate _ ipv6 _ address ( value )
except ValidationError :
raise ValidationError ( _ ( &apos; Enter a valid IPv4 or IPv6 address . &apos; ) , code = &apos; invalid &apos; )
ip _ address _ validator _ map = { &apos; both &apos; : ( &#91; validate _ ipv46 _ address &#93; , _ ( &apos; Enter a valid IPv4 or IPv6 address . &apos; ) ) , &apos; ipv4 &apos; : ( &#91; validate _ ipv4 _ address &#93; , _ ( &apos; Enter a valid IPv4 address . &apos; ) ) , &apos; ipv6 &apos; : ( &#91; validate _ ipv6 _ address &#93; , _ ( &apos; Enter a valid IPv6 address . &apos; ) ) , }
def ip _ address _ validators ( protocol , unpack _ ipv4 ) :
if protocol ! = &apos; both &apos; and unpack _ ipv4 :
raise ValueError ( &quot; You can only use `unpack _ ipv4` if `protocol` is set to &apos; both &apos; &quot; )
try :
return ip _ address _ validator _ map &#91; protocol . lower ( ) &#93;
except KeyError :
raise ValueError ( &quot; The protocol &apos; % s &apos; is unknown . supported : % s &quot; % ( protocol , list ( ip _ address _ validator _ map ) ) )
comma _ separated _ int _ list _ re = re . compile ( &apos; ^ &#91; \ d , &#93; + $ &apos; )
validate _ comma _ separated _ integer _ list = RegexValidator ( comma _ separated _ int _ list _ re , _ ( &apos; Enter only digits separated by commas . &apos; ) , &apos; invalid &apos; )
@ deconstructible
class BaseValidator ( object ) :
compare = lambda self , a , b : a is not b
clean = lambda self , x : x
message = _ ( &apos; Ensure this value is % ( limit _ value ) s ( it is % ( show _ value ) s ) . &apos; )
code = &apos; limit _ value&apos;
def _ _ init _ _ ( self , limit _ value ) :
self . limit _ value = limit _ value
def _ _ call _ _ ( self , value ) :
cleaned = self . clean ( value )
params = { &apos; limit _ value &apos; : self . limit _ value , &apos; show _ value &apos; : cleaned }
if self . compare ( cleaned , self . limit _ value ) :
raise ValidationError ( self . message , code = self . code , params = params )
def _ _ eq _ _ ( self , other ) :
return isinstance ( other , self . _ _ class _ _ ) and ( self . limit _ value = = other . limit _ value ) and ( self . message = = other . message ) and ( self . code = = other . code )
@ deconstructible
class MaxValueValidator ( BaseValidator ) :
compare = lambda self , a , b : a &gt; b
message = _ ( &apos; Ensure this value is less than or equal to % ( limit _ value ) s . &apos; )
code = &apos; max _ value&apos;
@ deconstructible
class MinValueValidator ( BaseValidator ) :
compare = lambda self , a , b : a &lt; b
message = _ ( &apos; Ensure this value is greater than or equal to % ( limit _ value ) s . &apos; )
code = &apos; min _ value&apos;
@ deconstructible
class MinLengthValidator ( BaseValidator ) :
compare = lambda self , a , b : a &lt; b
clean = lambda self , x : len ( x )
message = ungettext _ lazy ( &apos; Ensure this value has at least % ( limit _ value ) d character ( it has % ( show _ value ) d ) . &apos; , &apos; Ensure this value has at least % ( limit _ value ) d characters ( it has % ( show _ value ) d ) . &apos; , &apos; limit _ value &apos; )
code = &apos; min _ length&apos;
@ deconstructible
class MaxLengthValidator ( BaseValidator ) :
compare = lambda self , a , b : a &gt; b
clean = lambda self , x : len ( x )
message = ungettext _ lazy ( &apos; Ensure this value has at most % ( limit _ value ) d character ( it has % ( show _ value ) d ) . &apos; , &apos; Ensure this value has at most % ( limit _ value ) d characters ( it has % ( show _ value ) d ) . &apos; , &apos; limit _ value &apos; )
code = &apos; max _ length&apos;
import django
from django . core . handlers . wsgi import WSGIHandler
def get _ wsgi _ application ( ) :
Django . setup ( )
return WSGIHandler ( )
from django . core . exceptions import ValidationError
from django . forms . fields import *
from django . forms . forms import *
from django . forms . formsets import *
from django . forms . models import *
from django . forms . widgets import *
from django . forms . extras . widgets import SelectDateWidget
_ _ all _ _ = &#91; &apos; SelectDateWidget &apos; &#93;
from _ _ future _ _ import unicode _ literals
import datetime
import re
from django . forms . widgets import Widget , Select
from django . utils import datetime _ safe
from django . utils . dates import MONTHS
from django . utils . encoding import force _ str
from django . utils . SafeString import mark _ safe
from django . utils . formats import get _ format
from django . utils import six
from django . conf import settings
_ _ all _ _ = ( &apos; SelectDateWidget &apos; , )
re _ DATE = re . compile ( r &apos; ( \ d { 4 } ) - ( \ d \ d ? ) - ( \ d \ d ? ) $ &apos; )
def _ parse _ date _ fmt ( ) :
fmt = get _ format ( &apos; DATE _ FORMAT &apos; )
escaped = False
for char in fmt :
if escaped :
escaped = False
elif char = = &apos; \ \ &apos; :
escaped = True
elif char in &apos; Yy &apos; :
yield &apos; year&apos;
elif char in &apos; bEFMmNn &apos; :
yield &apos; month&apos;
elif char in &apos; dj &apos; :
yield &apos; day&apos;
class SelectDateWidget ( Widget ) :
None _ value = ( 0 , &apos; --- &apos; )
month _ field = &apos; % s _ month&apos;
day _ field = &apos; % s _ day&apos;
year _ field = &apos; % s _ year&apos;
def _ _ init _ _ ( self , attrs = None , years = None , months = None , empty _ label = None ) :
self . attrs = attrs or { }
if years :
self . years = years
else :
this _ year = datetime . date . today ( ) . year
self . years = range ( this _ year , this _ year + 10 )
if months :
self . MONTHS = months
else :
self . MONTHS = MONTHS
if isinstance ( empty _ label , ( list , tuple ) ) :
if not len ( empty _ label ) = = 3 :
raise ValueError ( &apos; empty _ label list / tuple must have 3 elements . &apos; )
self . year _ none _ value = ( 0 , empty _ label &#91; 0 &#93; )
self . month _ none _ value = ( 0 , empty _ label &#91; 1 &#93; )
self . day _ none _ value = ( 0 , empty _ label &#91; 2 &#93; )
else :
if empty _ label is not None :
self . None _ value = ( 0 , empty _ label )
self . year _ none _ value = self . None _ value
self . month _ none _ value = self . None _ value
self . day _ none _ value = self . None _ value
def render ( self , name , value , attrs = None ) :
try :
year _ val , month _ val , day _ val = value . year , value . month , value . day
except AttributeError :
year _ val = month _ val = day _ val = None
if isinstance ( value , six . string _ types ) :
if settings . use _ L10N :
try :
input _ format = get _ format ( &apos; DATE _ INPUT _ FORMATS &apos; ) &#91; 0 &#93;
v = datetime . datetime . strptime ( force _ str ( value ) , input _ format )
year _ val , month _ val , day _ val = v . year , v . month , v . day
except ValueError :
pass
else :
match = RE _ DATE . match ( value )
if match :
year _ val , month _ val , day _ val = &#91; int ( v ) for v in match . groups ( ) &#93;
html = { }
choices = &#91; ( i , i ) for i in self . years &#93;
html &#91; &apos; year &apos; &#93; = self . create _ select ( name , self . year _ field , value , year _ val , choices , self . year _ none _ value )
choices = list ( six . iteritems ( self . MONTHS ) )
html &#91; &apos; month &apos; &#93; = self . create _ select ( name , self . month _ field , value , month _ val , choices , self . month _ none _ value )
choices = &#91; ( i , i ) for i in range ( 1 , 32 ) &#93;
html &#91; &apos; day &apos; &#93; = self . create _ select ( name , self . day _ field , value , day _ val , choices , self . day _ none _ value )
output = &#91; &#93;
for field in _ parse _ date _ fmt ( ) :
output . append ( html &#91; field &#93; )
return mark _ safe ( &apos; \ n &apos; . join ( output ) )
def id _ for _ label ( self , id _ ) :
for first _ select in _ parse _ date _ fmt ( ) :
return &apos; % s _ % s &apos; % ( id _ , first _ select )
else :
return &apos; % s _ month &apos; % id _
def value _ from _ datadict ( self , data , files , name ) :
y = data . get ( self . year _ field % name )
m = data . get ( self . month _ field % name )
d = data . get ( self . day _ field % name )
if y = = m = = d = = &quot; 0 &quot; :
return None
if y and m and d :
if settings . use _ L10N :
input _ format = get _ format ( &apos; DATE _ INPUT _ FORMATS &apos; ) &#91; 0 &#93;
try :
date _ value = datetime . date ( int ( y ) , int ( m ) , int ( d ) )
except ValueError :
return &apos; % s- % s- % s &apos; % ( y , m , d )
else :
date _ value = datetime _ safe . new _ date ( date _ value )
return date _ value . strftime ( input _ format )
else :
return &apos; % s- % s- % s &apos; % ( y , m , d )
return data . get ( name , None )
def create _ select ( self , name , field , value , val , choices , none _ value ) :
if &apos; id &apos; in self . attrs :
id _ = self . attrs &#91; &apos; id &apos; &#93;
else :
id _ = &apos; id _ % s &apos; % name
if not self . is _ required :
choices . insert ( 0 , none _ value )
local _ attrs = self . build _ attrs ( id = field % id _ )
s = Select ( choices = choices )
select _ html = s . render ( field % name , val , local _ attrs )
return select _ html
from _ _ future _ _ import unicode _ literals
import copy
import datetime
import os
import re
import sys
import warnings
from decimal import Decimal , DecimalException
from io import BytesIO
from django . core import validators
from django . core . exceptions import ValidationError
from django . forms . utils import from _ current _ timezone , to _ current _ timezone
from django . forms . widgets import ( TextInput , NumberInput , EmailInput , URLInput , HiddenInput , MultipleHiddenInput , ClearableFileInput , CheckboxInput , Select , NullBooleanSelect , SelectMultiple , DateInput , DateTimeInput , TimeInput , SplitDateTimeWidget , SplitHiddenDateTimeWidget , FILE _ INPUT _ CONTRADICTION )
from django . utils import formats
from django . utils . encoding import smart _ text , force _ str , force _ text
from django . utils . ipv6 import clean _ ipv6 _ address
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils import six
from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit
from django . utils . translation import ugettext _ lazy as _ , ungettext _ lazy
from django . core . validators import EMPTY _ VALUES
_ _ all _ _ = ( &apos; Field &apos; , &apos; CharField &apos; , &apos; IntegerField &apos; , &apos; DateField &apos; , &apos; TimeField &apos; , &apos; DateTimeField &apos; , &apos; RegexField &apos; , &apos; EmailField &apos; , &apos; FileField &apos; , &apos; ImageField &apos; , &apos; URLField &apos; , &apos; BooleanField &apos; , &apos; NullBooleanField &apos; , &apos; ChoiceField &apos; , &apos; MultipleChoiceField &apos; , &apos; ComboField &apos; , &apos; MultiValueField &apos; , &apos; FloatField &apos; , &apos; DecimalField &apos; , &apos; SplitDateTimeField &apos; , &apos; IPAddressField &apos; , &apos; GenericIPAddressField &apos; , &apos; FilePathField &apos; , &apos; SlugField &apos; , &apos; TypedChoiceField &apos; , &apos; TypedMultipleChoiceField &apos; )
class Field ( object ) :
widget = TextInput
hidden _ widget = HiddenInput
default _ validators = &#91; &#93;
default _ error _ messages = { &apos; required &apos; : _ ( &apos; This field is required . &apos; ) , }
empty _ values = list ( validators . empty _ VALUES )
creation _ counter = 0
def _ _ init _ _ ( self , required = True , widget = None , label = None , initial = None , help _ text = &apos; &apos; , error _ messages = None , show _ hidden _ initial = False , validators = &#91; &#93; , localize = False , label _ suffix = None ) :
self . required , self . label , self . initial = required , label , initial
self . show _ hidden _ initial = show _ hidden _ initial
self . help _ text = help _ text
self . label _ suffix = label _ suffix
widget = widget or self . widget
if isinstance ( widget , type ) :
widget = widget ( )
self . localize = localize
if self . localize :
widget . is _ localized = True
widget . is _ required = self . required
extra _ attrs = self . widget _ attrs ( widget )
if extra _ attrs :
widget . attrs . update ( extra _ attrs )
self . widget = widget
self . creation _ counter = Field . creation _ counter
field . creation _ counter + = 1
messages = { }
for c in reversed ( self . _ _ class _ _ . _ _ mro _ _ ) :
messages . update ( getattr ( c , &apos; default _ error _ messages &apos; , { } ) )
messages . update ( error _ messages or { } )
self . error _ messages = messages
self . validators = self . default _ validators + validators
super ( Field , self ) . _ _ init _ _ ( )
def prepare _ value ( self , value ) :
return value
def to _ python ( self , value ) :
return value
def validate ( self , value ) :
if value in self . empty _ values and self . required :
raise ValidationError ( self . error _ messages &#91; &apos; required &apos; &#93; , code = &apos; required &apos; )
def run _ validators ( self , value ) :
if value in self . empty _ values :
return
errors = &#91; &#93;
for v in self . validators :
try :
v ( value )
except ValidationError as e :
if hasattr ( e , &apos; code &apos; ) and e . code in self . error _ messages :
e . message = self . error _ messages &#91; e . code &#93;
errors . extend ( e . error _ list )
if errors :
raise ValidationError ( errors )
def clean ( self , value ) :
value = self . to _ python ( value )
self . validate ( value )
self . run _ validators ( value )
return value
def bound _ data ( self , data , initial ) :
return data
def widget _ attrs ( self , widget ) :
return { }
def get _ limit _ choices _ to ( self ) :
if callable ( self . limit _ choices _ to ) :
return self . limit _ choices _ to ( )
return self . limit _ choices _ to
def _ has _ changed ( self , initial , data ) :
initial _ value = initial if initial is not None else &apos; &apos;
try :
data = self . to _ python ( data )
if hasattr ( self , &apos; _ coerce &apos; ) :
data = self . _ coerce ( data )
except ValidationError :
return True
data _ value = data if data is not None else &apos; &apos;
return initial _ value ! = data _ value
def _ _ deepcopy _ _ ( self , memo ) :
result = copy . copy ( self )
memo &#91; id ( self ) &#93; = result
result . widget = copy . deepcopy ( self . widget , memo )
result . validators = self . validators &#91; : &#93;
return result
class CharField ( Field ) :
def _ _ init _ _ ( self , max _ length = None , min _ length = None , * args , * * kwargs ) :
self . max _ length , self . min _ length = max _ length , min _ length
super ( CharField , self ) . _ _ init _ _ ( * args , * * kwargs )
if min _ length is not None :
self . validators . append ( validators . MinLengthValidator ( int ( min _ length ) ) )
if max _ length is not None :
self . validators . append ( validators . MaxLengthValidator ( int ( max _ length ) ) )
def to _ python ( self , value ) :
if value in self . empty _ values :
return &apos; &apos;
return smart _ text ( value )
def widget _ attrs ( self , widget ) :
attrs = super ( CharField , self ) . widget _ attrs ( widget )
if self . max _ length is not None :
attrs . update ( { &apos; maxlength &apos; : str ( self . max _ length ) } )
return attrs
class IntegerField ( Field ) :
widget = NumberInput
default _ error _ messages = { &apos; invalid &apos; : _ ( &apos; Enter a whole number . &apos; ) , }
def _ _ init _ _ ( self , max _ value = None , min _ value = None , * args , * * kwargs ) :
self . max _ value , self . min _ value = max _ value , min _ value
if kwargs . get ( &apos; localize &apos; ) and self . widget = = NumberInput :
kwargs . setdefault ( &apos; widget &apos; , super ( IntegerField , self ) . widget )
super ( IntegerField , self ) . _ _ init _ _ ( * args , * * kwargs )
if max _ value is not None :
self . validators . append ( validators . MaxValueValidator ( max _ value ) )
if min _ value is not None :
self . validators . append ( validators . MinValueValidator ( min _ value ) )
def to _ python ( self , value ) :
value = super ( IntegerField , self ) . to _ python ( value )
if value in self . empty _ values :
return None
if self . localize :
value = formats . sanitize _ separators ( value )
try :
value = int ( str ( value ) )
except ( ValueError , TypeError ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
return value
def widget _ attrs ( self , widget ) :
attrs = super ( IntegerField , self ) . widget _ attrs ( widget )
if isinstance ( widget , NumberInput ) :
if self . min _ value is not None :
attrs &#91; &apos; min &apos; &#93; = self . min _ value
if self . max _ value is not None :
attrs &#91; &apos; max &apos; &#93; = self . max _ value
return attrs
class FloatField ( IntegerField ) :
default _ error _ messages = { &apos; invalid &apos; : _ ( &apos; Enter a number . &apos; ) , }
def to _ python ( self , value ) :
value = super ( IntegerField , self ) . to _ python ( value )
if value in self . empty _ values :
return None
if self . localize :
value = formats . sanitize _ separators ( value )
try :
value = float ( value )
except ( ValueError , TypeError ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
return value
def validate ( self , value ) :
super ( FloatField , self ) . validate ( value )
if value ! = value or value in ( Decimal ( &apos; Inf &apos; ) , Decimal ( &apos; -Inf &apos; ) ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
return value
def widget _ attrs ( self , widget ) :
attrs = super ( FloatField , self ) . widget _ attrs ( widget )
if isinstance ( widget , NumberInput ) and &apos; step &apos; not in widget . attrs :
attrs . setdefault ( &apos; step &apos; , &apos; any &apos; )
return attrs
class DecimalField ( IntegerField ) :
default _ error _ messages = { &apos; invalid &apos; : _ ( &apos; Enter a number . &apos; ) , &apos; max _ digits &apos; : ungettext _ lazy ( &apos; Ensure that there are no more than % ( max ) s digit in total . &apos; , &apos; Ensure that there are no more than % ( max ) s digits in total . &apos; , &apos; max &apos; ) , &apos; max _ decimal _ places &apos; : ungettext _ lazy ( &apos; Ensure that there are no more than % ( max ) s decimal place . &apos; , &apos; Ensure that there are no more than % ( max ) s decimal places . &apos; , &apos; max &apos; ) , &apos; max _ whole _ digits &apos; : ungettext _ lazy ( &apos; Ensure that there are no more than % ( max ) s digit before the decimal point . &apos; , &apos; Ensure that there are no more than % ( max ) s digits before the decimal point . &apos; , &apos; max &apos; ) , }
def _ _ init _ _ ( self , max _ value = None , min _ value = None , max _ digits = None , decimal _ places = None , * args , * * kwargs ) :
self . max _ digits , self . decimal _ places = max _ digits , decimal _ places
super ( DecimalField , self ) . _ _ init _ _ ( max _ value , min _ value , * args , * * kwargs )
def to _ python ( self , value ) :
if value in self . empty _ values :
return None
if self . localize :
value = formats . sanitize _ separators ( value )
value = smart _ text ( value ) . strip ( )
try :
value = Decimal ( value )
except DecimalException :
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
return value
def validate ( self , value ) :
super ( DecimalField , self ) . validate ( value )
if value in self . empty _ values :
return
if value ! = value or value = = Decimal ( &quot; Inf &quot; ) or value = = Decimal ( &quot; -Inf &quot; ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
sign , digittuple , exponent = value . as _ tuple ( )
decimals = abs ( exponent )
digits = len ( digittuple )
if decimals &gt; digits :
digits = decimals
whole _ digits = digits - decimals
if self . max _ digits is not None and digits &gt; self . max _ digits :
raise ValidationError ( self . error _ messages &#91; &apos; max _ digits &apos; &#93; , code = &apos; max _ digits &apos; , params = { &apos; max &apos; : self . max _ digits } , )
if self . decimal _ places is not None and decimals &gt; self . decimal _ places :
raise ValidationError ( self . error _ messages &#91; &apos; max _ decimal _ places &apos; &#93; , code = &apos; max _ decimal _ places &apos; , params = { &apos; max &apos; : self . decimal _ places } , )
if ( self . max _ digits is not None and self . decimal _ places is not None and whole _ digits &gt; ( self . max _ digits - self . decimal _ places ) ) :
raise ValidationError ( self . error _ messages &#91; &apos; max _ whole _ digits &apos; &#93; , code = &apos; max _ whole _ digits &apos; , params = { &apos; max &apos; : ( self . max _ digits - self . decimal _ places ) } , )
return value
def widget _ attrs ( self , widget ) :
attrs = super ( DecimalField , self ) . widget _ attrs ( widget )
if isinstance ( widget , NumberInput ) and &apos; step &apos; not in widget . attrs :
if self . decimal _ places is not None :
step = str ( Decimal ( &apos; 1&apos; ) / 10 * * self . decimal _ places ) . lower ( )
else :
step = &apos; any&apos;
attrs . setdefault ( &apos; step &apos; , step )
return attrs
class BaseTemporalField ( Field ) :
def _ _ init _ _ ( self , input _ formats = None , * args , * * kwargs ) :
super ( BaseTemporalField , self ) . _ _ init _ _ ( * args , * * kwargs )
if input _ formats is not None :
self . input _ formats = input _ formats
def to _ python ( self , value ) :
unicode _ value = force _ text ( value , strings _ only = True )
if isinstance ( unicode _ value , six . text _ type ) :
value = unicode _ value . strip ( )
if isinstance ( value , six . text _ type ) :
for format in self . input _ formats :
try :
return self . strptime ( value , format )
except ( ValueError , TypeError ) :
continue
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
def strptime ( self , value , format ) :
raise NotImplementedError ( &apos; Subclasses must define this method . &apos; )
class DateField ( BaseTemporalField ) :
widget = DateInput
input _ formats = formats . get _ format _ lazy ( &apos; DATE _ INPUT _ FORMATS &apos; )
default _ error _ messages = { &apos; invalid &apos; : _ ( &apos; Enter a valid date . &apos; ) , }
def to _ python ( self , value ) :
if value in self . empty _ values :
return None
if isinstance ( value , datetime . datetime ) :
return value . date ( )
if isinstance ( value , datetime . date ) :
return value
return super ( DateField , self ) . to _ python ( value )
def strptime ( self , value , format ) :
return datetime . datetime . strptime ( force _ str ( value ) , format ) . date ( )
class TimeField ( BaseTemporalField ) :
widget = TimeInput
input _ formats = formats . get _ format _ lazy ( &apos; TIME _ INPUT _ FORMATS &apos; )
default _ error _ messages = { &apos; invalid &apos; : _ ( &apos; Enter a valid time . &apos; ) }
def to _ python ( self , value ) :
if value in self . empty _ values :
return None
if isinstance ( value , datetime . time ) :
return value
return super ( TimeField , self ) . to _ python ( value )
def strptime ( self , value , format ) :
return datetime . datetime . strptime ( force _ str ( value ) , format ) . time ( )
class DateTimeField ( BaseTemporalField ) :
widget = DateTimeInput
input _ formats = formats . get _ format _ lazy ( &apos; DATETIME _ INPUT _ FORMATS &apos; )
default _ error _ messages = { &apos; invalid &apos; : _ ( &apos; Enter a valid date / time . &apos; ) , }
def prepare _ value ( self , value ) :
if isinstance ( value , datetime . datetime ) :
value = to _ current _ timezone ( value )
return value
def to _ python ( self , value ) :
if value in self . empty _ values :
return None
if isinstance ( value , datetime . datetime ) :
return from _ current _ timezone ( value )
if isinstance ( value , datetime . date ) :
result = datetime . datetime ( value . year , value . month , value . day )
return from _ current _ timezone ( result )
if isinstance ( value , list ) :
warnings . warn ( &apos; Using SplitDateTimeWidget with DateTimeField is deprecated . &apos; &apos; use SplitDateTimeField instead . &apos; , RemovedInDjango19Warning , stacklevel = 2 )
if len ( value ) ! = 2 :
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
if value &#91; 0 &#93; in self . empty _ values and value &#91; 1 &#93; in self . empty _ values :
return None
value = &apos; % s % s &apos; % tuple ( value )
result = super ( DateTimeField , self ) . to _ python ( value )
return from _ current _ timezone ( result )
def strptime ( self , value , format ) :
return datetime . datetime . strptime ( force _ str ( value ) , format )
class RegexField ( CharField ) :
def _ _ init _ _ ( self , regex , max _ length = None , min _ length = None , error _ message = None , * args , * * kwargs ) :
if error _ message is not None :
error _ messages = kwargs . get ( &apos; error _ messages &apos; ) or { }
error _ messages &#91; &apos; invalid &apos; &#93; = error _ message
kwargs &#91; &apos; error _ messages &apos; &#93; = error _ messages
super ( RegexField , self ) . _ _ init _ _ ( max _ length , min _ length , * args , * * kwargs )
self . _ set _ regex ( regex )
def _ get _ regex ( self ) :
return self . _ regex
def _ set _ regex ( self , regex ) :
if isinstance ( regex , six . string _ types ) :
regex = re . compile ( regex , re . unicode )
self . _ regex = regex
if hasattr ( self , &apos; _ regex _ validator &apos; ) and self . _ regex _ validator in self . validators :
self . validators . remove ( self . _ regex _ validator )
self . _ regex _ validator = validators . RegexValidator ( regex = regex )
self . validators . append ( self . _ regex _ validator )
regex = property ( _ get _ regex , _ set _ regex )
class EmailField ( CharField ) :
widget = EmailInput
default _ validators = &#91; validators . validate _ email &#93;
def clean ( self , value ) :
value = self . to _ python ( value ) . strip ( )
return super ( EmailField , self ) . clean ( value )
class FileField ( Field ) :
widget = ClearableFileInput
default _ error _ messages = { &apos; invalid &apos; : _ ( &quot; No file was submitted . check the encoding type on the form . &quot; ) , &apos; missing &apos; : _ ( &quot; No file was submitted . &quot; ) , &apos; empty &apos; : _ ( &quot; The submitted file is empty . &quot; ) , &apos; max _ length &apos; : ungettext _ lazy ( &apos; Ensure this filename has at most % ( max ) d character ( it has % ( length ) d ) . &apos; , &apos; Ensure this filename has at most % ( max ) d characters ( it has % ( length ) d ) . &apos; , &apos; max &apos; ) , &apos; contradiction &apos; : _ ( &apos; Please either submit a file or check the clear checkbox , not both . &apos; ) }
def _ _ init _ _ ( self , * args , * * kwargs ) :
self . max _ length = kwargs . pop ( &apos; max _ length &apos; , None )
self . allow _ empty _ file = kwargs . pop ( &apos; allow _ empty _ file &apos; , False )
super ( FileField , self ) . _ _ init _ _ ( * args , * * kwargs )
def to _ python ( self , data ) :
if data in self . empty _ values :
return None
try :
file _ name = data . name
file _ size = data . size
except AttributeError :
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
if self . max _ length is not None and len ( file _ name ) &gt; self . max _ length :
params = { &apos; max &apos; : self . max _ length , &apos; length &apos; : len ( file _ name ) }
raise ValidationError ( self . error _ messages &#91; &apos; max _ length &apos; &#93; , code = &apos; max _ length &apos; , params = params )
if not file _ name :
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
if not self . allow _ empty _ file and not file _ size :
raise ValidationError ( self . error _ messages &#91; &apos; empty &apos; &#93; , code = &apos; empty &apos; )
return data
def clean ( self , data , initial = None ) :
if data is FILE _ INPUT _ CONTRADICTION :
raise ValidationError ( self . error _ messages &#91; &apos; contradiction &apos; &#93; , code = &apos; contradiction &apos; )
if data is False :
if not self . required :
return False
data = None
if not data and initial :
return initial
return super ( FileField , self ) . clean ( data )
def bound _ data ( self , data , initial ) :
if data in ( None , FILE _ INPUT _ CONTRADICTION ) :
return initial
return data
def _ has _ changed ( self , initial , data ) :
if data is None :
return False
return True
class ImageField ( FileField ) :
default _ error _ messages = { &apos; invalid _ image &apos; : _ ( &quot; upload a valid image . the file you uploaded was either not an image or a corrupted image . &quot; ) , }
def to _ python ( self , data ) :
f = super ( ImageField , self ) . to _ python ( data )
if f is None :
return None
from PIL import Image
if hasattr ( data , &apos; temporary _ file _ path &apos; ) :
file = data . temporary _ file _ path ( )
else :
if hasattr ( data , &apos; read &apos; ) :
file = BytesIO ( data . read ( ) )
else :
file = BytesIO ( data &#91; &apos; content &apos; &#93; )
try :
image . open ( file ) . verify ( )
except Exception :
six . reraise ( ValidationError , ValidationError ( self . error _ messages &#91; &apos; invalid _ image &apos; &#93; , code = &apos; invalid _ image &apos; , ) , sys . exc _ info ( ) &#91; 2 &#93; )
if hasattr ( f , &apos; seek &apos; ) and callable ( f . seek ) :
f . seek ( 0 )
return f
class URLField ( CharField ) :
widget = URLInput
default _ error _ messages = { &apos; invalid &apos; : _ ( &apos; Enter a valid URL . &apos; ) , }
default _ validators = &#91; validators . URLValidator ( ) &#93;
def to _ python ( self , value ) :
def split _ url ( url ) :
try :
return list ( urlsplit ( url ) )
except ValueError :
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
value = super ( URLField , self ) . to _ python ( value )
if value :
url _ fields = split _ url ( value )
if not url _ fields &#91; 0 &#93; :
url _ fields &#91; 0 &#93; = &apos; http&apos;
if not url _ fields &#91; 1 &#93; :
url _ fields &#91; 1 &#93; = url _ fields &#91; 2 &#93;
url _ fields &#91; 2 &#93; = &apos; &apos;
url _ fields = split _ url ( urlunsplit ( url _ fields ) )
value = urlunsplit ( url _ fields )
return value
def clean ( self , value ) :
value = self . to _ python ( value ) . strip ( )
return super ( URLField , self ) . clean ( value )
class BooleanField ( Field ) :
widget = CheckboxInput
def to _ python ( self , value ) :
if isinstance ( value , six . string _ types ) and value . lower ( ) in ( &apos; false &apos; , &apos; 0&apos; ) :
value = False
else :
value = bool ( value )
return super ( BooleanField , self ) . to _ python ( value )
def validate ( self , value ) :
if not value and self . required :
raise ValidationError ( self . error _ messages &#91; &apos; required &apos; &#93; , code = &apos; required &apos; )
def _ has _ changed ( self , initial , data ) :
if initial = = &apos; False &apos; :
initial = False
return bool ( initial ) ! = bool ( data )
class NullBooleanField ( BooleanField ) :
widget = NullBooleanSelect
def to _ python ( self , value ) :
if value in ( True , &apos; True &apos; , &apos; 1&apos; ) :
return True
elif value in ( False , &apos; False &apos; , &apos; 0&apos; ) :
return False
else :
return None
def validate ( self , value ) :
pass
def _ has _ changed ( self , initial , data ) :
if initial is not None :
initial = bool ( initial )
if data is not None :
data = bool ( data )
return initial ! = data
class ChoiceField ( Field ) :
widget = Select
default _ error _ messages = { &apos; invalid _ choice &apos; : _ ( &apos; Select a valid choice . % ( value ) s is not one of the available choices . &apos; ) , }
def _ _ init _ _ ( self , choices = ( ) , required = True , widget = None , label = None , initial = None , help _ text = &apos; &apos; , * args , * * kwargs ) :
super ( ChoiceField , self ) . _ _ init _ _ ( required = required , widget = widget , label = label , initial = initial , help _ text = help _ text , * args , * * kwargs )
self . choices = choices
def _ _ deepcopy _ _ ( self , memo ) :
result = super ( ChoiceField , self ) . _ _ deepcopy _ _ ( memo )
result . _ choices = copy . deepcopy ( self . _ choices , memo )
return result
def _ get _ choices ( self ) :
return self . _ choices
def _ set _ choices ( self , value ) :
self . _ choices = self . widget . choices = list ( value )
choices = property ( _ get _ choices , _ set _ choices )
def to _ python ( self , value ) :
if value in self . empty _ values :
return &apos; &apos;
return smart _ text ( value )
def validate ( self , value ) :
super ( ChoiceField , self ) . validate ( value )
if value and not self . valid _ value ( value ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ choice &apos; &#93; , code = &apos; invalid _ choice &apos; , params = { &apos; value &apos; : value } , )
def valid _ value ( self , value ) :
text _ value = force _ text ( value )
for k , v in self . choices :
if isinstance ( v , ( list , tuple ) ) :
for k2 , v2 in v :
if value = = k2 or text _ value = = force _ text ( k2 ) :
return True
else :
if value = = k or text _ value = = force _ text ( k ) :
return True
return False
class TypedChoiceField ( ChoiceField ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
self . coerce = kwargs . pop ( &apos; coerce &apos; , lambda val : val )
self . empty _ value = kwargs . pop ( &apos; empty _ value &apos; , &apos; &apos; )
super ( TypedChoiceField , self ) . _ _ init _ _ ( * args , * * kwargs )
def _ coerce ( self , value ) :
if value = = self . empty _ value or value in self . empty _ values :
return self . empty _ value
try :
value = self . coerce ( value )
except ( ValueError , TypeError , ValidationError ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ choice &apos; &#93; , code = &apos; invalid _ choice &apos; , params = { &apos; value &apos; : value } , )
return value
def clean ( self , value ) :
value = super ( TypedChoiceField , self ) . clean ( value )
return self . _ coerce ( value )
class MultipleChoiceField ( ChoiceField ) :
hidden _ widget = MultipleHiddenInput
widget = SelectMultiple
default _ error _ messages = { &apos; invalid _ choice &apos; : _ ( &apos; Select a valid choice . % ( value ) s is not one of the available choices . &apos; ) , &apos; invalid _ list &apos; : _ ( &apos; Enter a list of values . &apos; ) , }
def to _ python ( self , value ) :
if not value :
return &#91; &#93;
elif not isinstance ( value , ( list , tuple ) ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ list &apos; &#93; , code = &apos; invalid _ list &apos; )
return &#91; smart _ text ( val ) for val in value &#93;
def validate ( self , value ) :
if self . required and not value :
raise ValidationError ( self . error _ messages &#91; &apos; required &apos; &#93; , code = &apos; required &apos; )
for val in value :
if not self . valid _ value ( val ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ choice &apos; &#93; , code = &apos; invalid _ choice &apos; , params = { &apos; value &apos; : val } , )
def _ has _ changed ( self , initial , data ) :
if initial is None :
initial = &#91; &#93;
if data is None :
data = &#91; &#93;
if len ( initial ) ! = len ( data ) :
return True
initial _ set = set ( force _ text ( value ) for value in initial )
data _ set = set ( force _ text ( value ) for value in data )
return data _ set ! = initial _ set
class TypedMultipleChoiceField ( MultipleChoiceField ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
self . coerce = kwargs . pop ( &apos; coerce &apos; , lambda val : val )
self . empty _ value = kwargs . pop ( &apos; empty _ value &apos; , &#91; &#93; )
super ( TypedMultipleChoiceField , self ) . _ _ init _ _ ( * args , * * kwargs )
def _ coerce ( self , value ) :
if value = = self . empty _ value or value in self . empty _ values :
return self . empty _ value
new _ value = &#91; &#93;
for choice in value :
try :
new _ value . append ( self . coerce ( choice ) )
except ( ValueError , TypeError , ValidationError ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ choice &apos; &#93; , code = &apos; invalid _ choice &apos; , params = { &apos; value &apos; : choice } , )
return new _ value
def clean ( self , value ) :
value = super ( TypedMultipleChoiceField , self ) . clean ( value )
return self . _ coerce ( value )
def validate ( self , value ) :
if value ! = self . empty _ value :
super ( TypedMultipleChoiceField , self ) . validate ( value )
elif self . required :
raise ValidationError ( self . error _ messages &#91; &apos; required &apos; &#93; , code = &apos; required &apos; )
class ComboField ( Field ) :
def _ _ init _ _ ( self , fields = ( ) , * args , * * kwargs ) :
super ( ComboField , self ) . _ _ init _ _ ( * args , * * kwargs )
for f in fields :
f . required = False
self . fields = fields
def clean ( self , value ) :
super ( ComboField , self ) . clean ( value )
for field in self . fields :
value = field . clean ( value )
return value
class MultiValueField ( Field ) :
default _ error _ messages = { &apos; invalid &apos; : _ ( &apos; Enter a list of values . &apos; ) , &apos; incomplete &apos; : _ ( &apos; Enter a complete value . &apos; ) , }
def _ _ init _ _ ( self , fields = ( ) , * args , * * kwargs ) :
self . require _ all _ fields = kwargs . pop ( &apos; require _ all _ fields &apos; , True )
super ( MultiValueField , self ) . _ _ init _ _ ( * args , * * kwargs )
for f in fields :
f . error _ messages . setdefault ( &apos; incomplete &apos; , self . error _ messages &#91; &apos; incomplete &apos; &#93; )
if self . require _ all _ fields :
f . required = False
self . fields = fields
def _ _ deepcopy _ _ ( self , memo ) :
result = super ( MultiValueField , self ) . _ _ deepcopy _ _ ( memo )
result . fields = tuple ( &#91; x . _ _ deepcopy _ _ ( memo ) for x in self . fields &#93; )
return result
def validate ( self , value ) :
pass
def clean ( self , value ) :
clean _ data = &#91; &#93;
errors = &#91; &#93;
if not value or isinstance ( value , ( list , tuple ) ) :
if not value or not &#91; v for v in value if v not in self . empty _ values &#93; :
if self . required :
raise ValidationError ( self . error _ messages &#91; &apos; required &apos; &#93; , code = &apos; required &apos; )
else :
return self . compress ( &#91; &#93; )
else :
raise ValidationError ( self . error _ messages &#91; &apos; invalid &apos; &#93; , code = &apos; invalid &apos; )
for i , field in enumerate ( self . fields ) :
try :
field _ value = value &#91; i &#93;
except IndexError :
field _ value = None
if field _ value in self . empty _ values :
if self . require _ all _ fields :
if self . required :
raise ValidationError ( self . error _ messages &#91; &apos; required &apos; &#93; , code = &apos; required &apos; )
elif field . required :
if field . error _ messages &#91; &apos; incomplete &apos; &#93; not in errors :
errors . append ( field . error _ messages &#91; &apos; incomplete &apos; &#93; )
continue
try :
clean _ data . append ( field . clean ( field _ value ) )
except ValidationError as e :
errors . extend ( m for m in e . error _ list if m not in errors )
if errors :
raise ValidationError ( errors )
out = self . compress ( clean _ data )
self . validate ( out )
self . run _ validators ( out )
return out
def compress ( self , data _ list ) :
raise NotImplementedError ( &apos; Subclasses must implement this method . &apos; )
def _ has _ changed ( self , initial , data ) :
if initial is None :
initial = &#91; &apos; &apos; for x in range ( 0 , len ( data ) ) &#93;
else :
if not isinstance ( initial , list ) :
initial = self . widget . decompress ( initial )
for field , initial , data in zip ( self . fields , initial , data ) :
if field . _ has _ changed ( field . to _ python ( initial ) , data ) :
return True
return False
class FilePathField ( ChoiceField ) :
def _ _ init _ _ ( self , path , match = None , recursive = False , allow _ files = True , allow _ folders = False , required = True , widget = None , label = None , initial = None , help _ text = &apos; &apos; , * args , * * kwargs ) :
self . path , self . match , self . recursive = path , match , recursive
self . allow _ files , self . allow _ folders = allow _ files , allow _ folders
super ( FilePathField , self ) . _ _ init _ _ ( choices = ( ) , required = required , widget = widget , label = label , initial = initial , help _ text = help _ text , * args , * * kwargs )
if self . required :
self . choices = &#91; &#93;
else :
self . choices = &#91; ( &quot; &quot; , &quot; --------- &quot; ) &#93;
if self . match is not None :
self . match _ re = re . compile ( self . match )
if recursive :
for root , dirs , files in sorted ( os . walk ( self . path ) ) :
if self . allow _ files :
for f in files :
if self . match is None or self . match _ re . search ( f ) :
f = os . path . join ( root , f )
self . choices . append ( ( f , f . replace ( path , &quot; &quot; , 1 ) ) )
if self . allow _ folders :
for f in dirs :
if f = = &apos; _ _ pycache _ _ &apos; :
continue
if self . match is None or self . match _ re . search ( f ) :
f = os . path . join ( root , f )
self . choices . append ( ( f , f . replace ( path , &quot; &quot; , 1 ) ) )
else :
try :
for f in sorted ( os . listdir ( self . path ) ) :
if f = = &apos; _ _ pycache _ _ &apos; :
continue
full _ file = os . path . join ( self . path , f )
if ( ( ( self . allow _ files and os . path . isfile ( full _ file ) ) or ( self . allow _ folders and os . path . isdir ( full _ file ) ) ) and ( self . match is None or self . match _ re . search ( f ) ) ) :
self . choices . append ( ( full _ file , f ) )
except OSError :
pass
self . widget . choices = self . choices
class SplitDateTimeField ( MultiValueField ) :
widget = SplitDateTimeWidget
hidden _ widget = SplitHiddenDateTimeWidget
default _ error _ messages = { &apos; invalid _ date &apos; : _ ( &apos; Enter a valid date . &apos; ) , &apos; invalid _ time &apos; : _ ( &apos; Enter a valid time . &apos; ) , }
def _ _ init _ _ ( self , input _ date _ formats = None , input _ time _ formats = None , * args , * * kwargs ) :
errors = self . default _ error _ messages . copy ( )
if &apos; error _ messages &apos; in kwargs :
errors . update ( kwargs &#91; &apos; error _ messages &apos; &#93; )
localize = kwargs . get ( &apos; localize &apos; , False )
fields = ( DateField ( input _ formats = input _ date _ formats , error _ messages = { &apos; invalid &apos; : errors &#91; &apos; invalid _ date &apos; &#93; } , localize = localize ) , TimeField ( input _ formats = input _ time _ formats , error _ messages = { &apos; invalid &apos; : errors &#91; &apos; invalid _ time &apos; &#93; } , localize = localize ) , )
super ( SplitDateTimeField , self ) . _ _ init _ _ ( fields , * args , * * kwargs )
def compress ( self , data _ list ) :
if data _ list :
if data _ list &#91; 0 &#93; in self . empty _ values :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ date &apos; &#93; , code = &apos; invalid _ date &apos; )
if data _ list &#91; 1 &#93; in self . empty _ values :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ time &apos; &#93; , code = &apos; invalid _ time &apos; )
result = datetime . datetime . combine ( * data _ list )
return from _ current _ timezone ( result )
return None
class IPAddressField ( CharField ) :
default _ validators = &#91; validators . validate _ ipv4 _ address &#93;
def _ _ init _ _ ( self , * args , * * kwargs ) :
warnings . warn ( &quot; IPAddressField has been deprecated . use GenericIPAddressField instead . &quot; , RemovedInDjango19Warning )
super ( IPAddressField , self ) . _ _ init _ _ ( * args , * * kwargs )
def to _ python ( self , value ) :
if value in self . empty _ values :
return &apos; &apos;
return value . strip ( )
class GenericIPAddressField ( CharField ) :
def _ _ init _ _ ( self , protocol = &apos; both &apos; , unpack _ ipv4 = False , * args , * * kwargs ) :
self . unpack _ ipv4 = unpack _ ipv4
self . default _ validators = validators . ip _ address _ validators ( protocol , unpack _ ipv4 ) &#91; 0 &#93;
super ( GenericIPAddressField , self ) . _ _ init _ _ ( * args , * * kwargs )
def to _ python ( self , value ) :
if value in self . empty _ values :
return &apos; &apos;
value = value . strip ( )
if value and &apos; : &apos; in value :
return clean _ ipv6 _ address ( value , self . unpack _ ipv4 )
return value
class SlugField ( CharField ) :
default _ validators = &#91; validators . validate _ slug &#93;
def clean ( self , value ) :
value = self . to _ python ( value ) . strip ( )
return super ( SlugField , self ) . clean ( value )
from _ _ future _ _ import unicode _ literals
from collections import OrderedDict
import copy
import datetime
import warnings
from django . core . exceptions import ValidationError , NON _ FIELD _ ERRORS
from django . forms . fields import Field , FileField
from django . forms . utils import flatatt , ErrorDict , ErrorList
from django . forms . widgets import Media , MediaDefiningClass , TextInput , Textarea
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import smart _ text , force _ text , python _ 2 _ unicode _ compatible
from django . utils . html import conditional _ escape , format _ html
from django . utils . SafeString import mark _ safe
from django . utils . translation import ugettext as _
from django . utils import six
_ _ all _ _ = ( &apos; BaseForm &apos; , &apos; Form &apos; )
def pretty _ name ( name ) :
if not name :
return &apos; &apos;
return name . replace ( &apos; _ &apos; , &apos; &apos; ) . capitalize ( )
def get _ declared _ fields ( bases , attrs , with _ base _ fields = True ) :
warnings . warn ( &quot; get _ declared _ fields is deprecated and will be removed in Django 1.9 . &quot; , RemovedInDjango19Warning , stacklevel = 2 , )
fields = &#91; ( field _ name , attrs . pop ( field _ name ) ) for field _ name , obj in list ( six . iteritems ( attrs ) ) if isinstance ( obj , Field ) &#93;
fields . sort ( key = lambda x : x &#91; 1 &#93; . creation _ counter )
if with _ base _ fields :
for base in bases &#91; : : - 1 &#93; :
if hasattr ( base , &apos; base _ fields &apos; ) :
fields = list ( six . iteritems ( base . base _ fields ) ) + fields
else :
for base in bases &#91; : : - 1 &#93; :
if hasattr ( base , &apos; declared _ fields &apos; ) :
fields = list ( six . iteritems ( base . declared _ fields ) ) + fields
return OrderedDict ( fields )
class DeclarativeFieldsMetaclass ( MediaDefiningClass ) :
def _ _ new _ _ ( mcs , name , bases , attrs ) :
current _ fields = &#91; &#93;
for key , value in list ( attrs . items ( ) ) :
if isinstance ( value , Field ) :
current _ fields . append ( ( key , value ) )
attrs . pop ( key )
current _ fields . sort ( key = lambda x : x &#91; 1 &#93; . creation _ counter )
attrs &#91; &apos; declared _ fields &apos; &#93; = OrderedDict ( current _ fields )
new _ class = ( super ( DeclarativeFieldsMetaclass , mcs ) . _ _ new _ _ ( mcs , name , bases , attrs ) )
declared _ fields = OrderedDict ( )
for base in reversed ( new _ class . _ _ mro _ _ ) :
if hasattr ( base , &apos; declared _ fields &apos; ) :
declared _ fields . update ( base . declared _ fields )
for attr , value in base . _ _ dict _ _ . items ( ) :
if value is None and attr in declared _ fields :
declared _ fields . pop ( attr )
new _ class . base _ fields = declared _ fields
new _ class . declared _ fields = declared _ fields
return new _ class
@ python _ 2 _ unicode _ compatible
class BaseForm ( object ) :
def _ _ init _ _ ( self , data = None , files = None , auto _ id = &apos; id _ % s &apos; , prefix = None , initial = None , error _ class = ErrorList , label _ suffix = None , empty _ permitted = False ) :
self . is _ bound = data is not None or files is not None
self . data = data or { }
self . files = files or { }
self . auto _ id = auto _ id
self . prefix = prefix
self . initial = initial or { }
self . error _ class = error _ class
self . label _ suffix = label _ suffix if label _ suffix is not None else _ ( &apos; : &apos; )
self . empty _ permitted = empty _ permitted
self . _ errors = None
self . _ changed _ data = None
self . fields = copy . deepcopy ( self . base _ fields )
def _ _ str _ _ ( self ) :
return self . as _ table ( )
def _ _ iter _ _ ( self ) :
for name in self . fields :
yield self &#91; name &#93;
def _ _ getitem _ _ ( self , name ) :
try :
field = self . fields &#91; name &#93;
except KeyError :
raise KeyError ( &quot; Key % r not found in &apos; % s &apos; &quot; % ( name , self . _ _ class _ _ . _ _ name _ _ ) )
return BoundField ( self , field , name )
@ property
def errors ( self ) :
if self . _ errors is None :
self . full _ clean ( )
return self . _ errors
def is _ valid ( self ) :
return self . is _ bound and not self . errors
def add _ prefix ( self , field _ name ) :
return &apos; % s- % s &apos; % ( self . prefix , field _ name ) if self . prefix else field _ name
def add _ initial _ prefix ( self , field _ name ) :
return &apos; initial- % s &apos; % self . add _ prefix ( field _ name )
def _ html _ output ( self , normal _ row , error _ row , row _ ender , help _ text _ html , errors _ on _ separate _ row ) :
top _ errors = self . non _ field _ errors ( )
output , hidden _ fields = &#91; &#93; , &#91; &#93;
for name , field in self . fields . items ( ) :
html _ class _ attr = &apos; &apos;
bf = self &#91; name &#93;
bf _ errors = self . error _ class ( &#91; conditional _ escape ( error ) for error in bf . errors &#93; )
if bf . is _ hidden :
if bf _ errors :
top _ errors . extend ( &#91; _ ( &apos; ( Hidden field % ( name ) s ) % ( error ) s &apos; ) % { &apos; name &apos; : name , &apos; error &apos; : force _ text ( e ) } for e in bf _ errors &#93; )
hidden _ fields . append ( six . text _ type ( bf ) )
else :
css _ classes = bf . css _ classes ( )
if css _ classes :
html _ class _ attr = &apos; class = &quot; % s &quot; &apos; % css _ classes
if errors _ on _ separate _ row and bf _ errors :
output . append ( error _ row % force _ text ( bf _ errors ) )
if bf . label :
label = conditional _ escape ( force _ text ( bf . label ) )
label = bf . label _ tag ( label ) or &apos; &apos;
else :
label = &apos; &apos;
if field . help _ text :
help _ text = help _ text _ html % force _ text ( field . help _ text )
else :
help _ text = &apos; &apos;
output . append ( normal _ row % { &apos; errors &apos; : force _ text ( bf _ errors ) , &apos; label &apos; : force _ text ( label ) , &apos; field &apos; : six . text _ type ( bf ) , &apos; help _ text &apos; : help _ text , &apos; html _ class _ attr &apos; : html _ class _ attr , &apos; field _ name &apos; : bf . html _ name , } )
if top _ errors :
output . insert ( 0 , error _ row % force _ text ( top _ errors ) )
if hidden _ fields :
str _ hidden = &apos; &apos; . join ( hidden _ fields )
if output :
last _ row = output &#91; - 1 &#93;
if not last _ row . endswith ( row _ ender ) :
last _ row = ( normal _ row % { &apos; errors &apos; : &apos; &apos; , &apos; label &apos; : &apos; &apos; , &apos; field &apos; : &apos; &apos; , &apos; help _ text &apos; : &apos; &apos; , &apos; html _ class _ attr &apos; : html _ class _ attr } )
output . append ( last _ row )
output &#91; - 1 &#93; = last _ row &#91; : - len ( row _ ender ) &#93; + str _ hidden + row _ ender
else :
output . append ( str _ hidden )
return mark _ safe ( &apos; \ n &apos; . join ( output ) )
def as _ table ( self ) :
return self . _ html _ output ( normal _ row = &apos; &lt; tr % ( html _ class _ attr ) s &gt; &lt; th &gt; % ( label ) s &lt; / th &gt; &lt; td &gt; % ( errors ) s % ( field ) s % ( help _ text ) s &lt; / td &gt; &lt; / tr &gt; &apos; , error _ row = &apos; &lt; tr &gt; &lt; td colspan = &quot; 2 &quot; &gt; % s &lt; / td &gt; &lt; / tr &gt; &apos; , row _ ender = &apos; &lt; / td &gt; &lt; / tr &gt; &apos; , help _ text _ html = &apos; &lt; br / &gt; &lt; span class = &quot; helptext &quot; &gt; % s &lt; / span &gt; &apos; , errors _ on _ separate _ row = False )
def as _ ul ( self ) :
return self . _ html _ output ( normal _ row = &apos; &lt; li % ( html _ class _ attr ) s &gt; % ( errors ) s % ( label ) s % ( field ) s % ( help _ text ) s &lt; / li &gt; &apos; , error _ row = &apos; &lt; li &gt; % s &lt; / li &gt; &apos; , row _ ender = &apos; &lt; / li &gt; &apos; , help _ text _ html = &apos; &lt; span class = &quot; helptext &quot; &gt; % s &lt; / span &gt; &apos; , errors _ on _ separate _ row = False )
def as _ p ( self ) :
return self . _ html _ output ( normal _ row = &apos; &lt; p % ( html _ class _ attr ) s &gt; % ( label ) s % ( field ) s % ( help _ text ) s &lt; / p &gt; &apos; , error _ row = &apos; % s &apos; , row _ ender = &apos; &lt; / p &gt; &apos; , help _ text _ html = &apos; &lt; span class = &quot; helptext &quot; &gt; % s &lt; / span &gt; &apos; , errors _ on _ separate _ row = True )
def non _ field _ errors ( self ) :
return self . errors . get ( NON _ FIELD _ ERRORS , self . error _ class ( error _ class = &apos; nonfield &apos; ) )
def _ raw _ value ( self , fieldname ) :
field = self . fields &#91; fieldname &#93;
prefix = self . add _ prefix ( fieldname )
return field . widget . value _ from _ datadict ( self . data , self . files , prefix )
def add _ error ( self , field , error ) :
if not isinstance ( error , ValidationError ) :
error = ValidationError ( error )
if hasattr ( error , &apos; error _ dict &apos; ) :
if field is not None :
raise TypeError ( &quot; The argument `field` must be `None` when the `error` &quot; &quot; argument contains errors for multiple fields . &quot; )
else :
error = error . error _ dict
else :
error = { field or NON _ FIELD _ ERRORS : error . error _ list }
for field , error _ list in error . items ( ) :
if field not in self . errors :
if field ! = NON _ FIELD _ ERRORS and field not in self . fields :
raise ValueError ( &quot; &apos; % s &apos; has no field named &apos; % s &apos; . &quot; % ( self . _ _ class _ _ . _ _ name _ _ , field ) )
if field = = NON _ FIELD _ ERRORS :
self . _ errors &#91; field &#93; = self . error _ class ( error _ class = &apos; nonfield &apos; )
else :
self . _ errors &#91; field &#93; = self . error _ class ( )
self . _ errors &#91; field &#93; . extend ( error _ list )
if field in self . cleaned _ data :
del self . cleaned _ data &#91; field &#93;
def has _ error ( self , field , code = None ) :
if code is None :
return field in self . errors
if field in self . errors :
for error in self . errors . as _ data ( ) &#91; field &#93; :
if error . code = = code :
return True
return False
def full _ clean ( self ) :
self . _ errors = ErrorDict ( )
if not self . is _ bound :
return
self . cleaned _ data = { }
if self . empty _ permitted and not self . has _ changed ( ) :
return
self . _ clean _ fields ( )
self . _ clean _ form ( )
self . _ post _ clean ( )
def _ clean _ fields ( self ) :
for name , field in self . fields . items ( ) :
value = field . widget . value _ from _ datadict ( self . data , self . files , self . add _ prefix ( name ) )
try :
if isinstance ( field , FileField ) :
initial = self . initial . get ( name , field . initial )
value = field . clean ( value , initial )
else :
value = field . clean ( value )
self . cleaned _ data &#91; name &#93; = value
if hasattr ( self , &apos; clean _ % s &apos; % name ) :
value = getattr ( self , &apos; clean _ % s &apos; % name ) ( )
self . cleaned _ data &#91; name &#93; = value
except ValidationError as e :
self . add _ error ( name , e )
def _ clean _ form ( self ) :
try :
cleaned _ data = self . clean ( )
except ValidationError as e :
self . add _ error ( None , e )
else :
if cleaned _ data is not None :
self . cleaned _ data = cleaned _ data
def _ post _ clean ( self ) :
pass
def clean ( self ) :
return self . cleaned _ data
def has _ changed ( self ) :
return bool ( self . changed _ data )
@ property
def changed _ data ( self ) :
if self . _ changed _ data is None :
self . _ changed _ data = &#91; &#93;
for name , field in self . fields . items ( ) :
prefixed _ name = self . add _ prefix ( name )
data _ value = field . widget . value _ from _ datadict ( self . data , self . files , prefixed _ name )
if not field . show _ hidden _ initial :
initial _ value = self . initial . get ( name , field . initial )
if callable ( initial _ value ) :
initial _ value = initial _ value ( )
else :
initial _ prefixed _ name = self . add _ initial _ prefix ( name )
hidden _ widget = field . hidden _ widget ( )
try :
initial _ value = field . to _ python ( hidden _ widget . value _ from _ datadict ( self . data , self . files , initial _ prefixed _ name ) )
except ValidationError :
self . _ changed _ data . append ( name )
continue
if field . _ has _ changed ( initial _ value , data _ value ) :
self . _ changed _ data . append ( name )
return self . _ changed _ data
@ property
def media ( self ) :
media = Media ( )
for field in self . fields . values ( ) :
media = media + field . widget . media
return media
def is _ multipart ( self ) :
for field in self . fields . values ( ) :
if field . widget . needs _ multipart _ form :
return True
return False
def hidden _ fields ( self ) :
return &#91; field for field in self if field . is _ hidden &#93;
def visible _ fields ( self ) :
return &#91; field for field in self if not field . is _ hidden &#93;
class Form ( six . with _ metaclass ( DeclarativeFieldsMetaclass , BaseForm ) ) :
@ python _ 2 _ unicode _ compatible
class BoundField ( object ) :
def _ _ init _ _ ( self , form , field , name ) :
self . form = form
self . field = field
self . name = name
self . html _ name = form . add _ prefix ( name )
self . html _ initial _ name = form . add _ initial _ prefix ( name )
self . html _ initial _ id = form . add _ initial _ prefix ( self . auto _ id )
if self . field . label is None :
self . label = pretty _ name ( name )
else :
self . label = self . field . label
self . help _ text = field . help _ text or &apos; &apos;
def _ _ str _ _ ( self ) :
if self . field . show _ hidden _ initial :
return self . as _ widget ( ) + self . as _ hidden ( only _ initial = True )
return self . as _ widget ( )
def _ _ iter _ _ ( self ) :
id _ = self . field . widget . attrs . get ( &apos; id &apos; ) or self . auto _ id
attrs = { &apos; id &apos; : id _ } if id _ else { }
for subwidget in self . field . widget . subwidgets ( self . html _ name , self . value ( ) , attrs ) :
yield subwidget
def _ _ len _ _ ( self ) :
return len ( list ( self . _ _ iter _ _ ( ) ) )
def _ _ getitem _ _ ( self , idx ) :
return list ( self . _ _ iter _ _ ( ) ) &#91; idx &#93;
@ property
def errors ( self ) :
return self . form . errors . get ( self . name , self . form . error _ class ( ) )
def as _ widget ( self , widget = None , attrs = None , only _ initial = False ) :
if not widget :
widget = self . field . widget
if self . field . localize :
widget . is _ localized = True
attrs = attrs or { }
auto _ id = self . auto _ id
if auto _ id and &apos; id &apos; not in attrs and &apos; id &apos; not in widget . attrs :
if not only _ initial :
attrs &#91; &apos; id &apos; &#93; = auto _ id
else :
attrs &#91; &apos; id &apos; &#93; = self . html _ initial _ id
if not only _ initial :
name = self . html _ name
else :
name = self . html _ initial _ name
return force _ text ( widget . render ( name , self . value ( ) , attrs = attrs ) )
def as _ text ( self , attrs = None , * * kwargs ) :
return self . as _ widget ( TextInput ( ) , attrs , * * kwargs )
def as _ textarea ( self , attrs = None , * * kwargs ) :
return self . as _ widget ( Textarea ( ) , attrs , * * kwargs )
def as _ hidden ( self , attrs = None , * * kwargs ) :
return self . as _ widget ( self . field . hidden _ widget ( ) , attrs , * * kwargs )
@ property
def data ( self ) :
return self . field . widget . value _ from _ datadict ( self . form . data , self . form . files , self . html _ name )
def value ( self ) :
if not self . form . is _ bound :
data = self . form . initial . get ( self . name , self . field . initial )
if callable ( data ) :
data = data ( )
if ( isinstance ( data , ( datetime . datetime , datetime . time ) ) and not getattr ( self . field . widget , &apos; supports _ microseconds &apos; , True ) ) :
data = data . replace ( microsecond = 0 )
else :
data = self . field . bound _ data ( self . data , self . form . initial . get ( self . name , self . field . initial ) )
return self . field . prepare _ value ( data )
def label _ tag ( self , contents = None , attrs = None , label _ suffix = None ) :
contents = contents or self . label
if label _ suffix is None :
label _ suffix = ( self . field . label _ suffix if self . field . label _ suffix is not None else self . form . label _ suffix )
if label _ suffix and contents and contents &#91; - 1 &#93; not in _ ( &apos; : ? . ! &apos; ) :
contents = format _ html ( &apos; { 0 } { 1 } &apos; , contents , label _ suffix )
widget = self . field . widget
id _ = widget . attrs . get ( &apos; id &apos; ) or self . auto _ id
if id _ :
id _ for _ label = widget . id _ for _ label ( id _ )
if id _ for _ label :
attrs = dict ( attrs or { } , * * { &apos; for &apos; : id _ for _ label } )
if self . field . required and hasattr ( self . form , &apos; required _ css _ class &apos; ) :
attrs = attrs or { }
if &apos; class &apos; in attrs :
attrs &#91; &apos; class &apos; &#93; + = &apos; &apos; + self . form . required _ css _ class
else :
attrs &#91; &apos; class &apos; &#93; = self . form . required _ css _ class
attrs = flatatt ( attrs ) if attrs else &apos; &apos;
contents = format _ html ( &apos; &lt; label { 0 } &gt; { 1 } &lt; / label &gt; &apos; , attrs , contents )
else :
contents = conditional _ escape ( contents )
return mark _ safe ( contents )
def css _ classes ( self , extra _ classes = None ) :
if hasattr ( extra _ classes , &apos; split &apos; ) :
extra _ classes = extra _ classes . split ( )
extra _ classes = set ( extra _ classes or &#91; &#93; )
if self . errors and hasattr ( self . form , &apos; error _ css _ class &apos; ) :
extra _ classes . add ( self . form . error _ css _ class )
if self . field . required and hasattr ( self . form , &apos; required _ css _ class &apos; ) :
extra _ classes . add ( self . form . required _ css _ class )
return &apos; &apos; . join ( extra _ classes )
@ property
def is _ hidden ( self ) :
return self . field . widget . is _ hidden
@ property
def auto _ id ( self ) :
auto _ id = self . form . auto _ id
if auto _ id and &apos; % s &apos; in smart _ text ( auto _ id ) :
return smart _ text ( auto _ id ) % self . html _ name
elif auto _ id :
return self . html _ name
return &apos; &apos;
@ property
def id _ for _ label ( self ) :
widget = self . field . widget
id _ = widget . attrs . get ( &apos; id &apos; ) or self . auto _ id
return widget . id _ for _ label ( id _ )
from _ _ future _ _ import unicode _ literals
from django . core . exceptions import ValidationError
from django . forms import Form
from django . forms . fields import IntegerField , BooleanField
from django . forms . utils import ErrorList
from django . forms . widgets import HiddenInput
from django . utils . encoding import python _ 2 _ unicode _ compatible
from django . utils . functional import cached _ property
from django . utils . SafeString import mark _ safe
from django . utils import six
from django . utils . six . moves import xrange
from django . utils . translation import ungettext , ugettext as _
_ _ all _ _ = ( &apos; BaseFormSet &apos; , &apos; formset _ factory &apos; , &apos; all _ valid &apos; )
total _ FORM _ COUNT = &apos; TOTAL _ FORMS&apos;
initial _ FORM _ COUNT = &apos; INITIAL _ FORMS&apos;
min _ NUM _ FORM _ COUNT = &apos; MIN _ NUM _ FORMS&apos;
max _ NUM _ FORM _ COUNT = &apos; MAX _ NUM _ FORMS&apos;
ordering _ FIELD _ NAME = &apos; ORDER&apos;
DELETION _ FIELD _ NAME = &apos; DELETE&apos;
default _ MIN _ NUM = 0
default _ MAX _ NUM = 1000
class ManagementForm ( Form ) :
def _ _ init _ _ ( self , * args , * * kwargs ) :
self . base _ fields &#91; TOTAL _ FORM _ COUNT &#93; = IntegerField ( widget = HiddenInput )
self . base _ fields &#91; INITIAL _ FORM _ COUNT &#93; = IntegerField ( widget = HiddenInput )
self . base _ fields &#91; MIN _ NUM _ FORM _ COUNT &#93; = IntegerField ( required = False , widget = HiddenInput )
self . base _ fields &#91; MAX _ NUM _ FORM _ COUNT &#93; = IntegerField ( required = False , widget = HiddenInput )
super ( ManagementForm , self ) . _ _ init _ _ ( * args , * * kwargs )
@ python _ 2 _ unicode _ compatible
class BaseFormSet ( object ) :
def _ _ init _ _ ( self , data = None , files = None , auto _ id = &apos; id _ % s &apos; , prefix = None , initial = None , error _ class = ErrorList ) :
self . is _ bound = data is not None or files is not None
self . prefix = prefix or self . get _ default _ prefix ( )
self . auto _ id = auto _ id
self . data = data or { }
self . files = files or { }
self . initial = initial
self . error _ class = error _ class
self . _ errors = None
self . _ non _ form _ errors = None
def _ _ str _ _ ( self ) :
return self . as _ table ( )
def _ _ iter _ _ ( self ) :
return iter ( self . forms )
def _ _ getitem _ _ ( self , index ) :
return self . forms &#91; index &#93;
def _ _ len _ _ ( self ) :
return len ( self . forms )
def _ _ bool _ _ ( self ) :
return True
def _ _ nonzero _ _ ( self ) :
return type ( self ) . _ _ bool _ _ ( self )
@ property
def management _ form ( self ) :
if self . is _ bound :
form = ManagementForm ( self . data , auto _ id = self . auto _ id , prefix = self . prefix )
if not form . is _ valid ( ) :
raise ValidationError ( _ ( &apos; ManagementForm data is missing or has been tampered with &apos; ) , code = &apos; missing _ management _ form &apos; , )
else :
form = ManagementForm ( auto _ id = self . auto _ id , prefix = self . prefix , initial = { TOTAL _ FORM _ COUNT : self . total _ form _ count ( ) , INITIAL _ FORM _ COUNT : self . initial _ form _ count ( ) , MIN _ NUM _ FORM _ COUNT : self . min _ num , MAX _ NUM _ FORM _ COUNT : self . max _ num } )
return form
def total _ form _ count ( self ) :
if self . is _ bound :
return min ( self . management _ form . cleaned _ data &#91; TOTAL _ FORM _ COUNT &#93; , self . absolute _ max )
else :
initial _ forms = self . initial _ form _ count ( )
total _ forms = max ( initial _ forms , self . min _ num ) + self . extra
if initial _ forms &gt; self . max _ num &gt; = 0 :
total _ forms = initial _ forms
elif total _ forms &gt; self . max _ num &gt; = 0 :
total _ forms = self . max _ num
return total _ forms
def initial _ form _ count ( self ) :
if self . is _ bound :
return self . management _ form . cleaned _ data &#91; INITIAL _ FORM _ COUNT &#93;
else :
initial _ forms = len ( self . initial ) if self . initial else 0
return initial _ forms
@ cached _ property
def forms ( self ) :
forms = &#91; self . _ construct _ form ( i ) for i in xrange ( self . total _ form _ count ( ) ) &#93;
return forms
def _ construct _ form ( self , i , * * kwargs ) :
defaults = { &apos; auto _ id &apos; : self . auto _ id , &apos; prefix &apos; : self . add _ prefix ( i ) , &apos; error _ class &apos; : self . error _ class , }
if self . is _ bound :
defaults &#91; &apos; data &apos; &#93; = self . data
defaults &#91; &apos; files &apos; &#93; = self . files
if self . initial and &apos; initial &apos; not in kwargs :
try :
defaults &#91; &apos; initial &apos; &#93; = self . initial &#91; i &#93;
except IndexError :
pass
if i &gt; = self . initial _ form _ count ( ) and i &gt; = self . min _ num :
defaults &#91; &apos; empty _ permitted &apos; &#93; = True
defaults . update ( kwargs )
form = self . form ( * * defaults )
self . add _ fields ( form , i )
return form
@ property
def initial _ forms ( self ) :
return self . forms &#91; : self . initial _ form _ count ( ) &#93;
@ property
def extra _ forms ( self ) :
return self . forms &#91; self . initial _ form _ count ( ) : &#93;
@ property
def empty _ form ( self ) :
form = self . form ( auto _ id = self . auto _ id , prefix = self . add _ prefix ( &apos; _ _ prefix _ _ &apos; ) , empty _ permitted = True , )
self . add _ fields ( form , None )
return form
@ property
def cleaned _ data ( self ) :
if not self . is _ valid ( ) :
raise AttributeError ( &quot; &apos; % s &apos; object has no attribute &apos; cleaned _ data &apos; &quot; % self . _ _ class _ _ . _ _ name _ _ )
return &#91; form . cleaned _ data for form in self . forms &#93;
@ property
def deleted _ forms ( self ) :
if not self . is _ valid ( ) or not self . can _ delete :
return &#91; &#93;
if not hasattr ( self , &apos; _ deleted _ form _ indexes &apos; ) :
self . _ deleted _ form _ indexes = &#91; &#93;
for i in range ( 0 , self . total _ form _ count ( ) ) :
form = self . forms &#91; i &#93;
if i &gt; = self . initial _ form _ count ( ) and not form . has _ changed ( ) :
continue
if self . _ should _ delete _ form ( form ) :
self . _ deleted _ form _ indexes . append ( i )
return &#91; self . forms &#91; i &#93; for i in self . _ deleted _ form _ indexes &#93;
@ property
def ordered _ forms ( self ) :
if not self . is _ valid ( ) or not self . can _ order :
raise AttributeError ( &quot; &apos; % s &apos; object has no attribute &apos; ordered _ forms &apos; &quot; % self . _ _ class _ _ . _ _ name _ _ )
if not hasattr ( self , &apos; _ ordering &apos; ) :
self . _ ordering = &#91; &#93;
for i in range ( 0 , self . total _ form _ count ( ) ) :
form = self . forms &#91; i &#93;
if i &gt; = self . initial _ form _ count ( ) and not form . has _ changed ( ) :
continue
if self . can _ delete and self . _ should _ delete _ form ( form ) :
continue
self . _ ordering . append ( ( i , form . cleaned _ data &#91; ORDERING _ FIELD _ NAME &#93; ) )
def compare _ ordering _ key ( k ) :
if k &#91; 1 &#93; is None :
return ( 1 , 0 )
return ( 0 , k &#91; 1 &#93; )
self . _ ordering . sort ( key = compare _ ordering _ key )
return &#91; self . forms &#91; i &#91; 0 &#93; &#93; for i in self . _ ordering &#93;
@ classmethod
def get _ default _ prefix ( cls ) :
return &apos; form&apos;
def non _ form _ errors ( self ) :
if self . _ non _ form _ errors is None :
self . full _ clean ( )
return self . _ non _ form _ errors
@ property
def errors ( self ) :
if self . _ errors is None :
self . full _ clean ( )
return self . _ errors
def total _ error _ count ( self ) :
return len ( self . non _ form _ errors ( ) ) + sum ( len ( form _ errors ) for form _ errors in self . errors )
def _ should _ delete _ form ( self , form ) :
return form . cleaned _ data . get ( DELETION _ FIELD _ NAME , False )
def is _ valid ( self ) :
if not self . is _ bound :
return False
forms _ valid = True
self . errors
for i in range ( 0 , self . total _ form _ count ( ) ) :
form = self . forms &#91; i &#93;
if self . can _ delete :
if self . _ should _ delete _ form ( form ) :
continue
forms _ valid &amp; = form . is _ valid ( )
return forms _ valid and not self . non _ form _ errors ( )
def full _ clean ( self ) :
self . _ errors = &#91; &#93;
self . _ non _ form _ errors = self . error _ class ( )
if not self . is _ bound :
return
for i in range ( 0 , self . total _ form _ count ( ) ) :
form = self . forms &#91; i &#93;
self . _ errors . append ( form . errors )
try :
if ( self . validate _ max and self . total _ form _ count ( ) - len ( self . deleted _ forms ) &gt; self . max _ num ) or self . management _ form . cleaned _ data &#91; TOTAL _ FORM _ COUNT &#93; &gt; self . absolute _ max :
raise ValidationError ( ungettext ( &quot; Please submit % d or fewer forms . &quot; , &quot; Please submit % d or fewer forms . &quot; , self . max _ num ) % self . max _ num , code = &apos; too _ many _ forms &apos; , )
if ( self . validate _ min and self . total _ form _ count ( ) - len ( self . deleted _ forms ) &lt; self . min _ num ) :
raise ValidationError ( ungettext ( &quot; Please submit % d or more forms . &quot; , &quot; Please submit % d or more forms . &quot; , self . min _ num ) % self . min _ num , code = &apos; too _ few _ forms &apos; )
self . clean ( )
except ValidationError as e :
self . _ non _ form _ errors = self . error _ class ( e . error _ list )
def clean ( self ) :
pass
def has _ changed ( self ) :
return any ( form . has _ changed ( ) for form in self )
def add _ fields ( self , form , index ) :
if self . can _ order :
if index is not None and index &lt; self . initial _ form _ count ( ) :
form . fields &#91; ORDERING _ FIELD _ NAME &#93; = IntegerField ( label = _ ( &apos; Order &apos; ) , initial = index + 1 , required = False )
else :
form . fields &#91; ORDERING _ FIELD _ NAME &#93; = IntegerField ( label = _ ( &apos; Order &apos; ) , required = False )
if self . can _ delete :
form . fields &#91; DELETION _ FIELD _ NAME &#93; = BooleanField ( label = _ ( &apos; Delete &apos; ) , required = False )
def add _ prefix ( self , index ) :
return &apos; % s- % s &apos; % ( self . prefix , index )
def is _ multipart ( self ) :
if self . forms :
return self . forms &#91; 0 &#93; . is _ multipart ( )
else :
return self . empty _ form . is _ multipart ( )
@ property
def media ( self ) :
if self . forms :
return self . forms &#91; 0 &#93; . media
else :
return self . empty _ form . media
def as _ table ( self ) :
forms = &apos; &apos; . join ( form . as _ table ( ) for form in self )
return mark _ safe ( &apos; \ n &apos; . join ( &#91; six . text _ type ( self . management _ form ) , forms &#93; ) )
def as _ p ( self ) :
forms = &apos; &apos; . join ( form . as _ p ( ) for form in self )
return mark _ safe ( &apos; \ n &apos; . join ( &#91; six . text _ type ( self . management _ form ) , forms &#93; ) )
def as _ ul ( self ) :
forms = &apos; &apos; . join ( form . as _ ul ( ) for form in self )
return mark _ safe ( &apos; \ n &apos; . join ( &#91; six . text _ type ( self . management _ form ) , forms &#93; ) )
def formset _ factory ( form , formset = BaseFormSet , extra = 1 , can _ order = False , can _ delete = False , max _ num = None , validate _ max = False , min _ num = None , validate _ min = False ) :
if min _ num is None :
min _ num = DEFAULT _ MIN _ NUM
if max _ num is None :
max _ num = DEFAULT _ MAX _ NUM
absolute _ max = max _ num + DEFAULT _ MAX _ NUM
attrs = { &apos; form &apos; : form , &apos; extra &apos; : extra , &apos; can _ order &apos; : can _ order , &apos; can _ delete &apos; : can _ delete , &apos; min _ num &apos; : min _ num , &apos; max _ num &apos; : max _ num , &apos; absolute _ max &apos; : absolute _ max , &apos; validate _ min &apos; : validate _ min , &apos; validate _ max &apos; : validate _ max }
return type ( form . _ _ name _ _ + str ( &apos; FormSet &apos; ) , ( formset , ) , attrs )
def all _ valid ( formsets ) :
valid = True
for formset in formsets :
if not formset . is _ valid ( ) :
valid = False
return valid
from _ _ future _ _ import unicode _ literals
from collections import OrderedDict
import warnings
from django . core . exceptions import ( ImproperlyConfigured , ValidationError , NON _ FIELD _ ERRORS , FieldError )
from django . forms . fields import Field , ChoiceField
from django . forms . forms import DeclarativeFieldsMetaclass , BaseForm
from django . forms . formsets import BaseFormSet , formset _ factory
from django . forms . utils import ErrorList
from django . forms . widgets import ( SelectMultiple , HiddenInput , MultipleHiddenInput )
from django . utils import six
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import smart _ text , force _ text
from django . utils . text import get _ text _ list , capfirst
from django . utils . translation import ugettext _ lazy as _ , ugettext
_ _ all _ _ = ( &apos; ModelForm &apos; , &apos; BaseModelForm &apos; , &apos; model _ to _ dict &apos; , &apos; fields _ for _ model &apos; , &apos; save _ instance &apos; , &apos; ModelChoiceField &apos; , &apos; ModelMultipleChoiceField &apos; , &apos; ALL _ FIELDS &apos; , &apos; BaseModelFormSet &apos; , &apos; modelformset _ factory &apos; , &apos; BaseInlineFormSet &apos; , &apos; inlineformset _ factory &apos; , )
all _ FIELDS = &apos; _ _ all _ _ &apos;
def construct _ instance ( form , instance , fields = None , exclude = None ) :
from django . db import models
opts = instance . _ meta
cleaned _ data = form . cleaned _ data
file _ field _ list = &#91; &#93;
for f in opts . fields :
if not f . editable or isinstance ( f , models . AutoField ) or f . name not in cleaned _ data :
continue
if fields is not None and f . name not in fields :
continue
if exclude and f . name in exclude :
continue
if isinstance ( f , models . FileField ) :
file _ field _ list . append ( f )
else :
f . save _ form _ data ( instance , cleaned _ data &#91; f . name &#93; )
for f in file _ field _ list :
f . save _ form _ data ( instance , cleaned _ data &#91; f . name &#93; )
return instance
def save _ instance ( form , instance , fields = None , fail _ message = &apos; saved &apos; , commit = True , exclude = None , construct = True ) :
if construct :
instance = construct _ instance ( form , instance , fields , exclude )
opts = instance . _ meta
if form . errors :
raise ValueError ( &quot; The % s could not be % s because the data didn &apos;t &quot; &quot; validate . &quot; % ( opts . object _ name , fail _ message ) )
def save _ m2m ( ) :
cleaned _ data = form . cleaned _ data
for f in opts . many _ to _ many + opts . virtual _ fields :
if not hasattr ( f , &apos; save _ form _ data &apos; ) :
continue
if fields and f . name not in fields :
continue
if exclude and f . name in exclude :
continue
if f . name in cleaned _ data :
f . save _ form _ data ( instance , cleaned _ data &#91; f . name &#93; )
if commit :
instance . save ( )
save _ m2m ( )
else :
form . save _ m2m = save _ m2m
return instance
def model _ to _ dict ( instance , fields = None , exclude = None ) :
from django . db . models . fields . related import ManyToManyField
opts = instance . _ meta
data = { }
for f in opts . concrete _ fields + opts . virtual _ fields + opts . many _ to _ many :
if not getattr ( f , &apos; editable &apos; , False ) :
continue
if fields and f . name not in fields :
continue
if exclude and f . name in exclude :
continue
if isinstance ( f , ManyToManyField ) :
if instance . pk is None :
data &#91; f . name &#93; = &#91; &#93;
else :
qs = f . value _ from _ object ( instance )
if qs . _ result _ cache is not None :
data &#91; f . name &#93; = &#91; item . pk for item in qs &#93;
else :
data &#91; f . name &#93; = list ( qs . values _ list ( &apos; pk &apos; , flat = True ) )
else :
data &#91; f . name &#93; = f . value _ from _ object ( instance )
return data
def fields _ for _ model ( model , fields = None , exclude = None , widgets = None , formfield _ callback = None , localized _ fields = None , labels = None , help _ texts = None , error _ messages = None ) :
field _ list = &#91; &#93;
ignored = &#91; &#93;
opts = model . _ meta
from django . db . models . fields import Field as ModelField
sortable _ virtual _ fields = &#91; f for f in opts . virtual _ fields if isinstance ( f , ModelField ) &#93;
for f in sorted ( opts . concrete _ fields + sortable _ virtual _ fields + opts . many _ to _ many ) :
if not getattr ( f , &apos; editable &apos; , False ) :
continue
if fields is not None and f . name not in fields :
continue
if exclude and f . name in exclude :
continue
kwargs = { }
if widgets and f . name in widgets :
kwargs &#91; &apos; widget &apos; &#93; = widgets &#91; f . name &#93;
if localized _ fields = = ALL _ FIELDS or ( localized _ fields and f . name in localized _ fields ) :
kwargs &#91; &apos; localize &apos; &#93; = True
if labels and f . name in labels :
kwargs &#91; &apos; label &apos; &#93; = labels &#91; f . name &#93;
if help _ texts and f . name in help _ texts :
kwargs &#91; &apos; help _ text &apos; &#93; = help _ texts &#91; f . name &#93;
if error _ messages and f . name in error _ messages :
kwargs &#91; &apos; error _ messages &apos; &#93; = error _ messages &#91; f . name &#93;
if formfield _ callback is None :
formfield = f . formfield ( * * kwargs )
elif not callable ( formfield _ callback ) :
raise TypeError ( &apos; formfield _ callback must be a function or callable &apos; )
else :
formfield = formfield _ callback ( f , * * kwargs )
if formfield :
field _ list . append ( ( f . name , formfield ) )
else :
ignored . append ( f . name )
field _ dict = OrderedDict ( field _ list )
if fields :
field _ dict = OrderedDict ( &#91; ( f , field _ dict . get ( f ) ) for f in fields if ( ( not exclude ) or ( exclude and f not in exclude ) ) and ( f not in ignored ) &#93; )
return field _ dict
class ModelFormOptions ( object ) :
def _ _ init _ _ ( self , options = None ) :
self . model = getattr ( options , &apos; model &apos; , None )
self . fields = getattr ( options , &apos; fields &apos; , None )
self . exclude = getattr ( options , &apos; exclude &apos; , None )
self . widgets = getattr ( options , &apos; widgets &apos; , None )
self . localized _ fields = getattr ( options , &apos; localized _ fields &apos; , None )
self . labels = getattr ( options , &apos; labels &apos; , None )
self . help _ texts = getattr ( options , &apos; help _ texts &apos; , None )
self . error _ messages = getattr ( options , &apos; error _ messages &apos; , None )
class ModelFormMetaclass ( DeclarativeFieldsMetaclass ) :
def _ _ new _ _ ( mcs , name , bases , attrs ) :
formfield _ callback = attrs . pop ( &apos; formfield _ callback &apos; , None )
new _ class = super ( ModelFormMetaclass , mcs ) . _ _ new _ _ ( mcs , name , bases , attrs )
if bases = = ( BaseModelForm , ) :
return new _ class
opts = new _ class . _ meta = ModelFormOptions ( getattr ( new _ class , &apos; Meta &apos; , None ) )
for opt in &#91; &apos; fields &apos; , &apos; exclude &apos; , &apos; localized _ fields &apos; &#93; :
value = getattr ( opts , opt )
if isinstance ( value , six . string _ types ) and value ! = ALL _ FIELDS :
msg = ( &quot; % ( model ) s.Meta. % ( opt ) s cannot be a string . &quot; &quot; did you mean to type : ( &apos; % ( value ) s &apos; , ) ? &quot; % { &apos; model &apos; : new _ class . _ _ name _ _ , &apos; opt &apos; : opt , &apos; value &apos; : value , } )
raise TypeError ( msg )
if opts . model :
if opts . fields is None and opts . exclude is None :
raise ImproperlyConfigured ( &quot; Creating a ModelForm without either the &apos; fields &apos; attribute &quot; &quot; or the &apos; exclude &apos; attribute is prohibited ; form % s &quot; &quot; needs updating . &quot; % name )
if opts . fields = = ALL _ FIELDS :
opts . fields = None
fields = fields _ for _ model ( opts . model , opts . fields , opts . exclude , opts . widgets , formfield _ callback , opts . localized _ fields , opts . labels , opts . help _ texts , opts . error _ messages )
None _ model _ fields = &#91; k for k , v in six . iteritems ( fields ) if not v &#93;
missing _ fields = ( set ( none _ model _ fields ) - set ( new _ class . declared _ fields . keys ( ) ) )
if missing _ fields :
message = &apos; Unknown field ( s ) ( % s ) specified for % s&apos;
message = message % ( &apos; , &apos; . join ( missing _ fields ) , opts . model . _ _ name _ _ )
raise FieldError ( message )
fields . update ( new _ class . declared _ fields )
else :
fields = new _ class . declared _ fields
new _ class . base _ fields = fields
return new _ class
class BaseModelForm ( BaseForm ) :
def _ _ init _ _ ( self , data = None , files = None , auto _ id = &apos; id _ % s &apos; , prefix = None , initial = None , error _ class = ErrorList , label _ suffix = None , empty _ permitted = False , instance = None ) :
opts = self . _ meta
if opts . model is None :
raise ValueError ( &apos; ModelForm has no model class specified . &apos; )
if instance is None :
self . instance = opts . model ( )
object _ data = { }
else :
self . instance = instance
object _ data = model _ to _ dict ( instance , opts . fields , opts . exclude )
if initial is not None :
object _ data . update ( initial )
self . _ validate _ unique = False
super ( BaseModelForm , self ) . _ _ init _ _ ( data , files , auto _ id , prefix , object _ data , error _ class , label _ suffix , empty _ permitted )
for field _ name in self . fields :
formfield = self . fields &#91; field _ name &#93;
if hasattr ( formfield , &apos; queryset &apos; ) :
limit _ choices _ to = formfield . limit _ choices _ to
if limit _ choices _ to is not None :
if callable ( limit _ choices _ to ) :
limit _ choices _ to = limit _ choices _ to ( )
formfield . queryset = formfield . queryset . complex _ filter ( limit _ choices _ to )
def _ get _ validation _ exclusions ( self ) :
exclude = &#91; &#93;
for f in self . instance . _ meta . fields :
field = f . name
if field not in self . fields :
exclude . append ( f . name )
elif self . _ meta . fields and field not in self . _ meta . fields :
exclude . append ( f . name )
elif self . _ meta . exclude and field in self . _ meta . exclude :
exclude . append ( f . name )
elif field in self . _ errors . keys ( ) :
exclude . append ( f . name )
else :
form _ field = self . fields &#91; field &#93;
field _ value = self . cleaned _ data . get ( field , None )
if not f . blank and not form _ field . required and field _ value in form _ field . empty _ values :
exclude . append ( f . name )
return exclude
def clean ( self ) :
self . _ validate _ unique = True
return self . cleaned _ data
def _ update _ errors ( self , errors ) :
opts = self . _ meta
for field , messages in errors . error _ dict . items ( ) :
if ( field = = NON _ FIELD _ ERRORS and opts . error _ messages and NON _ FIELD _ ERRORS in opts . error _ messages ) :
error _ messages = opts . error _ messages &#91; NON _ FIELD _ ERRORS &#93;
elif field in self . fields :
error _ messages = self . fields &#91; field &#93; . error _ messages
else :
continue
for message in messages :
if ( isinstance ( message , ValidationError ) and message . code in error _ messages ) :
message . message = error _ messages &#91; message . code &#93;
self . add _ error ( None , errors )
def _ post _ clean ( self ) :
opts = self . _ meta
exclude = self . _ get _ validation _ exclusions ( )
construct _ instance _ exclude = list ( exclude )
for name , field in self . fields . items ( ) :
if isinstance ( field , InlineForeignKeyField ) :
if self . cleaned _ data . get ( name ) is not None and self . cleaned _ data &#91; name &#93; . _ state . adding :
construct _ instance _ exclude . append ( name )
exclude . append ( name )
self . instance = construct _ instance ( self , self . instance , opts . fields , construct _ instance _ exclude )
try :
self . instance . full _ clean ( exclude = exclude , validate _ unique = False )
except ValidationError as e :
self . _ update _ errors ( e )
if self . _ validate _ unique :
self . validate _ unique ( )
def validate _ unique ( self ) :
exclude = self . _ get _ validation _ exclusions ( )
try :
self . instance . validate _ unique ( exclude = exclude )
except ValidationError as e :
self . _ update _ errors ( e )
def save ( self , commit = True ) :
if self . instance . pk is None :
fail _ message = &apos; created&apos;
else :
fail _ message = &apos; changed&apos;
return save _ instance ( self , self . instance , self . _ meta . fields , fail _ message , commit , self . _ meta . exclude , construct = False )
save . alters _ data = True
class ModelForm ( six . with _ metaclass ( ModelFormMetaclass , BaseModelForm ) ) :
pass
def modelform _ factory ( model , form = ModelForm , fields = None , exclude = None , formfield _ callback = None , widgets = None , localized _ fields = None , labels = None , help _ texts = None , error _ messages = None ) :
attrs = { &apos; model &apos; : model }
if fields is not None :
attrs &#91; &apos; fields &apos; &#93; = fields
if exclude is not None :
attrs &#91; &apos; exclude &apos; &#93; = exclude
if widgets is not None :
attrs &#91; &apos; widgets &apos; &#93; = widgets
if localized _ fields is not None :
attrs &#91; &apos; localized _ fields &apos; &#93; = localized _ fields
if labels is not None :
attrs &#91; &apos; labels &apos; &#93; = labels
if help _ texts is not None :
attrs &#91; &apos; help _ texts &apos; &#93; = help _ texts
if error _ messages is not None :
attrs &#91; &apos; error _ messages &apos; &#93; = error _ messages
parent = ( object , )
if hasattr ( form , &apos; Meta &apos; ) :
parent = ( form . meta , object )
meta = type ( str ( &apos; Meta &apos; ) , parent , attrs )
class _ name = model . _ _ name _ _ + str ( &apos; Form &apos; )
form _ class _ attrs = { &apos; Meta &apos; : meta , &apos; formfield _ callback &apos; : formfield _ callback }
if ( getattr ( Meta , &apos; fields &apos; , None ) is None and getattr ( Meta , &apos; exclude &apos; , None ) is None ) :
raise ImproperlyConfigured ( &quot; Calling modelform _ factory without defining &apos; fields &apos; or &quot; &quot; &apos; exclude &apos; explicitly is prohibited . &quot; )
return type ( form ) ( class _ name , ( form , ) , form _ class _ attrs )
class BaseModelFormSet ( BaseFormSet ) :
model = None
def _ _ init _ _ ( self , data = None , files = None , auto _ id = &apos; id _ % s &apos; , prefix = None , queryset = None , * * kwargs ) :
self . queryset = queryset
self . initial _ extra = kwargs . pop ( &apos; initial &apos; , None )
defaults = { &apos; data &apos; : data , &apos; files &apos; : files , &apos; auto _ id &apos; : auto _ id , &apos; prefix &apos; : prefix }
defaults . update ( kwargs )
super ( BaseModelFormSet , self ) . _ _ init _ _ ( * * defaults )
def initial _ form _ count ( self ) :
if not ( self . data or self . files ) :
return len ( self . get _ queryset ( ) )
return super ( BaseModelFormSet , self ) . initial _ form _ count ( )
def _ existing _ object ( self , pk ) :
if not hasattr ( self , &apos; _ object _ dict &apos; ) :
self . _ object _ dict = dict ( ( o . pk , o ) for o in self . get _ queryset ( ) )
return self . _ object _ dict . get ( pk )
def _ get _ to _ python ( self , field ) :
while field . rel is not None :
field = field . rel . get _ related _ field ( )
return field . to _ python
def _ construct _ form ( self , i , * * kwargs ) :
if self . is _ bound and i &lt; self . initial _ form _ count ( ) :
pk _ key = &quot; % s- % s &quot; % ( self . add _ prefix ( i ) , self . model . _ meta . pk . name )
pk = self . data &#91; pk _ key &#93;
pk _ field = self . model . _ meta . pk
to _ python = self . _ get _ to _ python ( pk _ field )
pk = to _ python ( pk )
kwargs &#91; &apos; instance &apos; &#93; = self . _ existing _ object ( pk )
if i &lt; self . initial _ form _ count ( ) and &apos; instance &apos; not in kwargs :
kwargs &#91; &apos; instance &apos; &#93; = self . get _ queryset ( ) &#91; i &#93;
if i &gt; = self . initial _ form _ count ( ) and self . initial _ extra :
try :
kwargs &#91; &apos; initial &apos; &#93; = self . initial _ extra &#91; i - self . initial _ form _ count ( ) &#93;
except IndexError :
pass
return super ( BaseModelFormSet , self ) . _ construct _ form ( i , * * kwargs )
def get _ queryset ( self ) :
if not hasattr ( self , &apos; _ queryset &apos; ) :
if self . queryset is not None :
qs = self . queryset
else :
qs = self . model . _ default _ manager . get _ queryset ( )
if not qs . ordered :
qs = qs . order _ by ( self . model . _ meta . pk . name )
self . _ queryset = qs
return self . _ queryset
def save _ new ( self , form , commit = True ) :
return form . save ( commit = commit )
def save _ existing ( self , form , instance , commit = True ) :
return form . save ( commit = commit )
def save ( self , commit = True ) :
if not commit :
self . saved _ forms = &#91; &#93;
def save _ m2m ( ) :
for form in self . saved _ forms :
form . save _ m2m ( )
self . save _ m2m = save _ m2m
return self . save _ existing _ objects ( commit ) + self . save _ new _ objects ( commit )
save . alters _ data = True
def clean ( self ) :
self . validate _ unique ( )
def validate _ unique ( self ) :
all _ unique _ checks = set ( )
all _ date _ checks = set ( )
forms _ to _ delete = self . deleted _ forms
valid _ forms = &#91; form for form in self . forms if form . is _ valid ( ) and form not in forms _ to _ delete &#93;
for form in valid _ forms :
exclude = form . _ get _ validation _ exclusions ( )
unique _ checks , date _ checks = form . instance . _ get _ unique _ checks ( exclude = exclude )
all _ unique _ checks = all _ unique _ checks . union ( set ( unique _ checks ) )
all _ date _ checks = all _ date _ checks . union ( set ( date _ checks ) )
errors = &#91; &#93;
for uclass , unique _ check in all _ unique _ checks :
seen _ data = set ( )
for form in valid _ forms :
row _ data = ( form . cleaned _ data &#91; field &#93; for field in unique _ check if field in form . cleaned _ data )
row _ data = tuple ( d . _ get _ pk _ val ( ) if hasattr ( d , &apos; _ get _ pk _ val &apos; ) else d for d in row _ data )
if row _ data and None not in row _ data :
if row _ data in seen _ data :
errors . append ( self . get _ unique _ error _ message ( unique _ check ) )
form . _ errors &#91; NON _ FIELD _ ERRORS &#93; = self . error _ class ( &#91; self . get _ form _ error ( ) &#93; )
for field in unique _ check :
if field in form . cleaned _ data :
del form . cleaned _ data &#91; field &#93;
seen _ data . add ( row _ data )
for date _ check in all _ date _ checks :
seen _ data = set ( )
uclass , lookup , field , unique _ for = date _ check
for form in valid _ forms :
if ( form . cleaned _ data and form . cleaned _ data &#91; field &#93; is not None and form . cleaned _ data &#91; unique _ for &#93; is not None ) :
if lookup = = &apos; date &apos; :
date = form . cleaned _ data &#91; unique _ for &#93;
date _ data = ( date . year , date . month , date . day )
else :
date _ data = ( getattr ( form . cleaned _ data &#91; unique _ for &#93; , lookup ) , )
data = ( form . cleaned _ data &#91; field &#93; , ) + date _ data
if data in seen _ data :
errors . append ( self . get _ date _ error _ message ( date _ check ) )
form . _ errors &#91; NON _ FIELD _ ERRORS &#93; = self . error _ class ( &#91; self . get _ form _ error ( ) &#93; )
del form . cleaned _ data &#91; field &#93;
seen _ data . add ( data )
if errors :
raise ValidationError ( errors )
def get _ unique _ error _ message ( self , unique _ check ) :
if len ( unique _ check ) = = 1 :
return ugettext ( &quot; Please correct the duplicate data for % ( field ) s . &quot; ) % { &quot; field &quot; : unique _ check &#91; 0 &#93; , }
else :
return ugettext ( &quot; Please correct the duplicate data for % ( field ) s , &quot; &quot; which must be unique . &quot; ) % { &quot; field &quot; : get _ text _ list ( unique _ check , six . text _ type ( _ ( &quot; and &quot; ) ) ) , }
def get _ date _ error _ message ( self , date _ check ) :
return ugettext ( &quot; Please correct the duplicate data for % ( field _ name ) s &quot; &quot; which must be unique for the % ( lookup ) s in % ( date _ field ) s . &quot; ) % { &apos; field _ name &apos; : date _ check &#91; 2 &#93; , &apos; date _ field &apos; : date _ check &#91; 3 &#93; , &apos; lookup &apos; : six . text _ type ( date _ check &#91; 1 &#93; ) , }
def get _ form _ error ( self ) :
return ugettext ( &quot; Please correct the duplicate values below . &quot; )
def save _ existing _ objects ( self , commit = True ) :
self . changed _ objects = &#91; &#93;
self . deleted _ objects = &#91; &#93;
if not self . initial _ forms :
return &#91; &#93;
saved _ instances = &#91; &#93;
forms _ to _ delete = self . deleted _ forms
for form in self . initial _ forms :
obj = form . instance
if form in forms _ to _ delete :
if obj . pk is None :
continue
self . deleted _ objects . append ( obj )
if commit :
obj . delete ( )
elif form . has _ changed ( ) :
self . changed _ objects . append ( ( obj , form . changed _ data ) )
saved _ instances . append ( self . save _ existing ( form , obj , commit = commit ) )
if not commit :
self . saved _ forms . append ( form )
return saved _ instances
def save _ new _ objects ( self , commit = True ) :
self . new _ objects = &#91; &#93;
for form in self . extra _ forms :
if not form . has _ changed ( ) :
continue
if self . can _ delete and self . _ should _ delete _ form ( form ) :
continue
self . new _ objects . append ( self . save _ new ( form , commit = commit ) )
if not commit :
self . saved _ forms . append ( form )
return self . new _ objects
def add _ fields ( self , form , index ) :
from django . db . models import AutoField , OneToOneField , ForeignKey
self . _ pk _ field = pk = self . model . _ meta . pk
def pk _ is _ not _ editable ( pk ) :
return ( ( not pk . editable ) or ( pk . auto _ created or isinstance ( pk , AutoField ) ) or ( pk . rel and pk . rel . parent _ link and pk _ is _ not _ editable ( pk . rel . to . _ meta . pk ) ) )
if pk _ is _ not _ editable ( pk ) or pk . name not in form . fields :
if form . is _ bound :
pk _ value = form . instance . pk
else :
try :
if index is not None :
pk _ value = self . get _ queryset ( ) &#91; index &#93; . pk
else :
pk _ value = None
except IndexError :
pk _ value = None
if isinstance ( pk , OneToOneField ) or isinstance ( pk , ForeignKey ) :
qs = pk . rel . to . _ default _ manager . get _ queryset ( )
else :
qs = self . model . _ default _ manager . get _ queryset ( )
qs = qs . using ( form . instance . _ state . db )
if form . _ meta . widgets :
widget = form . _ meta . widgets . get ( self . _ pk _ field . name , HiddenInput )
else :
widget = HiddenInput
form . fields &#91; self . _ pk _ field . name &#93; = ModelChoiceField ( qs , initial = pk _ value , required = False , widget = widget )
super ( BaseModelFormSet , self ) . add _ fields ( form , index )
def modelformset _ factory ( model , form = ModelForm , formfield _ callback = None , formset = BaseModelFormSet , extra = 1 , can _ delete = False , can _ order = False , max _ num = None , fields = None , exclude = None , widgets = None , validate _ max = False , localized _ fields = None , labels = None , help _ texts = None , error _ messages = None , min _ num = None , validate _ min = False ) :
meta = getattr ( form , &apos; Meta &apos; , None )
if meta is None :
meta = type ( str ( &apos; Meta &apos; ) , ( object , ) , { } )
if ( getattr ( meta , &apos; fields &apos; , fields ) is None and getattr ( meta , &apos; exclude &apos; , exclude ) is None ) :
raise ImproperlyConfigured ( &quot; Calling modelformset _ factory without defining &apos; fields &apos; or &quot; &quot; &apos; exclude &apos; explicitly is prohibited . &quot; )
form = modelform _ factory ( model , form = form , fields = fields , exclude = exclude , formfield _ callback = formfield _ callback , widgets = widgets , localized _ fields = localized _ fields , labels = labels , help _ texts = help _ texts , error _ messages = error _ messages )
formset = formset _ factory ( form , formset , extra = extra , min _ num = min _ num , max _ num = max _ num , can _ order = can _ order , can _ delete = can _ delete , validate _ min = validate _ min , validate _ max = validate _ max )
formset . model = model
return FormSet
class BaseInlineFormSet ( BaseModelFormSet ) :
def _ _ init _ _ ( self , data = None , files = None , instance = None , save _ as _ new = False , prefix = None , queryset = None , * * kwargs ) :
if instance is None :
self . instance = self . fk . rel . to ( )
else :
self . instance = instance
self . save _ as _ new = save _ as _ new
if queryset is None :
queryset = self . model . _ default _ manager
if self . instance . pk is not None :
qs = queryset . filter ( * * { self . fk . name : self . instance } )
else :
qs = queryset . None ( )
super ( BaseInlineFormSet , self ) . _ _ init _ _ ( data , files , prefix = prefix , queryset = qs , * * kwargs )
def initial _ form _ count ( self ) :
if self . save _ as _ new :
return 0
return super ( BaseInlineFormSet , self ) . initial _ form _ count ( )
def _ construct _ form ( self , i , * * kwargs ) :
form = super ( BaseInlineFormSet , self ) . _ construct _ form ( i , * * kwargs )
if self . save _ as _ new :
form . data &#91; form . add _ prefix ( self . _ pk _ field . name ) &#93; = None
form . data &#91; form . add _ prefix ( self . fk . name ) &#93; = None
setattr ( form . instance , self . fk . get _ attname ( ) , self . instance . pk )
return form
@ classmethod
def get _ default _ prefix ( cls ) :
from django . db . models . fields . related import RelatedObject
return RelatedObject ( cls . fk . rel . to , cls . model , cls . fk ) . get _ accessor _ name ( ) . replace ( &apos; + &apos; , &apos; &apos; )
def save _ new ( self , form , commit = True ) :
obj = form . save ( commit = False )
pk _ value = getattr ( self . instance , self . fk . rel . field _ name )
setattr ( obj , self . fk . get _ attname ( ) , getattr ( pk _ value , &apos; pk &apos; , pk _ value ) )
if commit :
obj . save ( )
if commit and hasattr ( form , &apos; save _ m2m &apos; ) :
form . save _ m2m ( )
return obj
def add _ fields ( self , form , index ) :
super ( BaseInlineFormSet , self ) . add _ fields ( form , index )
if self . _ pk _ field = = self . fk :
name = self . _ pk _ field . name
kwargs = { &apos; pk _ field &apos; : true }
else :
name = self . fk . name
kwargs = { &apos; label &apos; : getattr ( form . fields . get ( name ) , &apos; label &apos; , capfirst ( self . fk . verbose _ name ) ) }
if self . fk . rel . field _ name ! = self . fk . rel . to . _ meta . pk . name :
kwargs &#91; &apos; to _ field &apos; &#93; = self . fk . rel . field _ name
form . fields &#91; name &#93; = InlineForeignKeyField ( self . instance , * * kwargs )
if form . _ meta . fields :
if isinstance ( form . _ meta . fields , tuple ) :
form . _ meta . fields = list ( form . _ meta . fields )
form . _ meta . fields . append ( self . fk . name )
def get _ unique _ error _ message ( self , unique _ check ) :
unique _ check = &#91; field for field in unique _ check if field ! = self . fk . name &#93;
return super ( BaseInlineFormSet , self ) . get _ unique _ error _ message ( unique _ check )
def _ get _ foreign _ key ( parent _ model , model , fk _ name = None , can _ fail = False ) :
from django . db . models import ForeignKey
opts = model . _ meta
if fk _ name :
fks _ to _ parent = &#91; f for f in opts . fields if f . name = = fk _ name &#93;
if len ( fks _ to _ parent ) = = 1 :
fk = fks _ to _ parent &#91; 0 &#93;
if not isinstance ( fk , ForeignKey ) or ( fk . rel . to ! = parent _ model and fk . rel . to not in parent _ model . _ meta . get _ parent _ list ( ) ) :
raise ValueError ( &quot; fk _ name &apos; % s &apos; is not a ForeignKey to &apos; % s . % &apos; . &quot; % ( fk _ name , parent _ model . _ meta . app _ label , parent _ model . _ meta . object _ name ) )
elif len ( fks _ to _ parent ) = = 0 :
raise ValueError ( &quot; &apos; % s . % s &apos; has no field named &apos; % s &apos; . &quot; % ( model . _ meta . app _ label , model . _ meta . object _ name , fk _ name ) )
else :
fks _ to _ parent = &#91; f for f in opts . fields if isinstance ( f , ForeignKey ) and ( f . rel . to = = parent _ model or f . rel . to in parent _ model . _ meta . get _ parent _ list ( ) ) &#93;
if len ( fks _ to _ parent ) = = 1 :
fk = fks _ to _ parent &#91; 0 &#93;
elif len ( fks _ to _ parent ) = = 0 :
if can _ fail :
return
raise ValueError ( &quot; &apos; % s . % s &apos; has no ForeignKey to &apos; % s . % s &apos; . &quot; % ( model . _ meta . app _ label , model . _ meta . object _ name , parent _ model . _ meta . app _ label , parent _ model . _ meta . object _ name ) )
else :
raise ValueError ( &quot; &apos; % s . % s &apos; has more than one ForeignKey to &apos; % s . % s &apos; . &quot; % ( model . _ meta . app _ label , model . _ meta . object _ name , parent _ model . _ meta . app _ label , parent _ model . _ meta . object _ name ) )
return fk
def inlineformset _ factory ( parent _ model , model , form = ModelForm , formset = BaseInlineFormSet , fk _ name = None , fields = None , exclude = None , extra = 3 , can _ order = False , can _ delete = True , max _ num = None , formfield _ callback = None , widgets = None , validate _ max = False , localized _ fields = None , labels = None , help _ texts = None , error _ messages = None , min _ num = None , validate _ min = False ) :
fk = _ get _ foreign _ key ( parent _ model , model , fk _ name = fk _ name )
if fk . unique :
max _ num = 1
kwargs = { &apos; form &apos; : form , &apos; formfield _ callback &apos; : formfield _ callback , &apos; formset &apos; : formset , &apos; extra &apos; : extra , &apos; can _ delete &apos; : can _ delete , &apos; can _ order &apos; : can _ order , &apos; fields &apos; : fields , &apos; exclude &apos; : exclude , &apos; min _ num &apos; : min _ num , &apos; max _ num &apos; : max _ num , &apos; widgets &apos; : widgets , &apos; validate _ min &apos; : validate _ min , &apos; validate _ max &apos; : validate _ max , &apos; localized _ fields &apos; : localized _ fields , &apos; labels &apos; : labels , &apos; help _ texts &apos; : help _ texts , &apos; error _ messages &apos; : error _ messages , }
formset = modelformset _ factory ( model , * * kwargs )
formset . fk = fk
return FormSet
class InlineForeignKeyField ( Field ) :
widget = HiddenInput
default _ error _ messages = { &apos; invalid _ choice &apos; : _ ( &apos; The inline foreign key did not match the parent instance primary key . &apos; ) , }
def _ _ init _ _ ( self , parent _ instance , * args , * * kwargs ) :
self . parent _ instance = parent _ instance
self . pk _ field = kwargs . pop ( &quot; pk _ field &quot; , False )
self . to _ field = kwargs . pop ( &quot; to _ field &quot; , None )
if self . parent _ instance is not None :
if self . to _ field :
kwargs &#91; &quot; initial &quot; &#93; = getattr ( self . parent _ instance , self . to _ field )
else :
kwargs &#91; &quot; initial &quot; &#93; = self . parent _ instance . pk
kwargs &#91; &quot; required &quot; &#93; = False
super ( InlineForeignKeyField , self ) . _ _ init _ _ ( * args , * * kwargs )
def clean ( self , value ) :
if value in self . empty _ values :
if self . pk _ field :
return None
return self . parent _ instance
if self . to _ field :
orig = getattr ( self . parent _ instance , self . to _ field )
else :
orig = self . parent _ instance . pk
if force _ text ( value ) ! = force _ text ( orig ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ choice &apos; &#93; , code = &apos; invalid _ choice &apos; )
return self . parent _ instance
def _ has _ changed ( self , initial , data ) :
return False
class ModelChoiceIterator ( object ) :
def _ _ init _ _ ( self , field ) :
self . field = field
self . queryset = field . queryset
def _ _ iter _ _ ( self ) :
if self . field . empty _ label is not None :
yield ( &quot; &quot; , self . field . empty _ label )
if self . field . cache _ choices :
if self . field . choice _ cache is None :
self . field . choice _ cache = &#91; self . choice ( obj ) for obj in self . queryset . all ( ) &#93;
for choice in self . field . choice _ cache :
yield choice
else :
for obj in self . queryset . all ( ) :
yield self . choice ( obj )
def _ _ len _ _ ( self ) :
return ( len ( self . queryset ) + ( 1 if self . field . empty _ label is not None else 0 ) )
def choice ( self , obj ) :
return ( self . field . prepare _ value ( obj ) , self . field . label _ from _ instance ( obj ) )
class ModelChoiceField ( ChoiceField ) :
default _ error _ messages = { &apos; invalid _ choice &apos; : _ ( &apos; Select a valid choice . that choice is not one of &apos; &apos; the available choices . &apos; ) , }
def _ _ init _ _ ( self , queryset , empty _ label = &quot; --------- &quot; , cache _ choices = None , required = True , widget = None , label = None , initial = None , help _ text = &apos; &apos; , to _ field _ name = None , limit _ choices _ to = None , * args , * * kwargs ) :
if required and ( initial is not None ) :
self . empty _ label = None
else :
self . empty _ label = empty _ label
if cache _ choices is not None :
warnings . warn ( &quot; cache _ choices has been deprecated and will be &quot; &quot; removed in Django 1.9 . &quot; , RemovedInDjango19Warning , stacklevel = 2 )
else :
cache _ choices = False
self . cache _ choices = cache _ choices
field . _ _ init _ _ ( self , required , widget , label , initial , help _ text , * args , * * kwargs )
self . queryset = queryset
self . limit _ choices _ to = limit _ choices _ to
self . choice _ cache = None
self . to _ field _ name = to _ field _ name
def _ _ deepcopy _ _ ( self , memo ) :
result = super ( ChoiceField , self ) . _ _ deepcopy _ _ ( memo )
result . queryset = result . queryset
return result
def _ get _ queryset ( self ) :
return self . _ queryset
def _ set _ queryset ( self , queryset ) :
self . _ queryset = queryset
self . widget . choices = self . choices
queryset = property ( _ get _ queryset , _ set _ queryset )
def label _ from _ instance ( self , obj ) :
return smart _ text ( obj )
def _ get _ choices ( self ) :
if hasattr ( self , &apos; _ choices &apos; ) :
return self . _ choices
return ModelChoiceIterator ( self )
choices = property ( _ get _ choices , ChoiceField . _ set _ choices )
def prepare _ value ( self , value ) :
if hasattr ( value , &apos; _ meta &apos; ) :
if self . to _ field _ name :
return value . serializable _ value ( self . to _ field _ name )
else :
return value . pk
return super ( ModelChoiceField , self ) . prepare _ value ( value )
def to _ python ( self , value ) :
if value in self . empty _ values :
return None
try :
key = self . to _ field _ name or &apos; pk&apos;
value = self . queryset . get ( * * { key : value } )
except ( ValueError , self . queryset . model . DoesNotExist ) :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ choice &apos; &#93; , code = &apos; invalid _ choice &apos; )
return value
def validate ( self , value ) :
return Field . validate ( self , value )
def _ has _ changed ( self , initial , data ) :
initial _ value = initial if initial is not None else &apos; &apos;
data _ value = data if data is not None else &apos; &apos;
return force _ text ( self . prepare _ value ( initial _ value ) ) ! = force _ text ( data _ value )
class ModelMultipleChoiceField ( ModelChoiceField ) :
widget = SelectMultiple
hidden _ widget = MultipleHiddenInput
default _ error _ messages = { &apos; list &apos; : _ ( &apos; Enter a list of values . &apos; ) , &apos; invalid _ choice &apos; : _ ( &apos; Select a valid choice . % ( value ) s is not one of the &apos; &apos; available choices . &apos; ) , &apos; invalid _ pk _ value &apos; : _ ( &apos; &quot; % ( pk ) s &quot; is not a valid value for a primary key . &apos; ) }
def _ _ init _ _ ( self , queryset , cache _ choices = None , required = True , widget = None , label = None , initial = None , help _ text = &apos; &apos; , * args , * * kwargs ) :
super ( ModelMultipleChoiceField , self ) . _ _ init _ _ ( queryset , None , cache _ choices , required , widget , label , initial , help _ text , * args , * * kwargs )
def to _ python ( self , value ) :
if not value :
return &#91; &#93;
to _ py = super ( ModelMultipleChoiceField , self ) . to _ python
return &#91; to _ py ( val ) for val in value &#93;
def clean ( self , value ) :
if self . required and not value :
raise ValidationError ( self . error _ messages &#91; &apos; required &apos; &#93; , code = &apos; required &apos; )
elif not self . required and not value :
return self . queryset . None ( )
if not isinstance ( value , ( list , tuple ) ) :
raise ValidationError ( self . error _ messages &#91; &apos; list &apos; &#93; , code = &apos; list &apos; )
key = self . to _ field _ name or &apos; pk&apos;
for pk in value :
try :
self . queryset . filter ( * * { key : pk } )
except ValueError :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ pk _ value &apos; &#93; , code = &apos; invalid _ pk _ value &apos; , params = { &apos; pk &apos; : pk } , )
qs = self . queryset . filter ( * * { &apos; % s _ _ in &apos; % key : value } )
pks = set ( force _ text ( getattr ( o , key ) ) for o in qs )
for val in value :
if force _ text ( val ) not in pks :
raise ValidationError ( self . error _ messages &#91; &apos; invalid _ choice &apos; &#93; , code = &apos; invalid _ choice &apos; , params = { &apos; value &apos; : val } , )
self . run _ validators ( value )
return qs
def prepare _ value ( self , value ) :
if ( hasattr ( value , &apos; _ _ iter _ _ &apos; ) and not isinstance ( value , six . text _ type ) and not hasattr ( value , &apos; _ meta &apos; ) ) :
return &#91; super ( ModelMultipleChoiceField , self ) . prepare _ value ( v ) for v in value &#93;
return super ( ModelMultipleChoiceField , self ) . prepare _ value ( value )
def _ has _ changed ( self , initial , data ) :
if initial is None :
initial = &#91; &#93;
if data is None :
data = &#91; &#93;
if len ( initial ) ! = len ( data ) :
return True
initial _ set = set ( force _ text ( value ) for value in self . prepare _ value ( initial ) )
data _ set = set ( force _ text ( value ) for value in data )
return data _ set ! = initial _ set
def modelform _ defines _ fields ( form _ class ) :
return ( form _ class is not None and ( hasattr ( form _ class , &apos; _ meta &apos; ) and ( form _ class . _ meta . fields is not None or form _ class . _ meta . exclude is not None ) ) )
import warnings
from django . utils . deprecation import RemovedInDjango19Warning
warnings . warn ( &quot; The django.forms.util module has been renamed . &quot; &quot; use django.forms.utils instead . &quot; , RemovedInDjango19Warning , stacklevel = 2 )
from django . forms . utils import *
from _ _ future _ _ import unicode _ literals
import json
import sys
try :
from collections import UserList
except ImportError :
from UserList import UserList
from django . conf import settings
from django . utils . encoding import force _ text , python _ 2 _ unicode _ compatible
from django . utils . html import format _ html , format _ html _ join , escape
from django . utils import timezone
from django . utils . translation import ugettext _ lazy as _
from django . utils import six
from django . core . exceptions import ValidationError
def flatatt ( attrs ) :
boolean _ attrs = &#91; &#93;
for attr , value in list ( attrs . items ( ) ) :
if value is True :
boolean _ attrs . append ( ( attr , ) )
del attrs &#91; attr &#93;
elif value is False :
del attrs &#91; attr &#93;
return ( format _ html _ join ( &apos; &apos; , &apos; { 0 } = &quot; { 1 } &quot; &apos; , sorted ( attrs . items ( ) ) ) + format _ html _ join ( &apos; &apos; , &apos; { 0 } &apos; , sorted ( boolean _ attrs ) ) )
@ python _ 2 _ unicode _ compatible
class ErrorDict ( dict ) :
def as _ data ( self ) :
return { f : e . as _ data ( ) for f , e in self . items ( ) }
def as _ json ( self , escape _ html = False ) :
return json . dumps ( { f : e . get _ json _ data ( escape _ html ) for f , e in self . items ( ) } )
def as _ ul ( self ) :
if not self :
return &apos; &apos;
return format _ html ( &apos; &lt; ul class = &quot; errorlist &quot; &gt; { 0 } &lt; / ul &gt; &apos; , format _ html _ join ( &apos; &apos; , &apos; &lt; li &gt; { 0 } { 1 } &lt; / li &gt; &apos; , ( ( k , force _ text ( v ) ) for k , v in self . items ( ) ) ) )
def as _ text ( self ) :
output = &#91; &#93;
for field , errors in self . items ( ) :
output . append ( &apos; * % s &apos; % field )
output . append ( &apos; \ n &apos; . join ( &apos; * % s &apos; % e for e in errors ) )
return &apos; \ n &apos; . join ( output )
def _ _ str _ _ ( self ) :
return self . as _ ul ( )
@ python _ 2 _ unicode _ compatible
class ErrorList ( UserList , list ) :
def _ _ init _ _ ( self , initlist = None , error _ class = None ) :
super ( ErrorList , self ) . _ _ init _ _ ( initlist )
if error _ class is None :
self . error _ class = &apos; errorlist&apos;
else :
self . error _ class = &apos; errorlist { } &apos; . format ( error _ class )
def as _ data ( self ) :
return ValidationError ( self . data ) . error _ list
def get _ json _ data ( self , escape _ html = False ) :
errors = &#91; &#93;
for error in self . as _ data ( ) :
message = list ( error ) &#91; 0 &#93;
errors . append ( { &apos; message &apos; : escape ( message ) if escape _ html else message , &apos; code &apos; : error . code or &apos; &apos; , } )
return errors
def as _ json ( self , escape _ html = False ) :
return json . dumps ( self . get _ json _ data ( escape _ html ) )
def as _ ul ( self ) :
if not self . data :
return &apos; &apos;
return format _ html ( &apos; &lt; ul class = &quot; { 0 } &quot; &gt; { 1 } &lt; / ul &gt; &apos; , self . error _ class , format _ html _ join ( &apos; &apos; , &apos; &lt; li &gt; { 0 } &lt; / li &gt; &apos; , ( ( force _ text ( e ) , ) for e in self ) ) )
def as _ text ( self ) :
return &apos; \ n &apos; . join ( &apos; * % s &apos; % e for e in self )
def _ _ str _ _ ( self ) :
return self . as _ ul ( )
def _ _ repr _ _ ( self ) :
return repr ( list ( self ) )
def _ _ contains _ _ ( self , item ) :
return item in list ( self )
def _ _ eq _ _ ( self , other ) :
return list ( self ) = = other
def _ _ ne _ _ ( self , other ) :
return list ( self ) ! = other
def _ _ getitem _ _ ( self , i ) :
error = self . data &#91; i &#93;
if isinstance ( error , ValidationError ) :
return list ( error ) &#91; 0 &#93;
return force _ text ( error )
def from _ current _ timezone ( value ) :
if settings . use _ TZ and value is not None and timezone . is _ naive ( value ) :
current _ timezone = timezone . get _ current _ timezone ( )
try :
return timezone . make _ aware ( value , current _ timezone )
except Exception :
message = _ ( &apos; % ( datetime ) s couldn \ &apos; t be interpreted &apos; &apos; in time zone % ( current _ timezone ) s ; it &apos; &apos; may be ambiguous or it may not exist . &apos; )
params = { &apos; datetime &apos; : value , &apos; current _ timezone &apos; : current _ timezone }
six . reraise ( ValidationError , ValidationError ( message , code = &apos; ambiguous _ timezone &apos; , params = params , ) , sys . exc _ info ( ) &#91; 2 &#93; )
return value
def to _ current _ timezone ( value ) :
if settings . use _ TZ and value is not None and timezone . is _ aware ( value ) :
current _ timezone = timezone . get _ current _ timezone ( )
return timezone . make _ naive ( value , current _ timezone )
return value
from _ _ future _ _ import unicode _ literals
import copy
from itertools import chain
from django . conf import settings
from django . forms . utils import flatatt , to _ current _ timezone
from django . utils . datastructures import MultiValueDict , MergeDict
from django . utils . encoding import force _ text , python _ 2 _ unicode _ compatible
from django . utils . html import conditional _ escape , format _ html
from django . utils . translation import ugettext _ lazy
from django . utils . SafeString import mark _ safe
from django . utils import formats , six
from django . utils . six . moves . urllib . parse import urljoin
_ _ all _ _ = ( &apos; Media &apos; , &apos; MediaDefiningClass &apos; , &apos; Widget &apos; , &apos; TextInput &apos; , &apos; EmailInput &apos; , &apos; URLInput &apos; , &apos; NumberInput &apos; , &apos; PasswordInput &apos; , &apos; HiddenInput &apos; , &apos; MultipleHiddenInput &apos; , &apos; ClearableFileInput &apos; , &apos; FileInput &apos; , &apos; DateInput &apos; , &apos; DateTimeInput &apos; , &apos; TimeInput &apos; , &apos; Textarea &apos; , &apos; CheckboxInput &apos; , &apos; Select &apos; , &apos; NullBooleanSelect &apos; , &apos; SelectMultiple &apos; , &apos; RadioSelect &apos; , &apos; CheckboxSelectMultiple &apos; , &apos; MultiWidget &apos; , &apos; SplitDateTimeWidget &apos; , &apos; SplitHiddenDateTimeWidget &apos; , )
media _ TYPES = ( &apos; css &apos; , &apos; js &apos; )
@ python _ 2 _ unicode _ compatible
class Media ( object ) :
def _ _ init _ _ ( self , media = None , * * kwargs ) :
if media :
media _ attrs = media . _ _ dict _ _
else :
media _ attrs = kwargs
self . _ css = { }
self . _ js = &#91; &#93;
for name in MEDIA _ TYPES :
getattr ( self , &apos; add _ &apos; + name ) ( media _ attrs . get ( name , None ) )
def _ _ str _ _ ( self ) :
return self . render ( )
def render ( self ) :
return mark _ safe ( &apos; \ n &apos; . join ( chain ( * &#91; getattr ( self , &apos; render _ &apos; + name ) ( ) for name in MEDIA _ TYPES &#93; ) ) )
def render _ js ( self ) :
return &#91; format _ html ( &apos; &lt; script type = &quot; text / javascript &quot; src = &quot; { 0 } &quot; &gt; &lt; / script &gt; &apos; , self . absolute _ path ( path ) ) for path in self . _ js &#93;
def render _ css ( self ) :
media = sorted ( self . _ css . keys ( ) )
return chain ( * &#91; &#91; format _ html ( &apos; &lt; link href = &quot; { 0 } &quot; type = &quot; text / css &quot; media = &quot; { 1 } &quot; rel = &quot; stylesheet &quot; / &gt; &apos; , self . absolute _ path ( path ) , medium ) for path in self . _ css &#91; medium &#93; &#93; for medium in media &#93; )
def absolute _ path ( self , path , prefix = None ) :
if path . startswith ( ( &apos; http : / / &apos; , &apos; https : / / &apos; , &apos; / &apos; ) ) :
return path
if prefix is None :
if settings . static _ URL is None :
prefix = settings . media _ URL
else :
prefix = settings . static _ URL
return urljoin ( prefix , path )
def _ _ getitem _ _ ( self , name ) :
if name in MEDIA _ TYPES :
return Media ( * * { str ( name ) : getattr ( self , &apos; _ &apos; + name ) } )
raise KeyError ( &apos; Unknown media type &quot; % s &quot; &apos; % name )
def add _ js ( self , data ) :
if data :
for path in data :
if path not in self . _ js :
self . _ js . append ( path )
def add _ css ( self , data ) :
if data :
for medium , paths in data . items ( ) :
for path in paths :
if not self . _ css . get ( medium ) or path not in self . _ css &#91; medium &#93; :
self . _ css . setdefault ( medium , &#91; &#93; ) . append ( path )
def _ _ add _ _ ( self , other ) :
combined = Media ( )
for name in MEDIA _ TYPES :
getattr ( combined , &apos; add _ &apos; + name ) ( getattr ( self , &apos; _ &apos; + name , None ) )
getattr ( combined , &apos; add _ &apos; + name ) ( getattr ( other , &apos; _ &apos; + name , None ) )
return combined
def media _ property ( cls ) :
def _ media ( self ) :
sup _ cls = super ( cls , self )
try :
base = sup _ cls . media
except AttributeError :
base = Media ( )
definition = getattr ( cls , &apos; Media &apos; , None )
if definition :
extend = getattr ( definition , &apos; extend &apos; , True )
if extend :
if extend is True :
m = base
else :
m = Media ( )
for medium in extend :
m = m + base &#91; medium &#93;
return m + Media ( definition )
else :
return Media ( definition )
else :
return base
return property ( _ media )
class MediaDefiningClass ( type ) :
def _ _ new _ _ ( mcs , name , bases , attrs ) :
new _ class = ( super ( MediaDefiningClass , mcs ) . _ _ new _ _ ( mcs , name , bases , attrs ) )
if &apos; media &apos; not in attrs :
new _ class . media = media _ property ( new _ class )
return new _ class
@ python _ 2 _ unicode _ compatible
class SubWidget ( object ) :
def _ _ init _ _ ( self , parent _ widget , name , value , attrs , choices ) :
self . parent _ widget = parent _ widget
self . name , self . value = name , value
self . attrs , self . choices = attrs , choices
def _ _ str _ _ ( self ) :
args = &#91; self . name , self . value , self . attrs &#93;
if self . choices :
args . append ( self . choices )
return self . parent _ widget . render ( * args )
class Widget ( six . with _ metaclass ( MediaDefiningClass ) ) :
needs _ multipart _ form = False
is _ localized = False
is _ required = False
def _ _ init _ _ ( self , attrs = None ) :
if attrs is not None :
self . attrs = attrs . copy ( )
else :
self . attrs = { }
def _ _ deepcopy _ _ ( self , memo ) :
obj = copy . copy ( self )
obj . attrs = self . attrs . copy ( )
memo &#91; id ( self ) &#93; = obj
return obj
@ property
def is _ hidden ( self ) :
return self . input _ type = = &apos; hidden &apos; if hasattr ( self , &apos; input _ type &apos; ) else False
def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :
yield SubWidget ( self , name , value , attrs , choices )
def render ( self , name , value , attrs = None ) :
raise NotImplementedError ( &apos; subclasses of Widget must provide a render ( ) method &apos; )
def build _ attrs ( self , extra _ attrs = None , * * kwargs ) :
attrs = dict ( self . attrs , * * kwargs )
if extra _ attrs :
attrs . update ( extra _ attrs )
return attrs
def value _ from _ datadict ( self , data , files , name ) :
return data . get ( name , None )
def id _ for _ label ( self , id _ ) :
return id _
class Input ( Widget ) :
input _ type = None
def _ format _ value ( self , value ) :
if self . is _ localized :
return formats . localize _ input ( value )
return value
def render ( self , name , value , attrs = None ) :
if value is None :
value = &apos; &apos;
final _ attrs = self . build _ attrs ( attrs , type = self . input _ type , name = name )
if value ! = &apos; &apos; :
final _ attrs &#91; &apos; value &apos; &#93; = force _ text ( self . _ format _ value ( value ) )
return format _ html ( &apos; &lt; input { 0 } / &gt; &apos; , flatatt ( final _ attrs ) )
class TextInput ( Input ) :
input _ type = &apos; text&apos;
def _ _ init _ _ ( self , attrs = None ) :
if attrs is not None :
self . input _ type = attrs . pop ( &apos; type &apos; , self . input _ type )
super ( TextInput , self ) . _ _ init _ _ ( attrs )
class NumberInput ( TextInput ) :
input _ type = &apos; number&apos;
class EmailInput ( TextInput ) :
input _ type = &apos; email&apos;
class URLInput ( TextInput ) :
input _ type = &apos; url&apos;
class PasswordInput ( TextInput ) :
input _ type = &apos; password&apos;
def _ _ init _ _ ( self , attrs = None , render _ value = False ) :
super ( PasswordInput , self ) . _ _ init _ _ ( attrs )
self . render _ value = render _ value
def render ( self , name , value , attrs = None ) :
if not self . render _ value :
value = None
return super ( PasswordInput , self ) . render ( name , value , attrs )
class HiddenInput ( Input ) :
input _ type = &apos; hidden&apos;
class MultipleHiddenInput ( HiddenInput ) :
def _ _ init _ _ ( self , attrs = None , choices = ( ) ) :
super ( MultipleHiddenInput , self ) . _ _ init _ _ ( attrs )
self . choices = choices
def render ( self , name , value , attrs = None , choices = ( ) ) :
if value is None :
value = &#91; &#93;
final _ attrs = self . build _ attrs ( attrs , type = self . input _ type , name = name )
id _ = final _ attrs . get ( &apos; id &apos; , None )
inputs = &#91; &#93;
for i , v in enumerate ( value ) :
input _ attrs = dict ( value = force _ text ( v ) , * * final _ attrs )
if id _ :
input _ attrs &#91; &apos; id &apos; &#93; = &apos; % s _ % s &apos; % ( id _ , i )
inputs . append ( format _ html ( &apos; &lt; input { 0 } / &gt; &apos; , flatatt ( input _ attrs ) ) )
return mark _ safe ( &apos; \ n &apos; . join ( inputs ) )
def value _ from _ datadict ( self , data , files , name ) :
if isinstance ( data , ( MultiValueDict , MergeDict ) ) :
return data . getlist ( name )
return data . get ( name , None )
class FileInput ( Input ) :
input _ type = &apos; file&apos;
needs _ multipart _ form = True
def render ( self , name , value , attrs = None ) :
return super ( FileInput , self ) . render ( name , None , attrs = attrs )
def value _ from _ datadict ( self , data , files , name ) :
return files . get ( name , None )
file _ INPUT _ CONTRADICTION = object ( )
class ClearableFileInput ( FileInput ) :
initial _ text = ugettext _ lazy ( &apos; Currently &apos; )
input _ text = ugettext _ lazy ( &apos; Change &apos; )
clear _ checkbox _ label = ugettext _ lazy ( &apos; Clear &apos; )
template _ with _ initial = &apos; % ( initial _ text ) s : % ( initial ) s % ( clear _ template ) s &lt; br / &gt; % ( input _ text ) s : % ( input ) s&apos;
template _ with _ clear = &apos; % ( clear ) s &lt; label for = &quot; % ( clear _ checkbox _ id ) s &quot; &gt; % ( clear _ checkbox _ label ) s &lt; / label &gt; &apos;
url _ markup _ template = &apos; &lt; a href = &quot; { 0 } &quot; &gt; { 1 } &lt; / a &gt; &apos;
def clear _ checkbox _ name ( self , name ) :
return name + &apos; -clear&apos;
def clear _ checkbox _ id ( self , name ) :
return name + &apos; _ id&apos;
def render ( self , name , value , attrs = None ) :
substitutions = { &apos; initial _ text &apos; : self . initial _ text , &apos; input _ text &apos; : self . input _ text , &apos; clear _ template &apos; : &apos; &apos; , &apos; clear _ checkbox _ label &apos; : self . clear _ checkbox _ label , }
template = &apos; % ( input ) s&apos;
substitutions &#91; &apos; input &apos; &#93; = super ( ClearableFileInput , self ) . render ( name , value , attrs )
if value and hasattr ( value , &quot; url &quot; ) :
template = self . template _ with _ initial
substitutions &#91; &apos; initial &apos; &#93; = format _ html ( self . url _ markup _ template , value . url , force _ text ( value ) )
if not self . is _ required :
checkbox _ name = self . clear _ checkbox _ name ( name )
checkbox _ id = self . clear _ checkbox _ id ( checkbox _ name )
substitutions &#91; &apos; clear _ checkbox _ name &apos; &#93; = conditional _ escape ( checkbox _ name )
substitutions &#91; &apos; clear _ checkbox _ id &apos; &#93; = conditional _ escape ( checkbox _ id )
substitutions &#91; &apos; clear &apos; &#93; = CheckboxInput ( ) . render ( checkbox _ name , False , attrs = { &apos; id &apos; : checkbox _ id } )
substitutions &#91; &apos; clear _ template &apos; &#93; = self . template _ with _ clear % substitutions
return mark _ safe ( template % substitutions )
def value _ from _ datadict ( self , data , files , name ) :
upload = super ( ClearableFileInput , self ) . value _ from _ datadict ( data , files , name )
if not self . is _ required and CheckboxInput ( ) . value _ from _ datadict ( data , files , self . clear _ checkbox _ name ( name ) ) :
if upload :
return FILE _ INPUT _ CONTRADICTION
return False
return upload
class Textarea ( Widget ) :
def _ _ init _ _ ( self , attrs = None ) :
default _ attrs = { &apos; cols &apos; : &apos; 40 &apos; , &apos; rows &apos; : &apos; 10 &apos; }
if attrs :
default _ attrs . update ( attrs )
super ( Textarea , self ) . _ _ init _ _ ( default _ attrs )
def render ( self , name , value , attrs = None ) :
if value is None :
value = &apos; &apos;
final _ attrs = self . build _ attrs ( attrs , name = name )
return format _ html ( &apos; &lt; textarea { 0 } &gt; \ r \ n { 1 } &lt; / textarea &gt; &apos; , flatatt ( final _ attrs ) , force _ text ( value ) )
class DateTimeBaseInput ( TextInput ) :
format _ key = &apos; &apos;
supports _ microseconds = False
def _ _ init _ _ ( self , attrs = None , format = None ) :
super ( DateTimeBaseInput , self ) . _ _ init _ _ ( attrs )
self . format = format if format else None
def _ format _ value ( self , value ) :
return formats . localize _ input ( value , self . format or formats . get _ format ( self . format _ key ) &#91; 0 &#93; )
class DateInput ( DateTimeBaseInput ) :
format _ key = &apos; DATE _ INPUT _ FORMATS&apos;
class DateTimeInput ( DateTimeBaseInput ) :
format _ key = &apos; DATETIME _ INPUT _ FORMATS&apos;
class TimeInput ( DateTimeBaseInput ) :
format _ key = &apos; TIME _ INPUT _ FORMATS&apos;
def boolean _ check ( v ) :
return not ( v is False or v is None or v = = &apos; &apos; )
class CheckboxInput ( Widget ) :
def _ _ init _ _ ( self , attrs = None , check _ test = None ) :
super ( CheckboxInput , self ) . _ _ init _ _ ( attrs )
self . check _ test = boolean _ check if check _ test is None else check _ test
def render ( self , name , value , attrs = None ) :
final _ attrs = self . build _ attrs ( attrs , type = &apos; checkbox &apos; , name = name )
if self . check _ test ( value ) :
final _ attrs &#91; &apos; checked &apos; &#93; = &apos; checked&apos;
if not ( value is True or value is False or value is None or value = = &apos; &apos; ) :
final _ attrs &#91; &apos; value &apos; &#93; = force _ text ( value )
return format _ html ( &apos; &lt; input { 0 } / &gt; &apos; , flatatt ( final _ attrs ) )
def value _ from _ datadict ( self , data , files , name ) :
if name not in data :
return False
value = data . get ( name )
values = { &apos; true &apos; : true , &apos; false &apos; : False }
if isinstance ( value , six . string _ types ) :
value = values . get ( value . lower ( ) , value )
return bool ( value )
class Select ( Widget ) :
allow _ multiple _ selected = False
def _ _ init _ _ ( self , attrs = None , choices = ( ) ) :
super ( Select , self ) . _ _ init _ _ ( attrs )
self . choices = list ( choices )
def render ( self , name , value , attrs = None , choices = ( ) ) :
if value is None :
value = &apos; &apos;
final _ attrs = self . build _ attrs ( attrs , name = name )
output = &#91; format _ html ( &apos; &lt; select { 0 } &gt; &apos; , flatatt ( final _ attrs ) ) &#93;
options = self . render _ options ( choices , &#91; value &#93; )
if options :
output . append ( options )
output . append ( &apos; &lt; / select &gt; &apos; )
return mark _ safe ( &apos; \ n &apos; . join ( output ) )
def render _ option ( self , selected _ choices , option _ value , option _ label ) :
if option _ value is None :
option _ value = &apos; &apos;
option _ value = force _ text ( option _ value )
if option _ value in selected _ choices :
selected _ html = mark _ safe ( &apos; selected = &quot; selected &quot; &apos; )
if not self . allow _ multiple _ selected :
selected _ choices . remove ( option _ value )
else :
selected _ html = &apos; &apos;
return format _ html ( &apos; &lt; option value = &quot; { 0 } &quot; { 1 } &gt; { 2 } &lt; / option &gt; &apos; , option _ value , selected _ html , force _ text ( option _ label ) )
def render _ options ( self , choices , selected _ choices ) :
selected _ choices = set ( force _ text ( v ) for v in selected _ choices )
output = &#91; &#93;
for option _ value , option _ label in chain ( self . choices , choices ) :
if isinstance ( option _ label , ( list , tuple ) ) :
output . append ( format _ html ( &apos; &lt; optgroup label = &quot; { 0 } &quot; &gt; &apos; , force _ text ( option _ value ) ) )
for option in option _ label :
output . append ( self . render _ option ( selected _ choices , * option ) )
output . append ( &apos; &lt; / optgroup &gt; &apos; )
else :
output . append ( self . render _ option ( selected _ choices , option _ value , option _ label ) )
return &apos; \ n &apos; . join ( output )
class NullBooleanSelect ( Select ) :
def _ _ init _ _ ( self , attrs = None ) :
choices = ( ( &apos; 1&apos; , ugettext _ lazy ( &apos; Unknown &apos; ) ) , ( &apos; 2&apos; , ugettext _ lazy ( &apos; Yes &apos; ) ) , ( &apos; 3&apos; , ugettext _ lazy ( &apos; No &apos; ) ) )
super ( NullBooleanSelect , self ) . _ _ init _ _ ( attrs , choices )
def render ( self , name , value , attrs = None , choices = ( ) ) :
try :
value = { True : &apos; 2&apos; , False : &apos; 3&apos; , &apos; 2&apos; : &apos; 2&apos; , &apos; 3&apos; : &apos; 3&apos; } &#91; value &#93;
except KeyError :
value = &apos; 1&apos;
return super ( NullBooleanSelect , self ) . render ( name , value , attrs , choices )
def value _ from _ datadict ( self , data , files , name ) :
value = data . get ( name , None )
return { &apos; 2&apos; : true , True : true , &apos; True &apos; : true , &apos; 3&apos; : False , &apos; False &apos; : False , False : False } . get ( value , None )
class SelectMultiple ( Select ) :
allow _ multiple _ selected = True
def render ( self , name , value , attrs = None , choices = ( ) ) :
if value is None :
value = &#91; &#93;
final _ attrs = self . build _ attrs ( attrs , name = name )
output = &#91; format _ html ( &apos; &lt; select multiple = &quot; multiple &quot; { 0 } &gt; &apos; , flatatt ( final _ attrs ) ) &#93;
options = self . render _ options ( choices , value )
if options :
output . append ( options )
output . append ( &apos; &lt; / select &gt; &apos; )
return mark _ safe ( &apos; \ n &apos; . join ( output ) )
def value _ from _ datadict ( self , data , files , name ) :
if isinstance ( data , ( MultiValueDict , MergeDict ) ) :
return data . getlist ( name )
return data . get ( name , None )
@ python _ 2 _ unicode _ compatible
class ChoiceInput ( SubWidget ) :
input _ type = None
def _ _ init _ _ ( self , name , value , attrs , choice , index ) :
self . name = name
self . value = value
self . attrs = attrs
self . choice _ value = force _ text ( choice &#91; 0 &#93; )
self . choice _ label = force _ text ( choice &#91; 1 &#93; )
self . index = index
if &apos; id &apos; in self . attrs :
self . attrs &#91; &apos; id &apos; &#93; + = &quot; _ % d &quot; % self . index
def _ _ str _ _ ( self ) :
return self . render ( )
def render ( self , name = None , value = None , attrs = None , choices = ( ) ) :
if self . id _ for _ label :
label _ for = format _ html ( &apos; for = &quot; { 0 } &quot; &apos; , self . id _ for _ label )
else :
label _ for = &apos; &apos;
return format _ html ( &apos; &lt; label { 0 } &gt; { 1 } { 2 } &lt; / label &gt; &apos; , label _ for , self . tag ( ) , self . choice _ label )
def is _ checked ( self ) :
return self . value = = self . choice _ value
def tag ( self ) :
final _ attrs = dict ( self . attrs , type = self . input _ type , name = self . name , value = self . choice _ value )
if self . is _ checked ( ) :
final _ attrs &#91; &apos; checked &apos; &#93; = &apos; checked&apos;
return format _ html ( &apos; &lt; input { 0 } / &gt; &apos; , flatatt ( final _ attrs ) )
@ property
def id _ for _ label ( self ) :
return self . attrs . get ( &apos; id &apos; , &apos; &apos; )
class RadioChoiceInput ( ChoiceInput ) :
input _ type = &apos; radio&apos;
def _ _ init _ _ ( self , * args , * * kwargs ) :
super ( RadioChoiceInput , self ) . _ _ init _ _ ( * args , * * kwargs )
self . value = force _ text ( self . value )
class CheckboxChoiceInput ( ChoiceInput ) :
input _ type = &apos; checkbox&apos;
def _ _ init _ _ ( self , * args , * * kwargs ) :
super ( CheckboxChoiceInput , self ) . _ _ init _ _ ( * args , * * kwargs )
self . value = set ( force _ text ( v ) for v in self . value )
def is _ checked ( self ) :
return self . choice _ value in self . value
@ python _ 2 _ unicode _ compatible
class ChoiceFieldRenderer ( object ) :
choice _ input _ class = None
outer _ html = &apos; &lt; ul { id _ attr } &gt; { content } &lt; / ul &gt; &apos;
inner _ html = &apos; &lt; li &gt; { choice _ value } { sub _ widgets } &lt; / li &gt; &apos;
def _ _ init _ _ ( self , name , value , attrs , choices ) :
self . name = name
self . value = value
self . attrs = attrs
self . choices = choices
def _ _ getitem _ _ ( self , idx ) :
choice = self . choices &#91; idx &#93;
return self . choice _ input _ class ( self . name , self . value , self . attrs . copy ( ) , choice , idx )
def _ _ str _ _ ( self ) :
return self . render ( )
def render ( self ) :
id _ = self . attrs . get ( &apos; id &apos; , None )
output = &#91; &#93;
for i , choice in enumerate ( self . choices ) :
choice _ value , choice _ label = choice
if isinstance ( choice _ label , ( tuple , list ) ) :
attrs _ plus = self . attrs . copy ( )
if id _ :
attrs _ plus &#91; &apos; id &apos; &#93; + = &apos; _ { 0 } &apos; . format ( i )
sub _ ul _ renderer = ChoiceFieldRenderer ( name = self . name , value = self . value , attrs = attrs _ plus , choices = choice _ label )
sub _ ul _ renderer . choice _ input _ class = self . choice _ input _ class
output . append ( format _ html ( self . inner _ html , choice _ value = choice _ value , sub _ widgets = sub _ ul _ renderer . render ( ) ) )
else :
w = self . choice _ input _ class ( self . name , self . value , self . attrs . copy ( ) , choice , i )
output . append ( format _ html ( self . inner _ html , choice _ value = force _ text ( w ) , sub _ widgets = &apos; &apos; ) )
return format _ html ( self . outer _ html , id _ attr = format _ html ( &apos; id = &quot; { 0 } &quot; &apos; , id _ ) if id _ else &apos; &apos; , content = mark _ safe ( &apos; \ n &apos; . join ( output ) ) )
class RadioFieldRenderer ( ChoiceFieldRenderer ) :
choice _ input _ class = RadioChoiceInput
class CheckboxFieldRenderer ( ChoiceFieldRenderer ) :
choice _ input _ class = CheckboxChoiceInput
class RendererMixin ( object ) :
renderer = None
_ empty _ value = None
def _ _ init _ _ ( self , * args , * * kwargs ) :
renderer = kwargs . pop ( &apos; renderer &apos; , None )
if renderer :
self . renderer = renderer
super ( RendererMixin , self ) . _ _ init _ _ ( * args , * * kwargs )
def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :
for widget in self . get _ renderer ( name , value , attrs , choices ) :
yield widget
def get _ renderer ( self , name , value , attrs = None , choices = ( ) ) :
if value is None :
value = self . _ empty _ value
final _ attrs = self . build _ attrs ( attrs )
choices = list ( chain ( self . choices , choices ) )
return self . renderer ( name , value , final _ attrs , choices )
def render ( self , name , value , attrs = None , choices = ( ) ) :
return self . get _ renderer ( name , value , attrs , choices ) . render ( )
def id _ for _ label ( self , id _ ) :
if id _ :
id _ + = &apos; _ 0&apos;
return id _
class RadioSelect ( RendererMixin , Select ) :
renderer = RadioFieldRenderer
_ empty _ value = &apos; &apos;
class CheckboxSelectMultiple ( RendererMixin , SelectMultiple ) :
renderer = CheckboxFieldRenderer
_ empty _ value = &#91; &#93;
class MultiWidget ( Widget ) :
def _ _ init _ _ ( self , widgets , attrs = None ) :
self . widgets = &#91; w ( ) if isinstance ( w , type ) else w for w in widgets &#93;
super ( MultiWidget , self ) . _ _ init _ _ ( attrs )
@ property
def is _ hidden ( self ) :
return all ( w . is _ hidden for w in self . widgets )
def render ( self , name , value , attrs = None ) :
if self . is _ localized :
for widget in self . widgets :
widget . is _ localized = self . is _ localized
if not isinstance ( value , list ) :
value = self . decompress ( value )
output = &#91; &#93;
final _ attrs = self . build _ attrs ( attrs )
id _ = final _ attrs . get ( &apos; id &apos; , None )
for i , widget in enumerate ( self . widgets ) :
try :
widget _ value = value &#91; i &#93;
except IndexError :
widget _ value = None
if id _ :
final _ attrs = dict ( final _ attrs , id = &apos; % s _ % s &apos; % ( id _ , i ) )
output . append ( widget . render ( name + &apos; _ % s &apos; % i , widget _ value , final _ attrs ) )
return mark _ safe ( self . format _ output ( output ) )
def id _ for _ label ( self , id _ ) :
if id _ :
id _ + = &apos; _ 0&apos;
return id _
def value _ from _ datadict ( self , data , files , name ) :
return &#91; widget . value _ from _ datadict ( data , files , name + &apos; _ % s &apos; % i ) for i , widget in enumerate ( self . widgets ) &#93;
def format _ output ( self , rendered _ widgets ) :
return &apos; &apos; . join ( rendered _ widgets )
def decompress ( self , value ) :
raise NotImplementedError ( &apos; Subclasses must implement this method . &apos; )
def _ get _ media ( self ) :
media = Media ( )
for w in self . widgets :
media = media + w . media
return media
media = property ( _ get _ media )
def _ _ deepcopy _ _ ( self , memo ) :
obj = super ( MultiWidget , self ) . _ _ deepcopy _ _ ( memo )
obj . widgets = copy . deepcopy ( self . widgets )
return obj
@ property
def needs _ multipart _ form ( self ) :
return any ( w . needs _ multipart _ form for w in self . widgets )
class SplitDateTimeWidget ( MultiWidget ) :
supports _ microseconds = False
def _ _ init _ _ ( self , attrs = None , date _ format = None , time _ format = None ) :
widgets = ( DateInput ( attrs = attrs , format = date _ format ) , TimeInput ( attrs = attrs , format = time _ format ) )
super ( SplitDateTimeWidget , self ) . _ _ init _ _ ( widgets , attrs )
def decompress ( self , value ) :
if value :
value = to _ current _ timezone ( value )
return &#91; value . date ( ) , value . time ( ) . replace ( microsecond = 0 ) &#93;
return &#91; None , None &#93;
class SplitHiddenDateTimeWidget ( SplitDateTimeWidget ) :
def _ _ init _ _ ( self , attrs = None , date _ format = None , time _ format = None ) :
super ( SplitHiddenDateTimeWidget , self ) . _ _ init _ _ ( attrs , date _ format , time _ format )
for widget in self . widgets :
widget . input _ type = &apos; hidden&apos;
from django . http . cookie import SimpleCookie , parse _ cookie
from django . http . request import ( HttpRequest , QueryDict , RawPostDataException , UnreadablePostError , build _ request _ repr )
from django . http . response import ( HttpResponse , StreamingHttpResponse , HttpResponseRedirect , HttpResponsePermanentRedirect , HttpResponseNotModified , HttpResponseBadRequest , HttpResponseForbidden , HttpResponseNotFound , HttpResponseNotAllowed , HttpResponseGone , HttpResponseServerError , Http404 , BadHeaderError , JsonResponse )
from django . http . utils import fix _ location _ header , conditional _ content _ removal
_ _ all _ _ = &#91; &apos; SimpleCookie &apos; , &apos; parse _ cookie &apos; , &apos; HttpRequest &apos; , &apos; QueryDict &apos; , &apos; RawPostDataException &apos; , &apos; UnreadablePostError &apos; , &apos; build _ request _ repr &apos; , &apos; HttpResponse &apos; , &apos; StreamingHttpResponse &apos; , &apos; HttpResponseRedirect &apos; , &apos; HttpResponsePermanentRedirect &apos; , &apos; HttpResponseNotModified &apos; , &apos; HttpResponseBadRequest &apos; , &apos; HttpResponseForbidden &apos; , &apos; HttpResponseNotFound &apos; , &apos; HttpResponseNotAllowed &apos; , &apos; HttpResponseGone &apos; , &apos; HttpResponseServerError &apos; , &apos; Http404 &apos; , &apos; BadHeaderError &apos; , &apos; fix _ location _ header &apos; , &apos; JsonResponse &apos; , &apos; conditional _ content _ removal &apos; , &#93;
from _ _ future _ _ import unicode _ literals
from django . utils . encoding import force _ str
from django . utils import six
from django . utils . six . moves import http _ cookies
_ cookie _ encodes _ correctly = http _ cookies . SimpleCookie ( ) . value _ encode ( &apos; ; &apos; ) = = ( &apos; ; &apos; , &apos; &quot; \ \ 073 &quot; &apos; )
_ tc = http _ cookies . SimpleCookie ( )
try :
_ tc . load ( str ( &apos; foo : bar = 1 &apos; ) )
_ cookie _ allows _ colon _ in _ names = True
except http _ cookies . CookieError :
_ cookie _ allows _ colon _ in _ names = False
if _ cookie _ encodes _ correctly and _ cookie _ allows _ colon _ in _ names :
SimpleCookie = http _ cookies . SimpleCookie
else :
Morsel = http _ cookies . Morsel
class SimpleCookie ( http _ cookies . SimpleCookie ) :
if not _ cookie _ encodes _ correctly :
def value _ encode ( self , val ) :
val , encoded = super ( SimpleCookie , self ) . value _ encode ( val )
encoded = encoded . replace ( &quot; ; &quot; , &quot; \ \ 073 &quot; ) . replace ( &quot; , &quot; , &quot; \ \ 054 &quot; )
if &quot; \ \ &quot; in encoded and not encoded . startswith ( &apos; &quot; &apos; ) :
encoded = &apos; &quot; &apos; + encoded + &apos; &quot; &apos;
return val , encoded
if not _ cookie _ allows _ colon _ in _ names :
def load ( self , rawdata ) :
self . bad _ cookies = set ( )
if six . PY2 and isinstance ( rawdata , six . text _ type ) :
rawdata = force _ str ( rawdata )
super ( SimpleCookie , self ) . load ( rawdata )
for key in self . bad _ cookies :
del self &#91; key &#93;
def _ BaseCookie _ _ set ( self , key , real _ value , coded _ value ) :
key = force _ str ( key )
try :
m = self . get ( key , Morsel ( ) )
m . set ( key , real _ value , coded _ value )
dict . _ _ setitem _ _ ( self , key , M )
except http _ cookies . CookieError :
if not hasattr ( self , &apos; bad _ cookies &apos; ) :
self . bad _ cookies = set ( )
self . bad _ cookies . add ( key )
dict . _ _ setitem _ _ ( self , key , http _ cookies . Morsel ( ) )
def parse _ cookie ( cookie ) :
if cookie = = &apos; &apos; :
return { }
if not isinstance ( cookie , http _ cookies . BaseCookie ) :
try :
c = SimpleCookie ( )
c . load ( cookie )
except http _ cookies . CookieError :
return { }
else :
c = cookie
cookiedict = { }
for key in c . keys ( ) :
cookiedict &#91; key &#93; = c . get ( key ) . value
return cookiedict
from _ _ future _ _ import unicode _ literals
import base64
import binascii
import cgi
import sys
from django . conf import settings
from django . core . exceptions import SuspiciousMultipartForm
from django . utils . datastructures import MultiValueDict
from django . utils . encoding import force _ text
from django . utils import six
from django . utils . text import unescape _ entities
from django . core . files . uploadhandler import StopUpload , SkipFile , StopFutureHandlers
_ _ all _ _ = ( &apos; MultiPartParser &apos; , &apos; MultiPartParserError &apos; , &apos; InputStreamExhausted &apos; )
class MultiPartParserError ( Exception ) :
pass
class InputStreamExhausted ( Exception ) :
pass
raw = &quot; raw &quot;
file = &quot; file &quot;
field = &quot; field &quot;
_ BASE64 _ DECODE _ ERROR = TypeError if six . PY2 else binascii . error
class MultiPartParser ( object ) :
def _ _ init _ _ ( self , META , input _ data , upload _ handlers , encoding = None ) :
content _ type = META . get ( &apos; HTTP _ CONTENT _ TYPE &apos; , META . get ( &apos; CONTENT _ TYPE &apos; , &apos; &apos; ) )
if not content _ type . startswith ( &apos; multipart / &apos; ) :
raise MultiPartParserError ( &apos; Invalid Content-Type : % s &apos; % content _ type )
ctypes , opts = parse _ header ( content _ type . encode ( &apos; ascii &apos; ) )
boundary = opts . get ( &apos; boundary &apos; )
if not boundary or not cgi . valid _ boundary ( boundary ) :
raise MultiPartParserError ( &apos; Invalid boundary in multipart : % s &apos; % boundary )
try :
content _ length = int ( META . get ( &apos; HTTP _ CONTENT _ LENGTH &apos; , META . get ( &apos; CONTENT _ LENGTH &apos; , 0 ) ) )
except ( ValueError , TypeError ) :
content _ length = 0
if content _ length &lt; 0 :
raise MultiPartParserError ( &quot; Invalid content length : % r &quot; % content _ length )
if isinstance ( boundary , six . text _ type ) :
boundary = boundary . encode ( &apos; ascii &apos; )
self . _ boundary = boundary
self . _ input _ data = input _ data
possible _ sizes = &#91; x . chunk _ size for x in upload _ handlers if x . chunk _ size &#93;
self . _ chunk _ size = min ( &#91; 2 * * 31 - 4 &#93; + possible _ sizes )
self . _ meta = META
self . _ encoding = encoding or settings . default _ CHARSET
self . _ content _ length = content _ length
self . _ upload _ handlers = upload _ handlers
def parse ( self ) :
from django . http import QueryDict
encoding = self . _ encoding
handlers = self . _ upload _ handlers
if self . _ content _ length = = 0 :
return QueryDict ( &apos; &apos; , encoding = self . _ encoding ) , MultiValueDict ( )
for handler in handlers :
result = handler . handle _ raw _ input ( self . _ input _ data , self . _ meta , self . _ content _ length , self . _ boundary , encoding )
if result is not None :
return result &#91; 0 &#93; , result &#91; 1 &#93;
self . _ post = QueryDict ( &apos; &apos; , mutable = True )
self . _ files = MultiValueDict ( )
stream = LazyStream ( ChunkIter ( self . _ input _ data , self . _ chunk _ size ) )
old _ field _ name = None
counters = &#91; 0 &#93; * len ( handlers )
try :
for item _ type , meta _ data , field _ stream in Parser ( stream , self . _ boundary ) :
if old _ field _ name :
self . handle _ file _ complete ( old _ field _ name , counters )
old _ field _ name = None
try :
disposition = meta _ data &#91; &apos; content-disposition &apos; &#93; &#91; 1 &#93;
field _ name = disposition &#91; &apos; name &apos; &#93; . strip ( )
except ( KeyError , IndexError , AttributeError ) :
continue
transfer _ encoding = meta _ data . get ( &apos; content-transfer-encoding &apos; )
if transfer _ encoding is not None :
transfer _ encoding = transfer _ encoding &#91; 0 &#93; . strip ( )
field _ name = force _ text ( field _ name , encoding , errors = &apos; replace &apos; )
if item _ type = = FIELD :
if transfer _ encoding = = &apos; base64 &apos; :
raw _ data = field _ stream . read ( )
try :
data = base64 . b64decode ( raw _ data )
except _ BASE64 _ DECODE _ ERROR :
data = raw _ data
else :
data = field _ stream . read ( )
self . _ post . appendlist ( field _ name , force _ text ( data , encoding , errors = &apos; replace &apos; ) )
elif item _ type = = FILE :
file _ name = disposition . get ( &apos; filename &apos; )
if not file _ name :
continue
file _ name = force _ text ( file _ name , encoding , errors = &apos; replace &apos; )
file _ name = self . IE _ sanitize ( unescape _ entities ( file _ name ) )
content _ type , content _ type _ extra = meta _ data . get ( &apos; content-type &apos; , ( &apos; &apos; , { } ) )
content _ type = content _ type . strip ( )
charset = content _ type _ extra . get ( &apos; charset &apos; )
try :
content _ length = int ( meta _ data . get ( &apos; content-length &apos; ) &#91; 0 &#93; )
except ( IndexError , TypeError , ValueError ) :
content _ length = None
counters = &#91; 0 &#93; * len ( handlers )
try :
for handler in handlers :
try :
handler . new _ file ( field _ name , file _ name , content _ type , content _ length , charset , content _ type _ extra )
except StopFutureHandlers :
break
for chunk in field _ stream :
if transfer _ encoding = = &apos; base64 &apos; :
over _ bytes = len ( chunk ) % 4
if over _ bytes :
over _ chunk = field _ stream . read ( 4 - over _ bytes )
chunk + = over _ chunk
try :
chunk = base64 . b64decode ( chunk )
except Exception as e :
msg = &quot; Could not decode base64 data : % r &quot; % e
six . reraise ( MultiPartParserError , MultiPartParserError ( msg ) , sys . exc _ info ( ) &#91; 2 &#93; )
for i , handler in enumerate ( handlers ) :
chunk _ length = len ( chunk )
chunk = handler . receive _ data _ chunk ( chunk , counters &#91; i &#93; )
counters &#91; i &#93; + = chunk _ length
if chunk is None :
break
except SkipFile :
self . _ close _ files ( )
exhaust ( field _ stream )
else :
old _ field _ name = field _ name
else :
exhaust ( stream )
except StopUpload as e :
self . _ close _ files ( )
if not e . connection _ reset :
exhaust ( self . _ input _ data )
else :
exhaust ( self . _ input _ data )
for handler in handlers :
retval = handler . upload _ complete ( )
if retval :
break
return self . _ post , self . _ files
def handle _ file _ complete ( self , old _ field _ name , counters ) :
for i , handler in enumerate ( self . _ upload _ handlers ) :
file _ obj = handler . file _ complete ( counters &#91; i &#93; )
if file _ obj :
self . _ files . appendlist ( force _ text ( old _ field _ name , self . _ encoding , errors = &apos; replace &apos; ) , file _ obj )
break
def IE _ sanitize ( self , filename ) :
return filename and filename &#91; filename . rfind ( &quot; \ \ &quot; ) + 1 : &#93; . strip ( )
def _ close _ files ( self ) :
for handler in self . _ upload _ handlers :
if hasattr ( handler , &apos; file &apos; ) :
handler . file . close ( )
class LazyStream ( six . iterator ) :
def _ _ init _ _ ( self , producer , length = None ) :
self . _ producer = producer
self . _ empty = False
self . _ leftover = b &apos; &apos;
self . length = length
self . position = 0
self . _ remaining = length
self . _ unget _ history = &#91; &#93;
def tell ( self ) :
return self . position
def read ( self , size = None ) :
def parts ( ) :
remaining = self . _ remaining if size is None else size
if remaining is None :
yield b &apos; &apos; . join ( self )
return
while remaining ! = 0 :
assert remaining &gt; 0 , &apos; remaining bytes to read should never go negative&apos;
chunk = next ( self )
emitting = chunk &#91; : remaining &#93;
self . unget ( chunk &#91; remaining : &#93; )
remaining - = len ( emitting )
yield emitting
out = b &apos; &apos; . join ( parts ( ) )
return out
def _ _ next _ _ ( self ) :
if self . _ leftover :
output = self . _ leftover
self . _ leftover = b &apos; &apos;
else :
output = next ( self . _ producer )
self . _ unget _ history = &#91; &#93;
self . position + = len ( output )
return output
def close ( self ) :
self . _ producer = &#91; &#93;
def _ _ iter _ _ ( self ) :
return self
def unget ( self , bytes ) :
if not bytes :
return
self . _ update _ unget _ history ( len ( bytes ) )
self . position - = len ( bytes )
self . _ leftover = b &apos; &apos; . join ( &#91; bytes , self . _ leftover &#93; )
def _ update _ unget _ history ( self , num _ bytes ) :
self . _ unget _ history = &#91; num _ bytes &#93; + self . _ unget _ history &#91; : 49 &#93;
number _ equal = len ( &#91; current _ number for current _ number in self . _ unget _ history if current _ number = = num _ bytes &#93; )
if number _ equal &gt; 40 :
raise SuspiciousMultipartForm ( &quot; The multipart parser got stuck , which shouldn &apos;t happen with &quot; &quot; normal uploaded files . check for malicious upload activity ; &quot; &quot; if there is none , report this to the Django developers . &quot; )
class ChunkIter ( six . iterator ) :
def _ _ init _ _ ( self , flo , chunk _ size = 64 * 1024 ) :
self . flo = flo
self . chunk _ size = chunk _ size
def _ _ next _ _ ( self ) :
try :
data = self . flo . read ( self . chunk _ size )
except InputStreamExhausted :
raise StopIteration ( )
if data :
return data
else :
raise StopIteration ( )
def _ _ iter _ _ ( self ) :
return self
class InterBoundaryIter ( six . iterator ) :
def _ _ init _ _ ( self , stream , boundary ) :
self . _ stream = stream
self . _ boundary = boundary
def _ _ iter _ _ ( self ) :
return self
def _ _ next _ _ ( self ) :
try :
return LazyStream ( BoundaryIter ( self . _ stream , self . _ boundary ) )
except InputStreamExhausted :
raise StopIteration ( )
class BoundaryIter ( six . iterator ) :
def _ _ init _ _ ( self , stream , boundary ) :
self . _ stream = stream
self . _ boundary = boundary
self . _ done = False
self . _ rollback = len ( boundary ) + 6
unused _ char = self . _ stream . read ( 1 )
if not unused _ char :
raise InputStreamExhausted ( )
self . _ stream . unget ( unused _ char )
def _ _ iter _ _ ( self ) :
return self
def _ _ next _ _ ( self ) :
if self . _ done :
raise StopIteration ( )
stream = self . _ stream
rollback = self . _ rollback
bytes _ read = 0
chunks = &#91; &#93;
for bytes in stream :
bytes _ read + = len ( bytes )
chunks . append ( bytes )
if bytes _ read &gt; rollback :
break
if not bytes :
break
else :
self . _ done = True
if not chunks :
raise StopIteration ( )
chunk = b &apos; &apos; . join ( chunks )
boundary = self . _ find _ boundary ( chunk , len ( chunk ) &lt; self . _ rollback )
if boundary :
end , next = boundary
stream . unget ( chunk &#91; next : &#93; )
self . _ done = True
return chunk &#91; : end &#93;
else :
if not chunk &#91; : - rollback &#93; :
self . _ done = True
return chunk
else :
stream . unget ( chunk &#91; - rollback : &#93; )
return chunk &#91; : - rollback &#93;
def _ find _ boundary ( self , data , eof = False ) :
index = data . find ( self . _ boundary )
if index &lt; 0 :
return None
else :
end = index
next = index + len ( self . _ boundary )
last = max ( 0 , end - 1 )
if data &#91; last : last + 1 &#93; = = b &apos; \ n &apos; :
end - = 1
last = max ( 0 , end - 1 )
if data &#91; last : last + 1 &#93; = = b &apos; \ r &apos; :
end - = 1
return end , next
def exhaust ( stream _ or _ iterable ) :
iterator = None
try :
iterator = iter ( stream _ or _ iterable )
except TypeError :
iterator = ChunkIter ( stream _ or _ iterable , 16384 )
if iterator is None :
raise MultiPartParserError ( &apos; multipartparser.exhaust ( ) was passed a non-iterable or stream parameter &apos; )
for _ _ in iterator :
pass
def parse _ boundary _ stream ( stream , max _ header _ size ) :
chunk = stream . read ( max _ header _ size )
header _ end = chunk . find ( b &apos; \ r \ n \ r \ n &apos; )
def _ parse _ header ( line ) :
main _ value _ pair , params = parse _ header ( line )
try :
name , value = main _ value _ pair . split ( &apos; : &apos; , 1 )
except ValueError :
raise ValueError ( &quot; Invalid header : % r &quot; % line )
return name , ( value , params )
if header _ end = = - 1 :
stream . unget ( chunk )
return ( RAW , { } , stream )
header = chunk &#91; : header _ end &#93;
stream . unget ( chunk &#91; header _ end + 4 : &#93; )
type = RAW
outdict = { }
for line in header . split ( b &apos; \ r \ n &apos; ) :
try :
name , ( value , params ) = _ parse _ header ( line )
except ValueError :
continue
if name = = &apos; content-disposition &apos; :
type = FIELD
if params . get ( &apos; filename &apos; ) :
type = FILE
outdict &#91; name &#93; = value , params
if TYPE = = RAW :
stream . unget ( chunk )
return ( TYPE , outdict , stream )
class Parser ( object ) :
def _ _ init _ _ ( self , stream , boundary ) :
self . _ stream = stream
self . _ separator = b &apos; -- &apos; + boundary
def _ _ iter _ _ ( self ) :
boundarystream = InterBoundaryIter ( self . _ stream , self . _ separator )
for sub _ stream in boundarystream :
yield parse _ boundary _ stream ( sub _ stream , 1024 )
def parse _ header ( line ) :
plist = _ parse _ header _ params ( b &apos; ; &apos; + line )
key = plist . pop ( 0 ) . lower ( ) . decode ( &apos; ascii &apos; )
pdict = { }
for p in plist :
i = p . find ( b &apos; = &apos; )
if i &gt; = 0 :
name = p &#91; : i &#93; . strip ( ) . lower ( ) . decode ( &apos; ascii &apos; )
value = p &#91; i + 1 : &#93; . strip ( )
if len ( value ) &gt; = 2 and value &#91; : 1 &#93; = = value &#91; - 1 : &#93; = = b &apos; &quot; &apos; :
value = value &#91; 1 : - 1 &#93;
value = value . replace ( b &apos; \ \ \ \ &apos; , b &apos; \ \ &apos; ) . replace ( b &apos; \ \ &quot; &apos; , b &apos; &quot; &apos; )
pdict &#91; name &#93; = value
return key , pdict
def _ parse _ header _ params ( s ) :
plist = &#91; &#93;
while s &#91; : 1 &#93; = = b &apos; ; &apos; :
s = s &#91; 1 : &#93;
end = s . find ( b &apos; ; &apos; )
while end &gt; 0 and s . count ( b &apos; &quot; &apos; , 0 , end ) % 2 :
end = s . find ( b &apos; ; &apos; , end + 1 )
if end &lt; 0 :
end = len ( s )
f = s &#91; : end &#93;
plist . append ( f . strip ( ) )
s = s &#91; end : &#93;
return plist
from _ _ future _ _ import unicode _ literals
import copy
import os
import re
import sys
from io import BytesIO
from itertools import chain
from pprint import pformat
from django . conf import settings
from django . core import signing
from django . core . exceptions import DisallowedHost , ImproperlyConfigured
from django . core . files import uploadhandler
from django . http . MultiPartParser import MultiPartParser , MultiPartParserError
from django . utils import six
from django . utils . datastructures import MultiValueDict , ImmutableList
from django . utils . encoding import force _ bytes , force _ text , force _ str , iri _ to _ uri
from django . utils . six . moves . urllib . parse import parse _ qsl , urlencode , quote , urljoin , urlsplit
raise _ ERROR = object ( )
absolute _ http _ url _ re = re . compile ( r &quot; ^ https ? : / / &quot; , re . i )
host _ validation _ re = re . compile ( r &quot; ^ ( &#91; a-z0-9.- &#93; + &#124; \ &#91; &#91; a-f0-9 &#93; * : &#91; a-f0-9 : &#93; + \ &#93; ) ( : \ d + ) ? $ &quot; )
class UnreadablePostError ( IOError ) :
pass
class RawPostDataException ( Exception ) :
pass
class HttpRequest ( object ) :
_ encoding = None
_ upload _ handlers = &#91; &#93;
def _ _ init _ _ ( self ) :
self . get = QueryDict ( mutable = True )
self . post = QueryDict ( mutable = True )
self . cookies = { }
self . meta = { }
self . files = MultiValueDict ( )
self . path = &apos; &apos;
self . path _ info = &apos; &apos;
self . method = None
self . resolver _ match = None
self . _ post _ parse _ error = False
def _ _ repr _ _ ( self ) :
return build _ request _ repr ( self )
def get _ host ( self ) :
if settings . use _ X _ FORWARDED _ HOST and ( &apos; HTTP _ X _ FORWARDED _ HOST &apos; in self . meta ) :
host = self . meta &#91; &apos; HTTP _ X _ FORWARDED _ HOST &apos; &#93;
elif &apos; HTTP _ HOST &apos; in self . meta :
host = self . meta &#91; &apos; HTTP _ HOST &apos; &#93;
else :
host = self . meta &#91; &apos; SERVER _ NAME &apos; &#93;
server _ port = str ( self . meta &#91; &apos; SERVER _ PORT &apos; &#93; )
if server _ port ! = ( &apos; 443 &apos; if self . is _ secure ( ) else &apos; 80 &apos; ) :
host = &apos; % s : % s &apos; % ( host , server _ port )
if settings . DEBUG :
return host
domain , port = split _ domain _ port ( host )
if domain and validate _ host ( domain , settings . allowed _ HOSTS ) :
return host
else :
msg = &quot; Invalid HTTP _ HOST header : % r . &quot; % host
if domain :
msg + = &quot; You may need to add % r to ALLOWED _ HOSTS . &quot; % domain
else :
msg + = &quot; The domain name provided is not valid according to RFC 1034 / 1035 . &quot;
raise DisallowedHost ( msg )
def get _ full _ path ( self ) :
return &apos; % s % s &apos; % ( self . path , ( &apos; ? &apos; + iri _ to _ uri ( self . meta . get ( &apos; QUERY _ STRING &apos; , &apos; &apos; ) ) ) if self . meta . get ( &apos; QUERY _ STRING &apos; , &apos; &apos; ) else &apos; &apos; )
def get _ signed _ cookie ( self , key , default = RAISE _ ERROR , salt = &apos; &apos; , max _ age = None ) :
try :
cookie _ value = self . cookies &#91; key &#93;
except KeyError :
if default is not RAISE _ ERROR :
return default
else :
raise
try :
value = signing . get _ cookie _ signer ( salt = key + salt ) . unsign ( cookie _ value , max _ age = max _ age )
except signing . BadSignature :
if default is not RAISE _ ERROR :
return default
else :
raise
return value
def build _ absolute _ uri ( self , location = None ) :
if location is None :
location = &apos; / / % s &apos; % self . get _ full _ path ( )
bits = urlsplit ( location )
if not ( bits . scheme and bits . netloc ) :
current _ uri = &apos; { scheme } : / / { host } { path } &apos; . format ( scheme = self . scheme , host = self . get _ host ( ) , path = self . path )
location = urljoin ( current _ uri , location )
return iri _ to _ uri ( location )
def _ get _ scheme ( self ) :
return &apos; https &apos; if os . environ . get ( &quot; HTTPS &quot; ) = = &quot; on &quot; else &apos; http&apos;
@ property
def scheme ( self ) :
if settings . secure _ PROXY _ SSL _ HEADER :
try :
header , value = settings . secure _ PROXY _ SSL _ HEADER
except ValueError :
raise ImproperlyConfigured ( &apos; The SECURE _ PROXY _ SSL _ HEADER setting must be a tuple containing two values . &apos; )
if self . meta . get ( header , None ) = = value :
return &apos; https&apos;
return self . _ get _ scheme ( )
def is _ secure ( self ) :
return self . scheme = = &apos; https&apos;
def is _ ajax ( self ) :
return self . meta . get ( &apos; HTTP _ X _ REQUESTED _ WITH &apos; ) = = &apos; XMLHttpRequest&apos;
@ property
def encoding ( self ) :
return self . _ encoding
@ encoding . setter
def encoding ( self , val ) :
self . _ encoding = val
if hasattr ( self , &apos; _ get &apos; ) :
del self . _ get
if hasattr ( self , &apos; _ post &apos; ) :
del self . _ post
def _ initialize _ handlers ( self ) :
self . _ upload _ handlers = &#91; uploadhandler . load _ handler ( handler , self ) for handler in settings . file _ UPLOAD _ HANDLERS &#93;
@ property
def upload _ handlers ( self ) :
if not self . _ upload _ handlers :
self . _ initialize _ handlers ( )
return self . _ upload _ handlers
@ upload _ handlers . setter
def upload _ handlers ( self , upload _ handlers ) :
if hasattr ( self , &apos; _ files &apos; ) :
raise AttributeError ( &quot; You cannot set the upload handlers after the upload has been processed . &quot; )
self . _ upload _ handlers = upload _ handlers
def parse _ file _ upload ( self , META , post _ data ) :
self . upload _ handlers = ImmutableList ( self . upload _ handlers , warning = &quot; You cannot alter upload handlers after the upload has been processed . &quot; )
parser = MultiPartParser ( META , post _ data , self . upload _ handlers , self . encoding )
return parser . parse ( )
@ property
def body ( self ) :
if not hasattr ( self , &apos; _ body &apos; ) :
if self . _ read _ started :
raise RawPostDataException ( &quot; You cannot access body after reading from request &apos;s data stream &quot; )
try :
self . _ body = self . read ( )
except IOError as e :
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc _ info ( ) &#91; 2 &#93; )
self . _ stream = BytesIO ( self . _ body )
return self . _ body
def _ mark _ post _ parse _ error ( self ) :
self . _ post = QueryDict ( &apos; &apos; )
self . _ files = MultiValueDict ( )
self . _ post _ parse _ error = True
def _ load _ post _ and _ files ( self ) :
if self . method ! = &apos; POST &apos; :
self . _ post , self . _ files = QueryDict ( &apos; &apos; , encoding = self . _ encoding ) , MultiValueDict ( )
return
if self . _ read _ started and not hasattr ( self , &apos; _ body &apos; ) :
self . _ mark _ post _ parse _ error ( )
return
if self . meta . get ( &apos; CONTENT _ TYPE &apos; , &apos; &apos; ) . startswith ( &apos; multipart / form-data &apos; ) :
if hasattr ( self , &apos; _ body &apos; ) :
data = BytesIO ( self . _ body )
else :
data = self
try :
self . _ post , self . _ files = self . parse _ file _ upload ( self . meta , data )
except MultiPartParserError :
self . _ mark _ post _ parse _ error ( )
raise
elif self . meta . get ( &apos; CONTENT _ TYPE &apos; , &apos; &apos; ) . startswith ( &apos; application / x-www-form-urlencoded &apos; ) :
self . _ post , self . _ files = QueryDict ( self . body , encoding = self . _ encoding ) , MultiValueDict ( )
else :
self . _ post , self . _ files = QueryDict ( &apos; &apos; , encoding = self . _ encoding ) , MultiValueDict ( )
def close ( self ) :
if hasattr ( self , &apos; _ files &apos; ) :
for f in chain . from _ iterable ( l &#91; 1 &#93; for l in self . _ files . lists ( ) ) :
f . close ( )
def read ( self , * args , * * kwargs ) :
self . _ read _ started = True
try :
return self . _ stream . read ( * args , * * kwargs )
except IOError as e :
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc _ info ( ) &#91; 2 &#93; )
def readline ( self , * args , * * kwargs ) :
self . _ read _ started = True
try :
return self . _ stream . readline ( * args , * * kwargs )
except IOError as e :
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc _ info ( ) &#91; 2 &#93; )
def xreadlines ( self ) :
while True :
buf = self . readline ( )
if not buf :
break
yield buf
_ _ iter _ _ = xreadlines
def readlines ( self ) :
return list ( iter ( self ) )
class QueryDict ( MultiValueDict ) :
_ mutable = True
_ encoding = None
def _ _ init _ _ ( self , query _ string = None , mutable = False , encoding = None ) :
super ( QueryDict , self ) . _ _ init _ _ ( )
if not encoding :
encoding = settings . default _ CHARSET
self . encoding = encoding
if six . PY3 :
if isinstance ( query _ string , bytes ) :
query _ string = query _ string . decode ( )
for key , value in parse _ qsl ( query _ string or &apos; &apos; , keep _ blank _ values = True , encoding = encoding ) :
self . appendlist ( key , value )
else :
for key , value in parse _ qsl ( query _ string or &apos; &apos; , keep _ blank _ values = True ) :
self . appendlist ( force _ text ( key , encoding , errors = &apos; replace &apos; ) , force _ text ( value , encoding , errors = &apos; replace &apos; ) )
self . _ mutable = mutable
@ property
def encoding ( self ) :
if self . _ encoding is None :
self . _ encoding = settings . default _ CHARSET
return self . _ encoding
@ encoding . setter
def encoding ( self , value ) :
self . _ encoding = value
def _ assert _ mutable ( self ) :
if not self . _ mutable :
raise AttributeError ( &quot; This QueryDict instance is immutable &quot; )
def _ _ setitem _ _ ( self , key , value ) :
self . _ assert _ mutable ( )
key = bytes _ to _ text ( key , self . encoding )
value = bytes _ to _ text ( value , self . encoding )
super ( QueryDict , self ) . _ _ setitem _ _ ( key , value )
def _ _ delitem _ _ ( self , key ) :
self . _ assert _ mutable ( )
super ( QueryDict , self ) . _ _ delitem _ _ ( key )
def _ _ copy _ _ ( self ) :
result = self . _ _ class _ _ ( &apos; &apos; , mutable = True , encoding = self . encoding )
for key , value in six . iterlists ( self ) :
result . setlist ( key , value )
return result
def _ _ deepcopy _ _ ( self , memo ) :
result = self . _ _ class _ _ ( &apos; &apos; , mutable = True , encoding = self . encoding )
memo &#91; id ( self ) &#93; = result
for key , value in six . iterlists ( self ) :
result . setlist ( copy . deepcopy ( key , memo ) , copy . deepcopy ( value , memo ) )
return result
def setlist ( self , key , list _ ) :
self . _ assert _ mutable ( )
key = bytes _ to _ text ( key , self . encoding )
list _ = &#91; bytes _ to _ text ( elt , self . encoding ) for elt in list _ &#93;
super ( QueryDict , self ) . setlist ( key , list _ )
def setlistdefault ( self , key , default _ list = None ) :
self . _ assert _ mutable ( )
return super ( QueryDict , self ) . setlistdefault ( key , default _ list )
def appendlist ( self , key , value ) :
self . _ assert _ mutable ( )
key = bytes _ to _ text ( key , self . encoding )
value = bytes _ to _ text ( value , self . encoding )
super ( QueryDict , self ) . appendlist ( key , value )
def pop ( self , key , * args ) :
self . _ assert _ mutable ( )
return super ( QueryDict , self ) . pop ( key , * args )
def popitem ( self ) :
self . _ assert _ mutable ( )
return super ( QueryDict , self ) . popitem ( )
def clear ( self ) :
self . _ assert _ mutable ( )
super ( QueryDict , self ) . clear ( )
def setdefault ( self , key , default = None ) :
self . _ assert _ mutable ( )
key = bytes _ to _ text ( key , self . encoding )
default = bytes _ to _ text ( default , self . encoding )
return super ( QueryDict , self ) . setdefault ( key , default )
def copy ( self ) :
return self . _ _ deepcopy _ _ ( { } )
def urlencode ( self , safe = None ) :
output = &#91; &#93;
if safe :
safe = force _ bytes ( safe , self . encoding )
encode = lambda k , v : &apos; % s = % s &apos; % ( ( quote ( k , safe ) , quote ( v , safe ) ) )
else :
encode = lambda k , v : urlencode ( { k : v } )
for k , list _ in self . lists ( ) :
k = force _ bytes ( k , self . encoding )
output . extend ( &#91; encode ( k , force _ bytes ( v , self . encoding ) ) for v in list _ &#93; )
return &apos; &amp; &apos; . join ( output )
def build _ request _ repr ( request , path _ override = None , GET _ override = None , POST _ override = None , COOKIES _ override = None , META _ override = None ) :
try :
get = ( pformat ( GET _ override ) if GET _ override is not None else pformat ( request . get ) )
except Exception :
get = &apos; &lt; could not parse &gt; &apos;
if request . _ post _ parse _ error :
post = &apos; &lt; could not parse &gt; &apos;
else :
try :
post = ( pformat ( POST _ override ) if POST _ override is not None else pformat ( request . post ) )
except Exception :
post = &apos; &lt; could not parse &gt; &apos;
try :
cookies = ( pformat ( COOKIES _ override ) if COOKIES _ override is not None else pformat ( request . cookies ) )
except Exception :
cookies = &apos; &lt; could not parse &gt; &apos;
try :
meta = ( pformat ( META _ override ) if META _ override is not None else pformat ( request . meta ) )
except Exception :
meta = &apos; &lt; could not parse &gt; &apos;
path = path _ override if path _ override is not None else request . path
return force _ str ( &apos; &lt; % s \ npath : % s , \ nGET : % s , \ nPOST : % s , \ nCOOKIES : % s , \ nMETA : % s &gt; &apos; % ( request . _ _ class _ _ . _ _ name _ _ , path , six . text _ type ( get ) , six . text _ type ( post ) , six . text _ type ( cookies ) , six . text _ type ( meta ) ) )
def bytes _ to _ text ( s , encoding ) :
if isinstance ( s , bytes ) :
return six . text _ type ( s , encoding , &apos; replace &apos; )
else :
return s
def split _ domain _ port ( host ) :
host = host . lower ( )
if not host _ validation _ re . match ( host ) :
return &apos; &apos; , &apos; &apos;
if host &#91; - 1 &#93; = = &apos; &#93; &apos; :
return host , &apos; &apos;
bits = host . rsplit ( &apos; : &apos; , 1 )
if len ( bits ) = = 2 :
return tuple ( bits )
return bits &#91; 0 &#93; , &apos; &apos;
def validate _ host ( host , allowed _ hosts ) :
host = host &#91; : - 1 &#93; if host . endswith ( &apos; .&apos; ) else host
for pattern in allowed _ hosts :
pattern = pattern . lower ( )
match = ( pattern = = &apos; * &apos; or pattern . startswith ( &apos; .&apos; ) and ( host . endswith ( pattern ) or host = = pattern &#91; 1 : &#93; ) or pattern = = host )
if match :
return True
return False
from _ _ future _ _ import unicode _ literals
import datetime
import json
import sys
import time
from email . header import Header
from django . conf import settings
from django . core import signals
from django . core import signing
from django . core . exceptions import DisallowedRedirect
from django . core . serializers . json import DjangoJSONEncoder
from django . http . cookie import SimpleCookie
from django . utils import six , timezone
from django . utils . encoding import force _ bytes , force _ text , iri _ to _ uri
from django . utils . http import cookie _ date
from django . utils . six . moves import map
from django . utils . six . moves . urllib . parse import urlparse
reason _ PHRASES = { 100 : &apos; continue &apos; , 101 : &apos; SWITCHING PROTOCOLS &apos; , 102 : &apos; processing &apos; , 200 : &apos; OK &apos; , 201 : &apos; created &apos; , 202 : &apos; accepted &apos; , 203 : &apos; NON-AUTHORITATIVE INFORMATION &apos; , 204 : &apos; no CONTENT &apos; , 205 : &apos; reset CONTENT &apos; , 206 : &apos; partial CONTENT &apos; , 207 : &apos; MULTI-STATUS &apos; , 208 : &apos; already REPORTED &apos; , 226 : &apos; im USED &apos; , 300 : &apos; multiple CHOICES &apos; , 301 : &apos; moved PERMANENTLY &apos; , 302 : &apos; found &apos; , 303 : &apos; see OTHER &apos; , 304 : &apos; not MODIFIED &apos; , 305 : &apos; use PROXY &apos; , 306 : &apos; reserved &apos; , 307 : &apos; temporary REDIRECT &apos; , 308 : &apos; PERMANENT REDIRECT &apos; , 400 : &apos; bad REQUEST &apos; , 401 : &apos; UNAUTHORIZED &apos; , 402 : &apos; PAYMENT REQUIRED &apos; , 403 : &apos; Forbidden &apos; , 404 : &apos; not FOUND &apos; , 405 : &apos; method NOT ALLOWED &apos; , 406 : &apos; not ACCEPTABLE &apos; , 407 : &apos; proxy AUTHENTICATION REQUIRED &apos; , 408 : &apos; request TIMEOUT &apos; , 409 : &apos; conflict &apos; , 410 : &apos; GONE &apos; , 411 : &apos; length REQUIRED &apos; , 412 : &apos; PRECONDITION FAILED &apos; , 413 : &apos; request ENTITY TOO LARGE &apos; , 414 : &apos; REQUEST-URI TOO LONG &apos; , 415 : &apos; Unsupported MEDIA TYPE &apos; , 416 : &apos; REQUESTED RANGE NOT SATISFIABLE &apos; , 417 : &apos; EXPECTATION FAILED &apos; , 418 : &quot; i &apos;M A TEAPOT &quot; , 422 : &apos; UNPROCESSABLE ENTITY &apos; , 423 : &apos; LOCKED &apos; , 424 : &apos; failed DEPENDENCY &apos; , 426 : &apos; UPGRADE REQUIRED &apos; , 428 : &apos; PRECONDITION REQUIRED &apos; , 429 : &apos; too MANY REQUESTS &apos; , 431 : &apos; request HEADER FIELDS TOO LARGE &apos; , 500 : &apos; internal SERVER ERROR &apos; , 501 : &apos; not IMPLEMENTED &apos; , 502 : &apos; bad GATEWAY &apos; , 503 : &apos; SERVICE UNAVAILABLE &apos; , 504 : &apos; GATEWAY TIMEOUT &apos; , 505 : &apos; http VERSION NOT SUPPORTED &apos; , 506 : &apos; variant ALSO NEGOTIATES &apos; , 507 : &apos; INSUFFICIENT STORAGE &apos; , 508 : &apos; loop DETECTED &apos; , 510 : &apos; not EXTENDED &apos; , 511 : &apos; NETWORK AUTHENTICATION REQUIRED &apos; , }
class BadHeaderError ( ValueError ) :
pass
class HttpResponseBase ( six . iterator ) :
status _ code = 200
reason _ phrase = None
def _ _ init _ _ ( self , content _ type = None , status = None , reason = None ) :
self . _ headers = { }
self . _ charset = settings . default _ CHARSET
self . _ closable _ objects = &#91; &#93;
self . _ handler _ class = None
if not content _ type :
content _ type = &quot; % s ; charset = % s &quot; % ( settings . default _ CONTENT _ TYPE , self . _ charset )
self . cookies = SimpleCookie ( )
if status is not None :
self . status _ code = status
if reason is not None :
self . reason _ phrase = reason
elif self . reason _ phrase is None :
self . reason _ phrase = REASON _ PHRASES . get ( self . status _ code , &apos; UNKNOWN STATUS CODE &apos; )
self &#91; &apos; Content-Type &apos; &#93; = content _ type
def serialize _ headers ( self ) :
def to _ bytes ( val , encoding ) :
return val if isinstance ( val , bytes ) else val . encode ( encoding )
headers = &#91; ( b &apos; : &apos; . join ( &#91; to _ bytes ( key , &apos; ascii &apos; ) , to _ bytes ( value , &apos; latin-1 &apos; ) &#93; ) ) for key , value in self . _ headers . values ( ) &#93;
return b &apos; \ r \ n &apos; . join ( headers )
if six . PY3 :
_ _ bytes _ _ = serialize _ headers
else :
_ _ str _ _ = serialize _ headers
def _ convert _ to _ charset ( self , value , charset , mime _ encode = False ) :
if not isinstance ( value , ( bytes , six . text _ type ) ) :
value = str ( value )
try :
if six . PY3 :
if isinstance ( value , str ) :
value . encode ( charset )
else :
value = value . decode ( charset )
else :
if isinstance ( value , str ) :
value . decode ( charset )
else :
value = value . encode ( charset )
except UnicodeError as e :
if mime _ encode :
value = str ( Header ( value , &apos; utf-8 &apos; , maxlinelen = sys . maxsize ) . encode ( ) )
else :
e . reason + = &apos; , HTTP response headers must be in % s format &apos; % charset
raise
if str ( &apos; \ n &apos; ) in value or str ( &apos; \ r &apos; ) in value :
raise BadHeaderError ( &quot; Header values can &apos;t contain newlines ( got % r ) &quot; % value )
return value
def _ _ setitem _ _ ( self , header , value ) :
header = self . _ convert _ to _ charset ( header , &apos; ascii &apos; )
value = self . _ convert _ to _ charset ( value , &apos; latin-1 &apos; , mime _ encode = True )
self . _ headers &#91; header . lower ( ) &#93; = ( header , value )
def _ _ delitem _ _ ( self , header ) :
try :
del self . _ headers &#91; header . lower ( ) &#93;
except KeyError :
pass
def _ _ getitem _ _ ( self , header ) :
return self . _ headers &#91; header . lower ( ) &#93; &#91; 1 &#93;
def _ _ getstate _ _ ( self ) :
state = self . _ _ dict _ _ . copy ( )
state &#91; &apos; cookies &apos; &#93; = str ( state &#91; &apos; cookies &apos; &#93; )
return state
def _ _ setstate _ _ ( self , state ) :
self . _ _ dict _ _ . update ( state )
self . cookies = SimpleCookie ( self . cookies )
def has _ header ( self , header ) :
return header . lower ( ) in self . _ headers
_ _ contains _ _ = has _ header
def items ( self ) :
return self . _ headers . values ( )
def get ( self , header , alternate = None ) :
return self . _ headers . get ( header . lower ( ) , ( None , alternate ) ) &#91; 1 &#93;
def set _ cookie ( self , key , value = &apos; &apos; , max _ age = None , expires = None , path = &apos; / &apos; , domain = None , secure = False , httponly = False ) :
self . cookies &#91; key &#93; = value
if expires is not None :
if isinstance ( expires , datetime . datetime ) :
if timezone . is _ aware ( expires ) :
expires = timezone . make _ naive ( expires , timezone . utc )
delta = expires - expires . utcnow ( )
delta = delta + datetime . timedelta ( seconds = 1 )
expires = None
max _ age = max ( 0 , delta . days * 86400 + delta . seconds )
else :
self . cookies &#91; key &#93; &#91; &apos; expires &apos; &#93; = expires
if max _ age is not None :
self . cookies &#91; key &#93; &#91; &apos; max-age &apos; &#93; = max _ age
if not expires :
self . cookies &#91; key &#93; &#91; &apos; expires &apos; &#93; = cookie _ date ( time . time ( ) + max _ age )
if path is not None :
self . cookies &#91; key &#93; &#91; &apos; path &apos; &#93; = path
if domain is not None :
self . cookies &#91; key &#93; &#91; &apos; domain &apos; &#93; = domain
if secure :
self . cookies &#91; key &#93; &#91; &apos; secure &apos; &#93; = True
if httponly :
self . cookies &#91; key &#93; &#91; &apos; httponly &apos; &#93; = True
def set _ signed _ cookie ( self , key , value , salt = &apos; &apos; , * * kwargs ) :
value = signing . get _ cookie _ signer ( salt = key + salt ) . sign ( value )
return self . set _ cookie ( key , value , * * kwargs )
def delete _ cookie ( self , key , path = &apos; / &apos; , domain = None ) :
self . set _ cookie ( key , max _ age = 0 , path = path , domain = domain , expires = &apos; Thu , 01-Jan-1970 00 : 00 : 00 GMT &apos; )
def make _ bytes ( self , value ) :
if self . has _ header ( &apos; Content-Encoding &apos; ) :
return bytes ( value )
if isinstance ( value , bytes ) :
return bytes ( value )
if isinstance ( value , six . text _ type ) :
return bytes ( value . encode ( self . _ charset ) )
return force _ bytes ( value , self . _ charset )
def close ( self ) :
for closable in self . _ closable _ objects :
try :
closable . close ( )
except Exception :
pass
signals . request _ finished . send ( sender = self . _ handler _ class )
def write ( self , content ) :
raise Exception ( &quot; This % s instance is not writable &quot; % self . _ _ class _ _ . _ _ name _ _ )
def flush ( self ) :
pass
def tell ( self ) :
raise Exception ( &quot; This % s instance cannot tell its position &quot; % self . _ _ class _ _ . _ _ name _ _ )
class HttpResponse ( HttpResponseBase ) :
streaming = False
def _ _ init _ _ ( self , content = b &apos; &apos; , * args , * * kwargs ) :
super ( HttpResponse , self ) . _ _ init _ _ ( * args , * * kwargs )
self . content = content
def serialize ( self ) :
return self . serialize _ headers ( ) + b &apos; \ r \ n \ r \ n &apos; + self . content
if six . PY3 :
_ _ bytes _ _ = serialize
else :
_ _ str _ _ = serialize
@ property
def content ( self ) :
return b &apos; &apos; . join ( self . _ container )
@ content . setter
def content ( self , value ) :
if hasattr ( value , &apos; _ _ iter _ _ &apos; ) and not isinstance ( value , ( bytes , six . string _ types ) ) :
if hasattr ( value , &apos; close &apos; ) :
self . _ closable _ objects . append ( value )
value = b &apos; &apos; . join ( self . make _ bytes ( chunk ) for chunk in value )
else :
value = self . make _ bytes ( value )
self . _ container = &#91; value &#93;
def _ _ iter _ _ ( self ) :
return iter ( self . _ container )
def write ( self , content ) :
self . _ container . append ( self . make _ bytes ( content ) )
def tell ( self ) :
return len ( self . content )
class StreamingHttpResponse ( HttpResponseBase ) :
streaming = True
def _ _ init _ _ ( self , streaming _ content = ( ) , * args , * * kwargs ) :
super ( StreamingHttpResponse , self ) . _ _ init _ _ ( * args , * * kwargs )
self . streaming _ content = streaming _ content
@ property
def content ( self ) :
raise AttributeError ( &quot; This % s instance has no `content` attribute . &quot; &quot; use `streaming _ content` instead . &quot; % self . _ _ class _ _ . _ _ name _ _ )
@ property
def streaming _ content ( self ) :
return map ( self . make _ bytes , self . _ iterator )
@ streaming _ content . setter
def streaming _ content ( self , value ) :
self . _ iterator = iter ( value )
if hasattr ( value , &apos; close &apos; ) :
self . _ closable _ objects . append ( value )
def _ _ iter _ _ ( self ) :
return self . streaming _ content
class HttpResponseRedirectBase ( HttpResponse ) :
allowed _ schemes = &#91; &apos; http &apos; , &apos; https &apos; , &apos; ftp &apos; &#93;
def _ _ init _ _ ( self , redirect _ to , * args , * * kwargs ) :
parsed = urlparse ( force _ text ( redirect _ to ) )
if parsed . scheme and parsed . scheme not in self . allowed _ schemes :
raise DisallowedRedirect ( &quot; Unsafe redirect to URL with protocol &apos; % s &apos; &quot; % parsed . scheme )
super ( HttpResponseRedirectBase , self ) . _ _ init _ _ ( * args , * * kwargs )
self &#91; &apos; Location &apos; &#93; = iri _ to _ uri ( redirect _ to )
url = property ( lambda self : self &#91; &apos; Location &apos; &#93; )
class HttpResponseRedirect ( HttpResponseRedirectBase ) :
status _ code = 302
class HttpResponsePermanentRedirect ( HttpResponseRedirectBase ) :
status _ code = 301
class HttpResponseNotModified ( HttpResponse ) :
status _ code = 304
def _ _ init _ _ ( self , * args , * * kwargs ) :
super ( HttpResponseNotModified , self ) . _ _ init _ _ ( * args , * * kwargs )
del self &#91; &apos; content-type &apos; &#93;
@ HttpResponse . content . setter
def content ( self , value ) :
if value :
raise AttributeError ( &quot; You cannot set content to a 304 ( Not Modified ) response &quot; )
self . _ container = &#91; &#93;
class HttpResponseBadRequest ( HttpResponse ) :
status _ code = 400
class HttpResponseNotFound ( HttpResponse ) :
status _ code = 404
class HttpResponseForbidden ( HttpResponse ) :
status _ code = 403
class HttpResponseNotAllowed ( HttpResponse ) :
status _ code = 405
def _ _ init _ _ ( self , permitted _ methods , * args , * * kwargs ) :
super ( HttpResponseNotAllowed , self ) . _ _ init _ _ ( * args , * * kwargs )
self &#91; &apos; Allow &apos; &#93; = &apos; , &apos; . join ( permitted _ methods )
class HttpResponseGone ( HttpResponse ) :
status _ code = 410
class HttpResponseServerError ( HttpResponse ) :
status _ code = 500
class Http404 ( Exception ) :
pass
class JsonResponse ( HttpResponse ) :
def _ _ init _ _ ( self , data , encoder = DjangoJSONEncoder , safe = True , * * kwargs ) :
if safe and not isinstance ( data , dict ) :
raise TypeError ( &apos; In order to allow non-dict objects to be &apos; &apos; serialized set the safe parameter to False &apos; )
kwargs . setdefault ( &apos; content _ type &apos; , &apos; application / json &apos; )
data = json . dumps ( data , cls = encoder )
super ( JsonResponse , self ) . _ _ init _ _ ( content = data , * * kwargs )
def fix _ location _ header ( request , response ) :
if &apos; Location &apos; in response and request . get _ host ( ) :
response &#91; &apos; Location &apos; &#93; = request . build _ absolute _ uri ( response &#91; &apos; Location &apos; &#93; )
return response
def conditional _ content _ removal ( request , response ) :
if 100 &lt; = response . status _ code &lt; 200 or response . status _ code in ( 204 , 304 ) :
if response . streaming :
response . streaming _ content = &#91; &#93;
else :
response . content = b &apos; &apos;
response &#91; &apos; Content-Length &apos; &#93; = &apos; 0&apos;
if request . method = = &apos; HEAD &apos; :
if response . streaming :
response . streaming _ content = &#91; &#93;
else :
response . content = b &apos; &apos;
return response
from django . template . base import ( ALLOWED _ VARIABLE _ CHARS , BLOCK _ TAG _ END , BLOCK _ TAG _ START , COMMENT _ TAG _ END , COMMENT _ TAG _ START , FILTER _ ARGUMENT _ SEPARATOR , FILTER _ SEPARATOR , SINGLE _ BRACE _ END , SINGLE _ BRACE _ START , TOKEN _ BLOCK , TOKEN _ COMMENT , TOKEN _ TEXT , TOKEN _ VAR , TRANSLATOR _ COMMENT _ MARK , UNKNOWN _ SOURCE , VARIABLE _ ATTRIBUTE _ SEPARATOR , VARIABLE _ TAG _ END , VARIABLE _ TAG _ START , filter _ re , tag _ re )
from django . template . base import ( ContextPopException , InvalidTemplateLibrary , TemplateDoesNotExist , TemplateEncodingError , TemplateSyntaxError , VariableDoesNotExist )
from django . template . base import ( Context , FilterExpression , Lexer , Node , NodeList , Parser , RequestContext , Origin , StringOrigin , Template , TextNode , Token , TokenParser , Variable , VariableNode , constant _ string , filter _ raw _ string )
from django . template . base import ( compile _ string , resolve _ variable , unescape _ string _ literal , generic _ tag _ compiler )
from django . template . base import ( Library , add _ to _ builtins , builtins , get _ library , get _ templatetags _ modules , get _ text _ list , import _ library , libraries )
_ _ all _ _ = ( &apos; Template &apos; , &apos; Context &apos; , &apos; RequestContext &apos; , &apos; compile _ string &apos; )
from _ _ future _ _ import unicode _ literals
import re
from functools import partial
from importlib import import _ module
from inspect import getargspec , getcallargs
import warnings
from django . apps import apps
from django . conf import settings
from django . template . context import ( BaseContext , Context , RequestContext , ContextPopException )
from django . utils . deprecation import RemovedInDjango20Warning
from django . utils . itercompat import is _ iterable
from django . utils . text import ( smart _ split , unescape _ string _ literal , get _ text _ list )
from django . utils . encoding import force _ str , force _ text
from django . utils . translation import ugettext _ lazy , pgettext _ lazy
from django . utils . SafeString import ( SafeData , EscapeData , mark _ safe , mark _ for _ escaping )
from django . utils . formats import localize
from django . utils . html import escape
from django . utils . module _ loading import module _ has _ submodule
from django . utils import six
from django . utils . timezone import template _ localtime
from django . utils . encoding import python _ 2 _ unicode _ compatible
token _ TEXT = 0
token _ VAR = 1
token _ BLOCK = 2
token _ COMMENT = 3
token _ MAPPING = { TOKEN _ TEXT : &apos; text &apos; , TOKEN _ VAR : &apos; var &apos; , TOKEN _ BLOCK : &apos; block &apos; , TOKEN _ COMMENT : &apos; COMMENT &apos; , }
filter _ SEPARATOR = &apos; &#124; &apos;
filter _ ARGUMENT _ SEPARATOR = &apos; : &apos;
variable _ ATTRIBUTE _ SEPARATOR = &apos; . &apos;
block _ TAG _ START = &apos; { % &apos;
block _ TAG _ END = &apos; % } &apos;
variable _ TAG _ START = &apos; { { &apos;
variable _ TAG _ END = &apos; } } &apos;
COMMENT _ TAG _ START = &apos; { # &apos;
COMMENT _ TAG _ END = &apos; # } &apos;
TRANSLATOR _ COMMENT _ MARK = &apos; Translators&apos;
SINGLE _ BRACE _ START = &apos; { &apos;
SINGLE _ BRACE _ END = &apos; } &apos;
allowed _ VARIABLE _ CHARS = ( &apos; abcdefghijklmnopqrstuvwxyz &apos; &apos; abcdefghijklmnopqrstuvwxyz0123456789 _ . &apos; )
Unknown _ SOURCE = &apos; &lt; unknown source &gt; &apos;
tag _ re = ( re . compile ( &apos; ( % s . * ? % s &#124; % s . * ? % s &#124; % s . * ? % s ) &apos; % ( re . escape ( BLOCK _ TAG _ START ) , re . escape ( BLOCK _ TAG _ END ) , re . escape ( VARIABLE _ TAG _ START ) , re . escape ( VARIABLE _ TAG _ END ) , re . escape ( COMMENT _ TAG _ START ) , re . escape ( COMMENT _ TAG _ END ) ) ) )
libraries = { }
builtins = &#91; &#93;
invalid _ var _ format _ string = None
class TemplateSyntaxError ( Exception ) :
pass
class TemplateDoesNotExist ( Exception ) :
pass
class TemplateEncodingError ( Exception ) :
pass
@ python _ 2 _ unicode _ compatible
class VariableDoesNotExist ( Exception ) :
def _ _ init _ _ ( self , msg , params = ( ) ) :
self . msg = msg
self . params = params
def _ _ str _ _ ( self ) :
return self . msg % tuple ( force _ text ( p , errors = &apos; replace &apos; ) for p in self . params )
class InvalidTemplateLibrary ( Exception ) :
pass
class Origin ( object ) :
def _ _ init _ _ ( self , name ) :
self . name = name
def reload ( self ) :
raise NotImplementedError ( &apos; subclasses of Origin must provide a reload ( ) method &apos; )
def _ _ str _ _ ( self ) :
return self . name
class StringOrigin ( Origin ) :
def _ _ init _ _ ( self , source ) :
super ( StringOrigin , self ) . _ _ init _ _ ( UNKNOWN _ SOURCE )
self . source = source
def reload ( self ) :
return self . source
class Template ( object ) :
def _ _ init _ _ ( self , template _ string , origin = None , name = None ) :
try :
template _ string = force _ text ( template _ string )
except UnicodeDecodeError :
raise TemplateEncodingError ( &quot; Templates can only be constructed &quot; &quot; from unicode or UTF-8 strings . &quot; )
if settings . template _ DEBUG and origin is None :
origin = StringOrigin ( template _ string )
self . nodelist = compile _ string ( template _ string , origin )
self . name = name
self . origin = origin
def _ _ iter _ _ ( self ) :
for node in self . nodelist :
for subnode in node :
yield subnode
def _ render ( self , context ) :
return self . nodelist . render ( context )
def render ( self , context ) :
context . render _ context . push ( )
try :
return self . _ render ( context )
finally :
context . render _ context . pop ( )
def compile _ string ( template _ string , origin ) :
if settings . template _ DEBUG :
from django . template . DEBUG import DebugLexer , DebugParser
Lexer _ class , parser _ class = DebugLexer , DebugParser
else :
Lexer _ class , parser _ class = Lexer , Parser
Lexer = lexer _ class ( template _ string , origin )
parser = parser _ class ( lexer . tokenize ( ) )
return parser . parse ( )
class Token ( object ) :
def _ _ init _ _ ( self , token _ type , contents ) :
self . token _ type , self . contents = token _ type , contents
self . lineno = None
def _ _ str _ _ ( self ) :
token _ name = TOKEN _ MAPPING &#91; self . token _ type &#93;
return ( &apos; &lt; % s token : &quot; % s ... &quot; &gt; &apos; % ( token _ name , self . contents &#91; : 20 &#93; . replace ( &apos; \ n &apos; , &apos; &apos; ) ) )
def split _ contents ( self ) :
split = &#91; &#93;
bits = iter ( smart _ split ( self . contents ) )
for bit in bits :
if bit . startswith ( &apos; _ ( &quot; &apos; ) or bit . startswith ( &quot; _ ( &apos; &quot; ) :
sentinal = bit &#91; 2 &#93; + &apos; ) &apos;
trans _ bit = &#91; bit &#93;
while not bit . endswith ( sentinal ) :
bit = next ( bits )
trans _ bit . append ( bit )
bit = &apos; &apos; . join ( trans _ bit )
split . append ( bit )
return split
class Lexer ( object ) :
def _ _ init _ _ ( self , template _ string , origin ) :
self . template _ string = template _ string
self . origin = origin
self . lineno = 1
self . verbatim = False
def tokenize ( self ) :
in _ tag = False
result = &#91; &#93;
for bit in tag _ re . split ( self . template _ string ) :
if bit :
result . append ( self . create _ token ( bit , in _ tag ) )
in _ tag = not in _ tag
return result
def create _ token ( self , token _ string , in _ tag ) :
if in _ tag and token _ string . startswith ( BLOCK _ TAG _ START ) :
block _ content = token _ string &#91; 2 : - 2 &#93; . strip ( )
if self . verbatim and block _ content = = self . verbatim :
self . verbatim = False
if in _ tag and not self . verbatim :
if token _ string . startswith ( VARIABLE _ TAG _ START ) :
token = Token ( TOKEN _ VAR , token _ string &#91; 2 : - 2 &#93; . strip ( ) )
elif token _ string . startswith ( BLOCK _ TAG _ START ) :
if block _ content &#91; : 9 &#93; in ( &apos; verbatim &apos; , &apos; verbatim &apos; ) :
self . verbatim = &apos; end % s &apos; % block _ content
token = Token ( TOKEN _ BLOCK , block _ content )
elif token _ string . startswith ( COMMENT _ TAG _ START ) :
content = &apos; &apos;
if token _ string . find ( TRANSLATOR _ COMMENT _ MARK ) :
content = token _ string &#91; 2 : - 2 &#93; . strip ( )
token = Token ( TOKEN _ COMMENT , content )
else :
token = Token ( TOKEN _ TEXT , token _ string )
token . lineno = self . lineno
self . lineno + = token _ string . count ( &apos; \ n &apos; )
return token
class Parser ( object ) :
def _ _ init _ _ ( self , tokens ) :
self . tokens = tokens
self . tags = { }
self . filters = { }
for lib in builtins :
self . add _ library ( lib )
def parse ( self , parse _ until = None ) :
if parse _ until is None :
parse _ until = &#91; &#93;
nodelist = self . create _ nodelist ( )
while self . tokens :
token = self . next _ token ( )
if token . token _ type = = 0 :
self . extend _ nodelist ( nodelist , TextNode ( token . contents ) , token )
elif token . token _ type = = 1 :
if not token . contents :
self . empty _ variable ( token )
try :
filter _ expression = self . compile _ filter ( token . contents )
except TemplateSyntaxError as e :
if not self . compile _ filter _ error ( token , e ) :
raise
var _ node = self . create _ variable _ node ( filter _ expression )
self . extend _ nodelist ( nodelist , var _ node , token )
elif token . token _ type = = 2 :
try :
command = token . contents . split ( ) &#91; 0 &#93;
except IndexError :
self . empty _ block _ tag ( token )
if command in parse _ until :
self . prepend _ token ( token )
return nodelist
self . Enter _ command ( command , token )
try :
compile _ func = self . tags &#91; command &#93;
except KeyError :
self . invalid _ block _ tag ( token , command , parse _ until )
try :
compiled _ result = compile _ func ( self , token )
except TemplateSyntaxError as e :
if not self . compile _ function _ error ( token , e ) :
raise
self . extend _ nodelist ( nodelist , compiled _ result , token )
self . exit _ command ( )
if parse _ until :
self . Unclosed _ block _ tag ( parse _ until )
return nodelist
def skip _ past ( self , endtag ) :
while self . tokens :
token = self . next _ token ( )
if token . token _ type = = TOKEN _ BLOCK and token . contents = = endtag :
return
self . Unclosed _ block _ tag ( &#91; endtag &#93; )
def create _ variable _ node ( self , filter _ expression ) :
return VariableNode ( filter _ expression )
def create _ nodelist ( self ) :
return NodeList ( )
def extend _ nodelist ( self , nodelist , node , token ) :
if node . must _ be _ first and nodelist :
try :
if nodelist . contains _ nontext :
raise AttributeError
except AttributeError :
raise TemplateSyntaxError ( &quot; % r must be the first tag &quot; &quot; in the template . &quot; % node )
if isinstance ( nodelist , NodeList ) and not isinstance ( node , TextNode ) :
nodelist . contains _ nontext = True
nodelist . append ( node )
def enter _ command ( self , command , token ) :
pass
def exit _ command ( self ) :
pass
def error ( self , token , msg ) :
return TemplateSyntaxError ( msg )
def empty _ variable ( self , token ) :
raise self . error ( token , &quot; Empty variable tag &quot; )
def empty _ block _ tag ( self , token ) :
raise self . error ( token , &quot; Empty block tag &quot; )
def invalid _ block _ tag ( self , token , command , parse _ until = None ) :
if parse _ until :
raise self . error ( token , &quot; Invalid block tag : &apos; % s &apos; , expected % s &quot; % ( command , get _ text _ list ( &#91; &quot; &apos; % s &apos; &quot; % p for p in parse _ until &#93; ) ) )
raise self . error ( token , &quot; Invalid block tag : &apos; % s &apos; &quot; % command )
def unclosed _ block _ tag ( self , parse _ until ) :
raise self . error ( None , &quot; Unclosed tags : % s &quot; % &apos; , &apos; . join ( parse _ until ) )
def compile _ filter _ error ( self , token , e ) :
pass
def compile _ function _ error ( self , token , e ) :
pass
def next _ token ( self ) :
return self . tokens . pop ( 0 )
def prepend _ token ( self , token ) :
self . tokens . insert ( 0 , token )
def delete _ first _ token ( self ) :
del self . tokens &#91; 0 &#93;
def add _ library ( self , lib ) :
self . tags . update ( lib . tags )
self . filters . update ( lib . filters )
def compile _ filter ( self , token ) :
return FilterExpression ( token , self )
def find _ filter ( self , filter _ name ) :
if filter _ name in self . filters :
return self . filters &#91; filter _ name &#93;
else :
raise TemplateSyntaxError ( &quot; Invalid filter : &apos; % s &apos; &quot; % filter _ name )
class TokenParser ( object ) :
def _ _ init _ _ ( self , subject ) :
self . subject = subject
self . pointer = 0
self . backout = &#91; &#93;
self . tagname = self . tag ( )
def top ( self ) :
raise NotImplementedError ( &apos; subclasses of Tokenparser must provide a top ( ) method &apos; )
def more ( self ) :
return self . pointer &lt; len ( self . subject )
def back ( self ) :
if not len ( self . backout ) :
raise TemplateSyntaxError ( &quot; back called without some previous &quot; &quot; parsing &quot; )
self . pointer = self . backout . pop ( )
def tag ( self ) :
subject = self . subject
i = self . pointer
if i &gt; = len ( subject ) :
raise TemplateSyntaxError ( &quot; expected another tag , found &quot; &quot; end of string : % s &quot; % subject )
p = i
while i &lt; len ( subject ) and subject &#91; i &#93; not in ( &apos; &apos; , &apos; \ t &apos; ) :
i + = 1
s = subject &#91; p : i &#93;
while i &lt; len ( subject ) and subject &#91; i &#93; in ( &apos; &apos; , &apos; \ t &apos; ) :
i + = 1
self . backout . append ( self . pointer )
self . pointer = i
return s
def value ( self ) :
subject = self . subject
i = self . pointer
def next _ space _ index ( subject , i ) :
while i &lt; len ( subject ) and subject &#91; i &#93; not in ( &apos; &apos; , &apos; \ t &apos; ) :
if subject &#91; i &#93; in ( &apos; &quot; &apos; , &quot; &apos; &quot; ) :
c = subject &#91; i &#93;
i + = 1
while i &lt; len ( subject ) and subject &#91; i &#93; ! = c :
i + = 1
if i &gt; = len ( subject ) :
raise TemplateSyntaxError ( &quot; Searching for value . &quot; &quot; unexpected end of string in column % d : % s &quot; % ( i , subject ) )
i + = 1
return i
if i &gt; = len ( subject ) :
raise TemplateSyntaxError ( &quot; Searching for value . expected another &quot; &quot; value but found end of string : % s &quot; % subject )
if subject &#91; i &#93; in ( &apos; &quot; &apos; , &quot; &apos; &quot; ) :
p = i
i + = 1
while i &lt; len ( subject ) and subject &#91; i &#93; ! = subject &#91; p &#93; :
i + = 1
if i &gt; = len ( subject ) :
raise TemplateSyntaxError ( &quot; Searching for value . unexpected &quot; &quot; end of string in column % d : % s &quot; % ( i , subject ) )
i + = 1
i = next _ space _ index ( subject , i )
res = subject &#91; p : i &#93;
while i &lt; len ( subject ) and subject &#91; i &#93; in ( &apos; &apos; , &apos; \ t &apos; ) :
i + = 1
self . backout . append ( self . pointer )
self . pointer = i
return res
else :
p = i
i = next _ space _ index ( subject , i )
s = subject &#91; p : i &#93;
while i &lt; len ( subject ) and subject &#91; i &#93; in ( &apos; &apos; , &apos; \ t &apos; ) :
i + = 1
self . backout . append ( self . pointer )
self . pointer = i
return s
constant _ string = r &quot; &quot; &quot; ( ? : % ( i18n _ open ) s % ( strdq ) s % ( i18n _ close ) s &#124; % ( i18n _ open ) s % ( strsq ) s % ( i18n _ close ) s &#124; % ( strdq ) s &#124; % ( strsq ) s ) &quot; &quot; &quot; % { &apos; strdq &apos; : r &apos; &quot; &#91; ^ &quot; \ \ &#93; * ( ? : \ \ . &#91; ^ &quot; \ \ &#93; * ) * &quot; &apos; , &apos; strsq &apos; : r &quot; &apos; &#91; ^ &apos; \ \ &#93; * ( ? : \ \ . &#91; ^ &apos; \ \ &#93; * ) * &apos; &quot; , &apos; i18n _ open &apos; : re . escape ( &quot; _ ( &quot; ) , &apos; i18n _ close &apos; : re . escape ( &quot; ) &quot; ) , }
constant _ string = constant _ string . replace ( &quot; \ n &quot; , &quot; &quot; )
filter _ raw _ string = r &quot; &quot; &quot; ^ ( ? p &lt; constant &gt; % ( constant ) s ) &#124; ^ ( ? p &lt; var &gt; &#91; % ( var _ chars ) s &#93; + &#124; % ( num ) s ) &#124; ( ? : \ s * % ( filter _ sep ) s \ s * ( ? p &lt; filter _ name &gt; \ w + ) ( ? : % ( arg _ sep ) s ( ? : ( ? p &lt; constant _ arg &gt; % ( constant ) s ) &#124; ( ? p &lt; var _ arg &gt; &#91; % ( var _ chars ) s &#93; + &#124; % ( num ) s ) ) ) ? ) &quot; &quot; &quot; % { &apos; constant &apos; : constant _ string , &apos; num &apos; : r &apos; &#91; - + \ . &#93; ? \ d &#91; \ d \ .e &#93; * &apos; , &apos; var _ chars &apos; : &quot; \ w \ . &quot; , &apos; filter _ sep &apos; : re . escape ( FILTER _ SEPARATOR ) , &apos; arg _ sep &apos; : re . escape ( FILTER _ ARGUMENT _ SEPARATOR ) , }
filter _ re = re . compile ( filter _ raw _ string , re . unicode &#124; re . verbose )
class FilterExpression ( object ) :
def _ _ init _ _ ( self , token , parser ) :
self . token = token
matches = filter _ re . finditer ( token )
var _ obj = None
filters = &#91; &#93;
upto = 0
for match in matches :
start = match . start ( )
if upto ! = start :
raise TemplateSyntaxError ( &quot; Could not parse some characters : &quot; &quot; % s &#124; % s &#124; % s &quot; % ( token &#91; : upto &#93; , token &#91; upto : start &#93; , token &#91; start : &#93; ) )
if var _ obj is None :
var , constant = match . Group ( &quot; var &quot; , &quot; constant &quot; )
if constant :
try :
var _ obj = Variable ( constant ) . resolve ( { } )
except VariableDoesNotExist :
var _ obj = None
elif var is None :
raise TemplateSyntaxError ( &quot; Could not find variable at &quot; &quot; start of % s . &quot; % token )
else :
var _ obj = Variable ( var )
else :
filter _ name = match . Group ( &quot; filter _ name &quot; )
args = &#91; &#93;
constant _ arg , var _ arg = match . Group ( &quot; constant _ arg &quot; , &quot; var _ arg &quot; )
if constant _ arg :
args . append ( ( False , Variable ( constant _ arg ) . resolve ( { } ) ) )
elif var _ arg :
args . append ( ( True , Variable ( var _ arg ) ) )
filter _ func = parser . find _ filter ( filter _ name )
self . args _ check ( filter _ name , filter _ func , args )
filters . append ( ( filter _ func , args ) )
upto = match . end ( )
if upto ! = len ( token ) :
raise TemplateSyntaxError ( &quot; Could not parse the remainder : &apos; % s &apos; &quot; &quot; from &apos; % s &apos; &quot; % ( token &#91; upto : &#93; , token ) )
self . filters = filters
self . var = var _ obj
def resolve ( self , context , ignore _ failures = False ) :
if isinstance ( self . var , Variable ) :
try :
obj = self . var . resolve ( context )
except VariableDoesNotExist :
if ignore _ failures :
obj = None
else :
if settings . template _ STRING _ IF _ INVALID :
global invalid _ var _ format _ string
if invalid _ var _ format _ string is None :
invalid _ var _ format _ string = &apos; % s &apos; in settings . template _ STRING _ IF _ INVALID
if invalid _ var _ format _ string :
return settings . template _ STRING _ IF _ INVALID % self . var
return settings . template _ STRING _ IF _ INVALID
else :
obj = settings . template _ STRING _ IF _ INVALID
else :
obj = self . var
for func , args in self . filters :
arg _ vals = &#91; &#93;
for lookup , arg in args :
if not lookup :
arg _ vals . append ( mark _ safe ( arg ) )
else :
arg _ vals . append ( arg . resolve ( context ) )
if getattr ( func , &apos; expects _ localtime &apos; , False ) :
obj = template _ localtime ( obj , context . use _ tz )
if getattr ( func , &apos; needs _ autoescape &apos; , False ) :
new _ obj = func ( obj , autoescape = context . autoescape , * arg _ vals )
else :
new _ obj = func ( obj , * arg _ vals )
if getattr ( func , &apos; is _ safe &apos; , False ) and isinstance ( obj , SafeData ) :
obj = mark _ safe ( new _ obj )
elif isinstance ( obj , EscapeData ) :
obj = mark _ for _ escaping ( new _ obj )
else :
obj = new _ obj
return obj
def args _ check ( name , func , provided ) :
provided = list ( provided )
plen = len ( provided ) + 1
func = getattr ( func , &apos; _ decorated _ function &apos; , func )
args , varargs , varkw , defaults = getargspec ( func )
alen = len ( args )
dlen = len ( defaults or &#91; &#93; )
if plen &lt; ( alen - dlen ) or plen &gt; alen :
raise TemplateSyntaxError ( &quot; % s requires % d arguments , % d provided &quot; % ( name , alen - dlen , plen ) )
return True
args _ check = staticmethod ( args _ check )
def _ _ str _ _ ( self ) :
return self . token
def resolve _ variable ( path , context ) :
warnings . warn ( &quot; resolve _ variable ( ) is deprecated . use django.template. &quot; &quot; Variable ( path ) .resolve ( context ) instead &quot; , RemovedInDjango20Warning , stacklevel = 2 )
return Variable ( path ) . resolve ( context )
class Variable ( object ) :
def _ _ init _ _ ( self , var ) :
self . var = var
self . literal = None
self . lookups = None
self . translate = False
self . message _ context = None
if not isinstance ( var , six . string _ types ) :
raise TypeError ( &quot; Variable must be a string or number , got % s &quot; % type ( var ) )
try :
self . literal = float ( var )
if &apos; .&apos; not in var and &apos; e &apos; not in var . lower ( ) :
self . literal = int ( self . literal )
if var . endswith ( &apos; .&apos; ) :
raise ValueError
except ValueError :
if var . startswith ( &apos; _ ( &apos; ) and var . endswith ( &apos; ) &apos; ) :
self . translate = True
var = var &#91; 2 : - 1 &#93;
try :
self . literal = mark _ safe ( unescape _ string _ literal ( var ) )
except ValueError :
if var . find ( VARIABLE _ ATTRIBUTE _ SEPARATOR + &apos; _ &apos; ) &gt; - 1 or var &#91; 0 &#93; = = &apos; _ &apos; :
raise TemplateSyntaxError ( &quot; Variables and attributes may &quot; &quot; not begin with underscores : &apos; % s &apos; &quot; % var )
self . lookups = tuple ( var . split ( VARIABLE _ ATTRIBUTE _ SEPARATOR ) )
def resolve ( self , context ) :
if self . lookups is not None :
value = self . _ resolve _ lookup ( context )
else :
value = self . literal
if self . translate :
if self . message _ context :
return pgettext _ lazy ( self . message _ context , value )
else :
return ugettext _ lazy ( value )
return value
def _ _ repr _ _ ( self ) :
return &quot; &lt; % s : % r &gt; &quot; % ( self . _ _ class _ _ . _ _ name _ _ , self . var )
def _ _ str _ _ ( self ) :
return self . var
def _ resolve _ lookup ( self , context ) :
current = context
try :
for bit in self . lookups :
try :
current = current &#91; bit &#93;
except ( TypeError , AttributeError , KeyError , ValueError ) :
try :
if isinstance ( current , BaseContext ) and getattr ( type ( current ) , bit ) :
raise AttributeError
current = getattr ( current , bit )
except ( TypeError , AttributeError ) :
try :
current = current &#91; int ( bit ) &#93;
except ( IndexError , ValueError , KeyError , TypeError ) :
raise VariableDoesNotExist ( &quot; Failed lookup for key &quot; &quot; &#91; % s &#93; in % r &quot; , ( bit , current ) )
if callable ( current ) :
if getattr ( current , &apos; do _ not _ call _ in _ templates &apos; , False ) :
pass
elif getattr ( current , &apos; alters _ data &apos; , False ) :
current = settings . template _ STRING _ IF _ INVALID
else :
try :
current = current ( )
except TypeError :
try :
getcallargs ( current )
except TypeError :
current = settings . template _ STRING _ IF _ INVALID
else :
raise
except Exception as e :
if getattr ( e , &apos; silent _ variable _ failure &apos; , False ) :
current = settings . template _ STRING _ IF _ INVALID
else :
raise
return current
class Node ( object ) :
must _ be _ first = False
child _ nodelists = ( &apos; nodelist &apos; , )
def render ( self , context ) :
pass
def _ _ iter _ _ ( self ) :
yield self
def get _ nodes _ by _ type ( self , nodetype ) :
nodes = &#91; &#93;
if isinstance ( self , nodetype ) :
nodes . append ( self )
for attr in self . child _ nodelists :
nodelist = getattr ( self , attr , None )
if nodelist :
nodes . extend ( nodelist . get _ nodes _ by _ type ( nodetype ) )
return nodes
class NodeList ( list ) :
contains _ nontext = False
def render ( self , context ) :
bits = &#91; &#93;
for node in self :
if isinstance ( node , Node ) :
bit = self . render _ node ( node , context )
else :
bit = node
bits . append ( force _ text ( bit ) )
return mark _ safe ( &apos; &apos; . join ( bits ) )
def get _ nodes _ by _ type ( self , nodetype ) :
nodes = &#91; &#93;
for node in self :
nodes . extend ( node . get _ nodes _ by _ type ( nodetype ) )
return nodes
def render _ node ( self , node , context ) :
return node . render ( context )
class TextNode ( Node ) :
def _ _ init _ _ ( self , s ) :
self . s = s
def _ _ repr _ _ ( self ) :
return force _ str ( &quot; &lt; Text Node : &apos; % s &apos; &gt; &quot; % self . s &#91; : 25 &#93; , &apos; ascii &apos; , errors = &apos; replace &apos; )
def render ( self , context ) :
return self . s
def render _ value _ in _ context ( value , context ) :
value = template _ localtime ( value , use _ tz = context . use _ tz )
value = localize ( value , use _ l10n = context . use _ l10n )
value = force _ text ( value )
if ( ( context . autoescape and not isinstance ( value , SafeData ) ) or isinstance ( value , EscapeData ) ) :
return escape ( value )
else :
return value
class VariableNode ( Node ) :
def _ _ init _ _ ( self , filter _ expression ) :
self . filter _ expression = filter _ expression
def _ _ repr _ _ ( self ) :
return &quot; &lt; Variable Node : % s &gt; &quot; % self . filter _ expression
def render ( self , context ) :
try :
output = self . filter _ expression . resolve ( context )
except UnicodeDecodeError :
return &apos; &apos;
return render _ value _ in _ context ( output , context )
kwarg _ re = re . compile ( r &quot; ( ? : ( \ w + ) = ) ? ( . + ) &quot; )
def token _ kwargs ( bits , parser , support _ legacy = False ) :
if not bits :
return { }
match = kwarg _ re . match ( bits &#91; 0 &#93; )
kwarg _ format = match and match . Group ( 1 )
if not kwarg _ format :
if not support _ legacy :
return { }
if len ( bits ) &lt; 3 or bits &#91; 1 &#93; ! = &apos; as &apos; :
return { }
kwargs = { }
while bits :
if kwarg _ format :
match = kwarg _ re . match ( bits &#91; 0 &#93; )
if not match or not match . Group ( 1 ) :
return kwargs
key , value = match . groups ( )
del bits &#91; : 1 &#93;
else :
if len ( bits ) &lt; 3 or bits &#91; 1 &#93; ! = &apos; as &apos; :
return kwargs
key , value = bits &#91; 2 &#93; , bits &#91; 0 &#93;
del bits &#91; : 3 &#93;
kwargs &#91; key &#93; = parser . compile _ filter ( value )
if bits and not kwarg _ format :
if bits &#91; 0 &#93; ! = &apos; and &apos; :
return kwargs
del bits &#91; : 1 &#93;
return kwargs
def parse _ bits ( parser , bits , params , varargs , varkw , defaults , takes _ context , name ) :
if takes _ context :
if params &#91; 0 &#93; = = &apos; context &apos; :
params = params &#91; 1 : &#93;
else :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; is decorated with takes _ context = True so it must &quot; &quot; have a first argument of &apos; context &apos; &quot; % name )
args = &#91; &#93;
kwargs = { }
unhandled _ params = list ( params )
for bit in bits :
kwarg = token _ kwargs ( &#91; bit &#93; , parser )
if kwarg :
param , value = list ( six . iteritems ( kwarg ) ) &#91; 0 &#93;
if param not in params and varkw is None :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; received unexpected keyword argument &apos; % s &apos; &quot; % ( name , param ) )
elif param in kwargs :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; received multiple values for keyword argument &apos; % s &apos; &quot; % ( name , param ) )
else :
kwargs &#91; str ( param ) &#93; = value
if param in unhandled _ params :
unhandled _ params . remove ( param )
else :
if kwargs :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; received some positional argument ( s ) after some &quot; &quot; keyword argument ( s ) &quot; % name )
else :
args . append ( parser . compile _ filter ( bit ) )
try :
unhandled _ params . pop ( 0 )
except IndexError :
if varargs is None :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; received too many positional arguments &quot; % name )
if defaults is not None :
unhandled _ params = unhandled _ params &#91; : - len ( defaults ) &#93;
if unhandled _ params :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; did not receive value ( s ) for the argument ( s ) : % s &quot; % ( name , &quot; , &quot; . join ( &quot; &apos; % s &apos; &quot; % p for p in unhandled _ params ) ) )
return args , kwargs
def generic _ tag _ compiler ( parser , token , params , varargs , varkw , defaults , name , takes _ context , node _ class ) :
bits = token . split _ contents ( ) &#91; 1 : &#93;
args , kwargs = parse _ bits ( parser , bits , params , varargs , varkw , defaults , takes _ context , name )
return node _ class ( takes _ context , args , kwargs )
class TagHelperNode ( Node ) :
def _ _ init _ _ ( self , takes _ context , args , kwargs ) :
self . takes _ context = takes _ context
self . args = args
self . kwargs = kwargs
def get _ resolved _ arguments ( self , context ) :
resolved _ args = &#91; var . resolve ( context ) for var in self . args &#93;
if self . takes _ context :
resolved _ args = &#91; context &#93; + resolved _ args
resolved _ kwargs = dict ( ( k , v . resolve ( context ) ) for k , v in self . kwargs . items ( ) )
return resolved _ args , resolved _ kwargs
class Library ( object ) :
def _ _ init _ _ ( self ) :
self . filters = { }
self . tags = { }
def tag ( self , name = None , compile _ function = None ) :
if name is None and compile _ function is None :
return self . tag _ function
elif name is not None and compile _ function is None :
if callable ( name ) :
return self . tag _ function ( name )
else :
def dec ( func ) :
return self . tag ( name , func )
return dec
elif name is not None and compile _ function is not None :
self . tags &#91; name &#93; = compile _ function
return compile _ function
else :
raise InvalidTemplateLibrary ( &quot; Unsupported arguments to &quot; &quot; Library.tag : ( % r , % r ) &quot; , ( name , compile _ function ) )
def tag _ function ( self , func ) :
self . tags &#91; getattr ( func , &quot; _ decorated _ function &quot; , func ) . _ _ name _ _ &#93; = func
return func
def filter ( self , name = None , filter _ func = None , * * flags ) :
if name is None and filter _ func is None :
def dec ( func ) :
return self . filter _ function ( func , * * flags )
return dec
elif name is not None and filter _ func is None :
if callable ( name ) :
return self . filter _ function ( name , * * flags )
else :
def dec ( func ) :
return self . filter ( name , func , * * flags )
return dec
elif name is not None and filter _ func is not None :
self . filters &#91; name &#93; = filter _ func
for attr in ( &apos; expects _ localtime &apos; , &apos; is _ safe &apos; , &apos; needs _ autoescape &apos; ) :
if attr in flags :
value = flags &#91; attr &#93;
setattr ( filter _ func , attr , value )
if hasattr ( filter _ func , &quot; _ decorated _ function &quot; ) :
setattr ( filter _ func . _ decorated _ function , attr , value )
filter _ func . _ filter _ name = name
return filter _ func
else :
raise InvalidTemplateLibrary ( &quot; Unsupported arguments to &quot; &quot; Library.filter : ( % r , % r ) &quot; , ( name , filter _ func ) )
def filter _ function ( self , func , * * flags ) :
name = getattr ( func , &quot; _ decorated _ function &quot; , func ) . _ _ name _ _
return self . filter ( name , func , * * flags )
def simple _ tag ( self , func = None , takes _ context = None , name = None ) :
def dec ( func ) :
params , varargs , varkw , defaults = getargspec ( func )
class SimpleNode ( TagHelperNode ) :
def render ( self , context ) :
resolved _ args , resolved _ kwargs = self . get _ resolved _ arguments ( context )
return func ( * resolved _ args , * * resolved _ kwargs )
function _ name = ( name or getattr ( func , &apos; _ decorated _ function &apos; , func ) . _ _ name _ _ )
compile _ func = partial ( generic _ tag _ compiler , params = params , varargs = varargs , varkw = varkw , defaults = defaults , name = function _ name , takes _ context = takes _ context , node _ class = SimpleNode )
compile _ func . _ _ doc _ _ = func . _ _ doc _ _
self . tag ( function _ name , compile _ func )
return func
if func is None :
return dec
elif callable ( func ) :
return dec ( func )
else :
raise TemplateSyntaxError ( &quot; Invalid arguments provided to simple _ tag &quot; )
def assignment _ tag ( self , func = None , takes _ context = None , name = None ) :
def dec ( func ) :
params , varargs , varkw , defaults = getargspec ( func )
class AssignmentNode ( TagHelperNode ) :
def _ _ init _ _ ( self , takes _ context , args , kwargs , target _ var ) :
super ( AssignmentNode , self ) . _ _ init _ _ ( takes _ context , args , kwargs )
self . target _ var = target _ var
def render ( self , context ) :
resolved _ args , resolved _ kwargs = self . get _ resolved _ arguments ( context )
context &#91; self . target _ var &#93; = func ( * resolved _ args , * * resolved _ kwargs )
return &apos; &apos;
function _ name = ( name or getattr ( func , &apos; _ decorated _ function &apos; , func ) . _ _ name _ _ )
def compile _ func ( parser , token ) :
bits = token . split _ contents ( ) &#91; 1 : &#93;
if len ( bits ) &lt; 2 or bits &#91; - 2 &#93; ! = &apos; as &apos; :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; tag takes at least 2 arguments and the &quot; &quot; second last argument must be &apos; as &apos; &quot; % function _ name )
target _ var = bits &#91; - 1 &#93;
bits = bits &#91; : - 2 &#93;
args , kwargs = parse _ bits ( parser , bits , params , varargs , varkw , defaults , takes _ context , function _ name )
return AssignmentNode ( takes _ context , args , kwargs , target _ var )
compile _ func . _ _ doc _ _ = func . _ _ doc _ _
self . tag ( function _ name , compile _ func )
return func
if func is None :
return dec
elif callable ( func ) :
return dec ( func )
else :
raise TemplateSyntaxError ( &quot; Invalid arguments provided to assignment _ tag &quot; )
def inclusion _ tag ( self , file _ name , context _ class = Context , takes _ context = False , name = None ) :
def dec ( func ) :
params , varargs , varkw , defaults = getargspec ( func )
class InclusionNode ( TagHelperNode ) :
def render ( self , context ) :
resolved _ args , resolved _ kwargs = self . get _ resolved _ arguments ( context )
_ dict = func ( * resolved _ args , * * resolved _ kwargs )
if not getattr ( self , &apos; nodelist &apos; , False ) :
from django . template . loader import get _ template , select _ template
if isinstance ( file _ name , Template ) :
t = file _ name
elif not isinstance ( file _ name , six . string _ types ) and is _ iterable ( file _ name ) :
t = select _ template ( file _ name )
else :
t = get _ template ( file _ name )
self . nodelist = t . nodelist
new _ context = context _ class ( _ dict , * * { &apos; autoescape &apos; : context . autoescape , &apos; current _ app &apos; : context . current _ app , &apos; use _ l10n &apos; : context . use _ l10n , &apos; use _ tz &apos; : context . use _ tz , } )
csrf _ token = context . get ( &apos; csrf _ token &apos; , None )
if csrf _ token is not None :
new _ context &#91; &apos; csrf _ token &apos; &#93; = csrf _ token
return self . nodelist . render ( new _ context )
function _ name = ( name or getattr ( func , &apos; _ decorated _ function &apos; , func ) . _ _ name _ _ )
compile _ func = partial ( generic _ tag _ compiler , params = params , varargs = varargs , varkw = varkw , defaults = defaults , name = function _ name , takes _ context = takes _ context , node _ class = InclusionNode )
compile _ func . _ _ doc _ _ = func . _ _ doc _ _
self . tag ( function _ name , compile _ func )
return func
return dec
def is _ library _ missing ( name ) :
path , module = name . rsplit ( &apos; .&apos; , 1 )
try :
package = import _ module ( path )
return not module _ has _ submodule ( package , module )
except ImportError :
return is _ library _ missing ( path )
def import _ library ( taglib _ module ) :
try :
mod = import _ module ( taglib _ module )
except ImportError as e :
if is _ library _ missing ( taglib _ module ) :
return None
else :
raise InvalidTemplateLibrary ( &quot; ImportError raised loading % s : % s &quot; % ( taglib _ module , e ) )
try :
return mod . register
except AttributeError :
raise InvalidTemplateLibrary ( &quot; Template library % s does not have &quot; &quot; a variable named &apos; register &apos; &quot; % taglib _ module )
templatetags _ modules = &#91; &#93;
def get _ templatetags _ modules ( ) :
global templatetags _ modules
if not templatetags _ modules :
_ templatetags _ modules = &#91; &#93;
templatetags _ modules _ candidates = &#91; &apos; django.templatetags &apos; &#93;
templatetags _ modules _ candidates + = &#91; &apos; % s.templatetags &apos; % app _ config . name for app _ config in apps . get _ app _ configs ( ) &#93;
for templatetag _ module in templatetags _ modules _ candidates :
try :
import _ module ( templatetag _ module )
_ templatetags _ modules . append ( templatetag _ module )
except ImportError :
continue
templatetags _ modules = _ templatetags _ modules
return templatetags _ modules
def get _ library ( library _ name ) :
lib = libraries . get ( library _ name , None )
if not lib :
templatetags _ modules = get _ templatetags _ modules ( )
tried _ modules = &#91; &#93;
for module in templatetags _ modules :
taglib _ module = &apos; % s . % s &apos; % ( module , library _ name )
tried _ modules . append ( taglib _ module )
lib = import _ library ( taglib _ module )
if lib :
libraries &#91; library _ name &#93; = lib
break
if not lib :
raise InvalidTemplateLibrary ( &quot; Template library % s not found , &quot; &quot; tried % s &quot; % ( library _ name , &apos; , &apos; . join ( tried _ modules ) ) )
return lib
def add _ to _ builtins ( module ) :
builtins . append ( import _ library ( module ) )
add _ to _ builtins ( &apos; django.template.defaulttags &apos; )
add _ to _ builtins ( &apos; django.template.defaultfilters &apos; )
add _ to _ builtins ( &apos; django.template.loader _ tags &apos; )
from copy import copy
from django . utils . module _ loading import import _ string
_ standard _ context _ processors = None
_ builtin _ context _ processors = ( &apos; django.core.context _ processors.csrf &apos; , )
class ContextPopException ( Exception ) :
pass
class ContextDict ( dict ) :
def _ _ init _ _ ( self , context , * args , * * kwargs ) :
super ( ContextDict , self ) . _ _ init _ _ ( * args , * * kwargs )
context . dicts . append ( self )
self . context = context
def _ _ enter _ _ ( self ) :
return self
def _ _ exit _ _ ( self , * args , * * kwargs ) :
self . context . pop ( )
class BaseContext ( object ) :
def _ _ init _ _ ( self , dict _ = None ) :
self . _ reset _ dicts ( dict _ )
def _ reset _ dicts ( self , value = None ) :
builtins = { &apos; True &apos; : true , &apos; False &apos; : False , &apos; None &apos; : None }
self . dicts = &#91; builtins &#93;
if value is not None :
self . dicts . append ( value )
def _ _ copy _ _ ( self ) :
duplicate = copy ( super ( BaseContext , self ) )
duplicate . dicts = self . dicts &#91; : &#93;
return duplicate
def _ _ repr _ _ ( self ) :
return repr ( self . dicts )
def _ _ iter _ _ ( self ) :
for d in reversed ( self . dicts ) :
yield d
def push ( self , * args , * * kwargs ) :
return ContextDict ( self , * args , * * kwargs )
def pop ( self ) :
if len ( self . dicts ) = = 1 :
raise ContextPopException
return self . dicts . pop ( )
def _ _ setitem _ _ ( self , key , value ) :
self . dicts &#91; - 1 &#93; &#91; key &#93; = value
def _ _ getitem _ _ ( self , key ) :
for d in reversed ( self . dicts ) :
if key in d :
return d &#91; key &#93;
raise KeyError ( key )
def _ _ delitem _ _ ( self , key ) :
del self . dicts &#91; - 1 &#93; &#91; key &#93;
def has _ key ( self , key ) :
for d in self . dicts :
if key in d :
return True
return False
def _ _ contains _ _ ( self , key ) :
return self . has _ key ( key )
def get ( self , key , otherwise = None ) :
for d in reversed ( self . dicts ) :
if key in d :
return d &#91; key &#93;
return otherwise
def new ( self , values = None ) :
new _ context = copy ( self )
new _ context . _ reset _ dicts ( values )
return new _ context
def flatten ( self ) :
flat = { }
for d in self . dicts :
flat . update ( d )
return flat
def _ _ eq _ _ ( self , other ) :
if isinstance ( other , BaseContext ) :
return self . flatten ( ) = = other . flatten ( )
return False
class Context ( BaseContext ) :
def _ _ init _ _ ( self , dict _ = None , autoescape = True , current _ app = None , use _ l10n = None , use _ tz = None ) :
self . autoescape = autoescape
self . current _ app = current _ app
self . use _ l10n = use _ l10n
self . use _ tz = use _ tz
self . render _ context = RenderContext ( )
super ( Context , self ) . _ _ init _ _ ( dict _ )
def _ _ copy _ _ ( self ) :
duplicate = super ( Context , self ) . _ _ copy _ _ ( )
duplicate . render _ context = copy ( self . render _ context )
return duplicate
def update ( self , other _ dict ) :
if not hasattr ( other _ dict , &apos; _ _ getitem _ _ &apos; ) :
raise TypeError ( &apos; other _ dict must be a mapping ( dictionary-like ) object . &apos; )
self . dicts . append ( other _ dict )
return other _ dict
class RenderContext ( BaseContext ) :
def _ _ iter _ _ ( self ) :
for d in self . dicts &#91; - 1 &#93; :
yield d
def has _ key ( self , key ) :
return key in self . dicts &#91; - 1 &#93;
def get ( self , key , otherwise = None ) :
return self . dicts &#91; - 1 &#93; . get ( key , otherwise )
def _ _ getitem _ _ ( self , key ) :
return self . dicts &#91; - 1 &#93; &#91; key &#93;
def get _ standard _ processors ( ) :
from django . conf import settings
global _ standard _ context _ processors
if _ standard _ context _ processors is None :
processors = &#91; &#93;
collect = &#91; &#93;
collect . extend ( _ builtin _ context _ processors )
collect . extend ( settings . template _ CONTEXT _ PROCESSORS )
for path in collect :
func = import _ string ( path )
processors . append ( func )
_ standard _ context _ processors = tuple ( processors )
return _ standard _ context _ processors
class RequestContext ( Context ) :
def _ _ init _ _ ( self , request , dict _ = None , processors = None , current _ app = None , use _ l10n = None , use _ tz = None ) :
context . _ _ init _ _ ( self , dict _ , current _ app = current _ app , use _ l10n = use _ l10n , use _ tz = use _ tz )
if processors is None :
processors = ( )
else :
processors = tuple ( processors )
updates = dict ( )
for processor in get _ standard _ processors ( ) + processors :
updates . update ( processor ( request ) )
self . update ( updates )
from django . template . base import Lexer , Parser , tag _ re , NodeList , VariableNode , TemplateSyntaxError
from django . utils . encoding import force _ text
from django . utils . html import escape
from django . utils . SafeString import SafeData , EscapeData
from django . utils . formats import localize
from django . utils . timezone import template _ localtime
class DebugLexer ( Lexer ) :
def _ _ init _ _ ( self , template _ string , origin ) :
super ( DebugLexer , self ) . _ _ init _ _ ( template _ string , origin )
def tokenize ( self ) :
result , upto = &#91; &#93; , 0
for match in tag _ re . finditer ( self . template _ string ) :
start , end = match . span ( )
if start &gt; upto :
result . append ( self . create _ token ( self . template _ string &#91; upto : start &#93; , ( upto , start ) , False ) )
upto = start
result . append ( self . create _ token ( self . template _ string &#91; start : end &#93; , ( start , end ) , True ) )
upto = end
last _ bit = self . template _ string &#91; upto : &#93;
if last _ bit :
result . append ( self . create _ token ( last _ bit , ( upto , upto + len ( last _ bit ) ) , False ) )
return result
def create _ token ( self , token _ string , source , in _ tag ) :
token = super ( DebugLexer , self ) . create _ token ( token _ string , in _ tag )
token . source = self . origin , source
return token
class DebugParser ( Parser ) :
def _ _ init _ _ ( self , lexer ) :
super ( DebugParser , self ) . _ _ init _ _ ( lexer )
self . command _ stack = &#91; &#93;
def enter _ command ( self , command , token ) :
self . command _ stack . append ( ( command , token . source ) )
def exit _ command ( self ) :
self . command _ stack . pop ( )
def error ( self , token , msg ) :
return self . source _ error ( token . source , msg )
def source _ error ( self , source , msg ) :
e = TemplateSyntaxError ( msg )
e . Django _ template _ source = source
return e
def create _ nodelist ( self ) :
return DebugNodeList ( )
def create _ variable _ node ( self , contents ) :
return DebugVariableNode ( contents )
def extend _ nodelist ( self , nodelist , node , token ) :
node . source = token . source
super ( DebugParser , self ) . extend _ nodelist ( nodelist , node , token )
def unclosed _ block _ tag ( self , parse _ until ) :
command , source = self . command _ stack . pop ( )
msg = &quot; Unclosed tag &apos; % s &apos; . Looking for one of : % s &quot; % ( command , &apos; , &apos; . join ( parse _ until ) )
raise self . source _ error ( source , msg )
def compile _ filter _ error ( self , token , e ) :
if not hasattr ( e , &apos; django _ template _ source &apos; ) :
e . Django _ template _ source = token . source
def compile _ function _ error ( self , token , e ) :
if not hasattr ( e , &apos; django _ template _ source &apos; ) :
e . Django _ template _ source = token . source
class DebugNodeList ( NodeList ) :
def render _ node ( self , node , context ) :
try :
return node . render ( context )
except Exception as e :
if not hasattr ( e , &apos; django _ template _ source &apos; ) :
e . Django _ template _ source = node . source
raise
class DebugVariableNode ( VariableNode ) :
def render ( self , context ) :
try :
output = self . filter _ expression . resolve ( context )
output = template _ localtime ( output , use _ tz = context . use _ tz )
output = localize ( output , use _ l10n = context . use _ l10n )
output = force _ text ( output )
except UnicodeDecodeError :
return &apos; &apos;
except Exception as e :
if not hasattr ( e , &apos; django _ template _ source &apos; ) :
e . Django _ template _ source = self . source
raise
if ( context . autoescape and not isinstance ( output , SafeData ) ) or isinstance ( output , EscapeData ) :
return escape ( output )
else :
return output
from _ _ future _ _ import unicode _ literals
import re
import random as random _ module
from decimal import Decimal , InvalidOperation , Context , ROUND _ HALF _ UP
from functools import wraps
from pprint import pformat
from django . template . base import Variable , Library , VariableDoesNotExist
from django . conf import settings
from django . utils import formats
from django . utils . DateFormat import format , time _ format
from django . utils . encoding import force _ text , iri _ to _ uri
from django . utils . html import ( conditional _ escape , escapejs , escape , urlize as _ urlize , linebreaks , strip _ tags , avoid _ wrapping , remove _ tags )
from django . utils . http import urlquote
from django . utils . text import Truncator , wrap , phone2numeric
from django . utils . SafeString import mark _ safe , SafeData , mark _ for _ escaping
from django . utils import six
from django . utils . timesince import timesince , timeuntil
from django . utils . translation import ugettext , ungettext
from django . utils . text import normalize _ newlines , slugify as _ slugify
register = Library ( )
def stringfilter ( func ) :
def _ dec ( * args , * * kwargs ) :
if args :
args = list ( args )
args &#91; 0 &#93; = force _ text ( args &#91; 0 &#93; )
if ( isinstance ( args &#91; 0 &#93; , SafeData ) and getattr ( _ dec . _ decorated _ function , &apos; is _ safe &apos; , False ) ) :
return mark _ safe ( func ( * args , * * kwargs ) )
return func ( * args , * * kwargs )
_ dec . _ decorated _ function = getattr ( func , &apos; _ decorated _ function &apos; , func )
return wraps ( func ) ( _ dec )
@ register . filter ( is _ safe = True )
@ stringfilter
def addslashes ( value ) :
return value . replace ( &apos; \ \ &apos; , &apos; \ \ \ \ &apos; ) . replace ( &apos; &quot; &apos; , &apos; \ \ &quot; &apos; ) . replace ( &quot; &apos; &quot; , &quot; \ \ &apos; &quot; )
@ register . filter ( is _ safe = True )
@ stringfilter
def capfirst ( value ) :
return value and value &#91; 0 &#93; . upper ( ) + value &#91; 1 : &#93;
@ register . filter ( &quot; escapejs &quot; )
@ stringfilter
def escapejs _ filter ( value ) :
return escapejs ( value )
pos _ inf = 1e200 * 1e200
neg _ inf = - 1e200 * 1e200
nan = ( 1e200 * 1e200 ) / / ( 1e200 * 1e200 )
special _ floats = &#91; str ( pos _ inf ) , str ( neg _ inf ) , str ( nan ) &#93;
@ register . filter ( is _ safe = True )
def floatformat ( text , arg = - 1 ) :
try :
input _ val = force _ text ( text )
d = Decimal ( input _ val )
except UnicodeEncodeError :
return &apos; &apos;
except InvalidOperation :
if input _ val in special _ floats :
return input _ val
try :
d = Decimal ( force _ text ( float ( text ) ) )
except ( ValueError , InvalidOperation , TypeError , UnicodeEncodeError ) :
return &apos; &apos;
try :
p = int ( arg )
except ValueError :
return input _ val
try :
m = int ( d ) - d
except ( ValueError , OverflowError , InvalidOperation ) :
return input _ val
if not m and p &lt; 0 :
return mark _ safe ( formats . number _ format ( &apos; % d &apos; % ( int ( d ) ) , 0 ) )
if p = = 0 :
exp = Decimal ( 1 )
else :
exp = Decimal ( &apos; 1.0 &apos; ) / ( Decimal ( 10 ) * * abs ( p ) )
try :
tupl = d . as _ tuple ( )
units = len ( tupl &#91; 1 &#93; ) - tupl &#91; 2 &#93;
prec = abs ( p ) + units + 1
sign , digits , exponent = d . quantize ( exp , ROUND _ HALF _ UP , Context ( prec = prec ) ) . as _ tuple ( )
digits = &#91; six . text _ type ( digit ) for digit in reversed ( digits ) &#93;
while len ( digits ) &lt; = abs ( exponent ) :
digits . append ( &apos; 0&apos; )
digits . insert ( - exponent , &apos; .&apos; )
if sign :
digits . append ( &apos; -&apos; )
number = &apos; &apos; . join ( reversed ( digits ) )
return mark _ safe ( formats . number _ format ( number , abs ( p ) ) )
except InvalidOperation :
return input _ val
@ register . filter ( is _ safe = True )
@ stringfilter
def iriencode ( value ) :
return force _ text ( iri _ to _ uri ( value ) )
@ register . filter ( is _ safe = True , needs _ autoescape = True )
@ stringfilter
def linenumbers ( value , autoescape = None ) :
lines = value . split ( &apos; \ n &apos; )
width = six . text _ type ( len ( six . text _ type ( len ( lines ) ) ) )
if not autoescape or isinstance ( value , SafeData ) :
for i , line in enumerate ( lines ) :
lines &#91; i &#93; = ( &quot; % 0 &quot; + width + &quot; d . % s &quot; ) % ( i + 1 , line )
else :
for i , line in enumerate ( lines ) :
lines &#91; i &#93; = ( &quot; % 0 &quot; + width + &quot; d . % s &quot; ) % ( i + 1 , escape ( line ) )
return mark _ safe ( &apos; \ n &apos; . join ( lines ) )
@ register . filter ( is _ safe = True )
@ stringfilter
def lower ( value ) :
return value . lower ( )
@ register . filter ( is _ safe = False )
@ stringfilter
def make _ list ( value ) :
return list ( value )
@ register . filter ( is _ safe = True )
@ stringfilter
def slugify ( value ) :
return _ slugify ( value )
@ register . filter ( is _ safe = True )
def stringformat ( value , arg ) :
try :
return ( &quot; % &quot; + six . text _ type ( arg ) ) % value
except ( ValueError , TypeError ) :
return &quot; &quot;
@ register . filter ( is _ safe = True )
@ stringfilter
def title ( value ) :
t = re . sub ( &quot; ( &#91; a-z &#93; ) &apos; ( &#91; A-Z &#93; ) &quot; , lambda m : m . Group ( 0 ) . lower ( ) , value . title ( ) )
return re . sub ( &quot; \ d ( &#91; A-Z &#93; ) &quot; , lambda m : m . Group ( 0 ) . lower ( ) , t )
@ register . filter ( is _ safe = True )
@ stringfilter
def truncatechars ( value , arg ) :
try :
length = int ( arg )
except ValueError :
return value
return Truncator ( value ) . chars ( length )
@ register . filter ( is _ safe = True )
@ stringfilter
def truncatechars _ html ( value , arg ) :
try :
length = int ( arg )
except ValueError :
return value
return Truncator ( value ) . chars ( length , html = True )
@ register . filter ( is _ safe = True )
@ stringfilter
def truncatewords ( value , arg ) :
try :
length = int ( arg )
except ValueError :
return value
return Truncator ( value ) . words ( length , truncate = &apos; ... &apos; )
@ register . filter ( is _ safe = True )
@ stringfilter
def truncatewords _ html ( value , arg ) :
try :
length = int ( arg )
except ValueError :
return value
return Truncator ( value ) . words ( length , html = True , truncate = &apos; ... &apos; )
@ register . filter ( is _ safe = False )
@ stringfilter
def upper ( value ) :
return value . upper ( )
@ register . filter ( is _ safe = False )
@ stringfilter
def urlencode ( value , safe = None ) :
kwargs = { }
if safe is not None :
kwargs &#91; &apos; safe &apos; &#93; = safe
return urlquote ( value , * * kwargs )
@ register . filter ( is _ safe = True , needs _ autoescape = True )
@ stringfilter
def urlize ( value , autoescape = None ) :
return mark _ safe ( _ urlize ( value , nofollow = True , autoescape = autoescape ) )
@ register . filter ( is _ safe = True , needs _ autoescape = True )
@ stringfilter
def urlizetrunc ( value , limit , autoescape = None ) :
return mark _ safe ( _ urlize ( value , trim _ url _ limit = int ( limit ) , nofollow = True , autoescape = autoescape ) )
@ register . filter ( is _ safe = False )
@ stringfilter
def wordcount ( value ) :
return len ( value . split ( ) )
@ register . filter ( is _ safe = True )
@ stringfilter
def wordwrap ( value , arg ) :
return wrap ( value , int ( arg ) )
@ register . filter ( is _ safe = True )
@ stringfilter
def ljust ( value , arg ) :
return value . ljust ( int ( arg ) )
@ register . filter ( is _ safe = True )
@ stringfilter
def rjust ( value , arg ) :
return value . rjust ( int ( arg ) )
@ register . filter ( is _ safe = True )
@ stringfilter
def center ( value , arg ) :
return value . center ( int ( arg ) )
@ register . filter
@ stringfilter
def cut ( value , arg ) :
safe = isinstance ( value , SafeData )
value = value . replace ( arg , &apos; &apos; )
if safe and arg ! = &apos; ; &apos; :
return mark _ safe ( value )
return value
@ register . filter ( &quot; escape &quot; , is _ safe = True )
@ stringfilter
def escape _ filter ( value ) :
return mark _ for _ escaping ( value )
@ register . filter ( is _ safe = True )
@ stringfilter
def force _ escape ( value ) :
return escape ( value )
@ register . filter ( &quot; linebreaks &quot; , is _ safe = True , needs _ autoescape = True )
@ stringfilter
def linebreaks _ filter ( value , autoescape = None ) :
autoescape = autoescape and not isinstance ( value , SafeData )
return mark _ safe ( linebreaks ( value , autoescape ) )
@ register . filter ( is _ safe = True , needs _ autoescape = True )
@ stringfilter
def linebreaksbr ( value , autoescape = None ) :
autoescape = autoescape and not isinstance ( value , SafeData )
value = normalize _ newlines ( value )
if autoescape :
value = escape ( value )
return mark _ safe ( value . replace ( &apos; \ n &apos; , &apos; &lt; br / &gt; &apos; ) )
@ register . filter ( is _ safe = True )
@ stringfilter
def safe ( value ) :
return mark _ safe ( value )
@ register . filter ( is _ safe = True )
def safeseq ( value ) :
return &#91; mark _ safe ( force _ text ( obj ) ) for obj in value &#93;
@ register . filter ( is _ safe = True )
@ stringfilter
def removetags ( value , tags ) :
return remove _ tags ( value , tags )
@ register . filter ( is _ safe = True )
@ stringfilter
def striptags ( value ) :
return strip _ tags ( value )
@ register . filter ( is _ safe = False )
def dictsort ( value , arg ) :
try :
return sorted ( value , key = Variable ( arg ) . resolve )
except ( TypeError , VariableDoesNotExist ) :
return &apos; &apos;
@ register . filter ( is _ safe = False )
def dictsortreversed ( value , arg ) :
try :
return sorted ( value , key = Variable ( arg ) . resolve , reverse = True )
except ( TypeError , VariableDoesNotExist ) :
return &apos; &apos;
@ register . filter ( is _ safe = False )
def first ( value ) :
try :
return value &#91; 0 &#93;
except IndexError :
return &apos; &apos;
@ register . filter ( is _ safe = True , needs _ autoescape = True )
def join ( value , arg , autoescape = None ) :
value = map ( force _ text , value )
if autoescape :
value = &#91; conditional _ escape ( v ) for v in value &#93;
try :
data = conditional _ escape ( arg ) . join ( value )
except AttributeError :
return value
return mark _ safe ( data )
@ register . filter ( is _ safe = True )
def last ( value ) :
try :
return value &#91; - 1 &#93;
except IndexError :
return &apos; &apos;
@ register . filter ( is _ safe = False )
def length ( value ) :
try :
return len ( value )
except ( ValueError , TypeError ) :
return 0
@ register . filter ( is _ safe = False )
def length _ is ( value , arg ) :
try :
return len ( value ) = = int ( arg )
except ( ValueError , TypeError ) :
return &apos; &apos;
@ register . filter ( is _ safe = True )
def random ( value ) :
return random _ module . choice ( value )
@ register . filter ( &quot; slice &quot; , is _ safe = True )
def slice _ filter ( value , arg ) :
try :
bits = &#91; &#93;
for x in arg . split ( &apos; : &apos; ) :
if len ( x ) = = 0 :
bits . append ( None )
else :
bits . append ( int ( x ) )
return value &#91; slice ( * bits ) &#93;
except ( ValueError , TypeError ) :
return value
@ register . filter ( is _ safe = True , needs _ autoescape = True )
def unordered _ list ( value , autoescape = None ) :
if autoescape :
escaper = conditional _ escape
else :
escaper = lambda x : x
def convert _ old _ style _ list ( list _ ) :
if not isinstance ( list _ , ( tuple , list ) ) or len ( list _ ) ! = 2 :
return list _ , False
first _ item , second _ item = list _
if second _ item = = &#91; &#93; :
return &#91; first _ item &#93; , True
try :
iter ( second _ item )
except TypeError :
return list _ , False
old _ style _ list = True
new _ second _ item = &#91; &#93;
for sublist in second _ item :
item , old _ style _ list = convert _ old _ style _ list ( sublist )
if not old _ style _ list :
break
new _ second _ item . extend ( item )
if old _ style _ list :
second _ item = new _ second _ item
return &#91; first _ item , second _ item &#93; , old _ style _ list
def _ helper ( list _ , tabs = 1 ) :
indent = &apos; \ t &apos; * tabs
output = &#91; &#93;
list _ length = len ( list _ )
i = 0
while i &lt; list _ length :
title = list _ &#91; i &#93;
sublist = &apos; &apos;
sublist _ item = None
if isinstance ( title , ( list , tuple ) ) :
sublist _ item = title
title = &apos; &apos;
elif i &lt; list _ length - 1 :
next _ item = list _ &#91; i + 1 &#93;
if next _ item and isinstance ( next _ item , ( list , tuple ) ) :
sublist _ item = next _ item
i + = 1
if sublist _ item :
sublist = _ helper ( sublist _ item , tabs + 1 )
sublist = &apos; \ n % s &lt; ul &gt; \ n % s \ n % s &lt; / ul &gt; \ n % s &apos; % ( indent , sublist , indent , indent )
output . append ( &apos; % s &lt; li &gt; % s % s &lt; / li &gt; &apos; % ( indent , escaper ( force _ text ( title ) ) , sublist ) )
i + = 1
return &apos; \ n &apos; . join ( output )
value , converted = convert _ old _ style _ list ( value )
return mark _ safe ( _ helper ( value ) )
@ register . filter ( is _ safe = False )
def add ( value , arg ) :
try :
return int ( value ) + int ( arg )
except ( ValueError , TypeError ) :
try :
return value + arg
except Exception :
return &apos; &apos;
@ register . filter ( is _ safe = False )
def get _ digit ( value , arg ) :
try :
arg = int ( arg )
value = int ( value )
except ValueError :
return value
if arg &lt; 1 :
return value
try :
return int ( str ( value ) &#91; - arg &#93; )
except IndexError :
return 0
@ register . filter ( expects _ localtime = True , is _ safe = False )
def date ( value , arg = None ) :
if value in ( None , &apos; &apos; ) :
return &apos; &apos;
if arg is None :
arg = settings . date _ FORMAT
try :
return formats . date _ format ( value , arg )
except AttributeError :
try :
return format ( value , arg )
except AttributeError :
return &apos; &apos;
@ register . filter ( expects _ localtime = True , is _ safe = False )
def time ( value , arg = None ) :
if value in ( None , &apos; &apos; ) :
return &apos; &apos;
if arg is None :
arg = settings . time _ FORMAT
try :
return formats . time _ format ( value , arg )
except AttributeError :
try :
return time _ format ( value , arg )
except AttributeError :
return &apos; &apos;
@ register . filter ( &quot; timesince &quot; , is _ safe = False )
def timesince _ filter ( value , arg = None ) :
if not value :
return &apos; &apos;
try :
if arg :
return timesince ( value , arg )
return timesince ( value )
except ( ValueError , TypeError ) :
return &apos; &apos;
@ register . filter ( &quot; timeuntil &quot; , is _ safe = False )
def timeuntil _ filter ( value , arg = None ) :
if not value :
return &apos; &apos;
try :
return timeuntil ( value , arg )
except ( ValueError , TypeError ) :
return &apos; &apos;
@ register . filter ( is _ safe = False )
def default ( value , arg ) :
return value or arg
@ register . filter ( is _ safe = False )
def default _ if _ none ( value , arg ) :
if value is None :
return arg
return value
@ register . filter ( is _ safe = False )
def divisibleby ( value , arg ) :
return int ( value ) % int ( arg ) = = 0
@ register . filter ( is _ safe = False )
def yesno ( value , arg = None ) :
if arg is None :
arg = ugettext ( &apos; yes , no , maybe &apos; )
bits = arg . split ( &apos; , &apos; )
if len ( bits ) &lt; 2 :
return value
try :
yes , no , maybe = bits
except ValueError :
yes , no , maybe = bits &#91; 0 &#93; , bits &#91; 1 &#93; , bits &#91; 1 &#93;
if value is None :
return maybe
if value :
return yes
return no
@ register . filter ( is _ safe = True )
def filesizeformat ( bytes ) :
try :
bytes = float ( bytes )
except ( TypeError , ValueError , UnicodeDecodeError ) :
value = ungettext ( &quot; % ( size ) d byte &quot; , &quot; % ( size ) d bytes &quot; , 0 ) % { &apos; size &apos; : 0 }
return avoid _ wrapping ( value )
filesize _ number _ format = lambda value : formats . number _ format ( round ( value , 1 ) , 1 )
KB = 1 &lt; &lt; 10
MB = 1 &lt; &lt; 20
GB = 1 &lt; &lt; 30
tb = 1 &lt; &lt; 40
PB = 1 &lt; &lt; 50
if bytes &lt; KB :
value = ungettext ( &quot; % ( size ) d byte &quot; , &quot; % ( size ) d bytes &quot; , bytes ) % { &apos; size &apos; : bytes }
elif bytes &lt; MB :
value = ugettext ( &quot; % s KB &quot; ) % filesize _ number _ format ( bytes / KB )
elif bytes &lt; GB :
value = ugettext ( &quot; % s MB &quot; ) % filesize _ number _ format ( bytes / MB )
elif bytes &lt; TB :
value = ugettext ( &quot; % s GB &quot; ) % filesize _ number _ format ( bytes / GB )
elif bytes &lt; PB :
value = ugettext ( &quot; % s TB &quot; ) % filesize _ number _ format ( bytes / TB )
else :
value = ugettext ( &quot; % s PB &quot; ) % filesize _ number _ format ( bytes / PB )
return avoid _ wrapping ( value )
@ register . filter ( is _ safe = False )
def pluralize ( value , arg = &apos; s &apos; ) :
if &apos; , &apos; not in arg :
arg = &apos; , &apos; + arg
bits = arg . split ( &apos; , &apos; )
if len ( bits ) &gt; 2 :
return &apos; &apos;
singular _ suffix , plural _ suffix = bits &#91; : 2 &#93;
try :
if float ( value ) ! = 1 :
return plural _ suffix
except ValueError :
pass
except TypeError :
try :
if len ( value ) ! = 1 :
return plural _ suffix
except TypeError :
pass
return singular _ suffix
@ register . filter ( &quot; phone2numeric &quot; , is _ safe = True )
def phone2numeric _ filter ( value ) :
return phone2numeric ( value )
@ register . filter ( is _ safe = True )
def pprint ( value ) :
try :
return pformat ( value )
except Exception as e :
return &quot; Error in formatting : % s &quot; % force _ text ( e , errors = &quot; replace &quot; )
from _ _ future _ _ import unicode _ literals
import os
import sys
import re
from datetime import datetime
from itertools import groupby , cycle as itertools _ cycle
import warnings
from django . conf import settings
from django . template . base import ( Node , NodeList , Template , Context , Library , TemplateSyntaxError , VariableDoesNotExist , InvalidTemplateLibrary , BLOCK _ TAG _ START , BLOCK _ TAG _ END , VARIABLE _ TAG _ START , VARIABLE _ TAG _ END , SINGLE _ BRACE _ START , SINGLE _ BRACE _ END , COMMENT _ TAG _ START , COMMENT _ TAG _ END , VARIABLE _ ATTRIBUTE _ SEPARATOR , get _ library , token _ kwargs , kwarg _ re , render _ value _ in _ context )
from django . template . smartif import IfParser , Literal
from django . template . defaultfilters import date
from django . utils . deprecation import RemovedInDjango20Warning
from django . utils . encoding import force _ text , smart _ text
from django . utils . SafeString import mark _ safe
from django . utils . html import format _ html
from django . utils import six
from django . utils import timezone
register = Library ( )
class AutoEscapeControlNode ( Node ) :
def _ _ init _ _ ( self , setting , nodelist ) :
self . setting , self . nodelist = setting , nodelist
def render ( self , context ) :
old _ setting = context . autoescape
context . autoescape = self . setting
output = self . nodelist . render ( context )
context . autoescape = old _ setting
if self . setting :
return mark _ safe ( output )
else :
return output
class CommentNode ( Node ) :
def render ( self , context ) :
return &apos; &apos;
class CsrfTokenNode ( Node ) :
def render ( self , context ) :
csrf _ token = context . get ( &apos; csrf _ token &apos; , None )
if csrf _ token :
if csrf _ token = = &apos; NOTPROVIDED &apos; :
return format _ html ( &quot; &quot; )
else :
return format _ html ( &quot; &lt; input type = &apos; hidden &apos; name = &apos; csrfmiddlewaretoken &apos; value = &apos; { 0 } &apos; / &gt; &quot; , csrf _ token )
else :
if settings . DEBUG :
warnings . warn ( &quot; A { % csrf _ token % } was used in a template , but the context did not provide the value . this is usually caused by not using RequestContext . &quot; )
return &apos; &apos;
class CycleNode ( Node ) :
def _ _ init _ _ ( self , cyclevars , variable _ name = None , silent = False ) :
self . cyclevars = cyclevars
self . variable _ name = variable _ name
self . silent = silent
def render ( self , context ) :
if self not in context . render _ context :
context . render _ context &#91; self &#93; = itertools _ cycle ( self . cyclevars )
cycle _ iter = context . render _ context &#91; self &#93;
value = next ( cycle _ iter ) . resolve ( context )
if self . variable _ name :
context &#91; self . variable _ name &#93; = value
if self . silent :
return &apos; &apos;
return render _ value _ in _ context ( value , context )
class DebugNode ( Node ) :
def render ( self , context ) :
from pprint import pformat
output = &#91; pformat ( val ) for val in context &#93;
output . append ( &apos; \ n \ n &apos; )
output . append ( pformat ( sys . modules ) )
return &apos; &apos; . join ( output )
class FilterNode ( Node ) :
def _ _ init _ _ ( self , filter _ expr , nodelist ) :
self . filter _ expr , self . nodelist = filter _ expr , nodelist
def render ( self , context ) :
output = self . nodelist . render ( context )
with context . push ( var = output ) :
return self . filter _ expr . resolve ( context )
class FirstOfNode ( Node ) :
def _ _ init _ _ ( self , variables ) :
self . vars = variables
def render ( self , context ) :
for var in self . vars :
value = var . resolve ( context , True )
if value :
return render _ value _ in _ context ( value , context )
return &apos; &apos;
class ForNode ( Node ) :
child _ nodelists = ( &apos; nodelist _ loop &apos; , &apos; nodelist _ empty &apos; )
def _ _ init _ _ ( self , loopvars , sequence , is _ reversed , nodelist _ loop , nodelist _ empty = None ) :
self . loopvars , self . sequence = loopvars , sequence
self . is _ reversed = is _ reversed
self . nodelist _ loop = nodelist _ loop
if nodelist _ empty is None :
self . nodelist _ empty = NodeList ( )
else :
self . nodelist _ empty = nodelist _ empty
def _ _ repr _ _ ( self ) :
reversed _ text = &apos; reversed &apos; if self . is _ reversed else &apos; &apos;
return &quot; &lt; For Node : for % s in % s , tail _ len : % d % s &gt; &quot; % ( &apos; , &apos; . join ( self . loopvars ) , self . sequence , len ( self . nodelist _ loop ) , reversed _ text )
def _ _ iter _ _ ( self ) :
for node in self . nodelist _ loop :
yield node
for node in self . nodelist _ empty :
yield node
def render ( self , context ) :
if &apos; forloop &apos; in context :
parentloop = context &#91; &apos; forloop &apos; &#93;
else :
parentloop = { }
with context . push ( ) :
try :
values = self . sequence . resolve ( context , True )
except VariableDoesNotExist :
values = &#91; &#93;
if values is None :
values = &#91; &#93;
if not hasattr ( values , &apos; _ _ len _ _ &apos; ) :
values = list ( values )
len _ values = len ( values )
if len _ values &lt; 1 :
return self . nodelist _ empty . render ( context )
nodelist = &#91; &#93;
if self . is _ reversed :
values = reversed ( values )
num _ loopvars = len ( self . loopvars )
unpack = num _ loopvars &gt; 1
loop _ dict = context &#91; &apos; forloop &apos; &#93; = { &apos; parentloop &apos; : parentloop }
for i , item in enumerate ( values ) :
loop _ dict &#91; &apos; counter0 &apos; &#93; = i
loop _ dict &#91; &apos; counter &apos; &#93; = i + 1
loop _ dict &#91; &apos; revcounter &apos; &#93; = len _ values - i
loop _ dict &#91; &apos; revcounter0 &apos; &#93; = len _ values - i - 1
loop _ dict &#91; &apos; first &apos; &#93; = ( i = = 0 )
loop _ dict &#91; &apos; last &apos; &#93; = ( i = = len _ values - 1 )
pop _ context = False
if unpack :
if not isinstance ( item , ( list , tuple ) ) :
len _ item = 1
else :
len _ item = len ( item )
if num _ loopvars ! = len _ item :
warnings . warn ( &quot; Need { 0 } values to unpack in for loop ; got { 1 } . &quot; &quot; this will raise an exception in Django 2.0 . &quot; . format ( num _ loopvars , len _ item ) , RemovedInDjango20Warning )
try :
unpacked _ vars = dict ( zip ( self . loopvars , item ) )
except TypeError :
pass
else :
pop _ context = True
context . update ( unpacked _ vars )
else :
context &#91; self . loopvars &#91; 0 &#93; &#93; = item
if settings . template _ DEBUG :
for node in self . nodelist _ loop :
try :
nodelist . append ( node . render ( context ) )
except Exception as e :
if not hasattr ( e , &apos; django _ template _ source &apos; ) :
e . Django _ template _ source = node . source
raise
else :
for node in self . nodelist _ loop :
nodelist . append ( node . render ( context ) )
if pop _ context :
context . pop ( )
return mark _ safe ( &apos; &apos; . join ( force _ text ( n ) for n in nodelist ) )
class IfChangedNode ( Node ) :
child _ nodelists = ( &apos; nodelist _ true &apos; , &apos; nodelist _ false &apos; )
def _ _ init _ _ ( self , nodelist _ true , nodelist _ false , * varlist ) :
self . nodelist _ true , self . nodelist _ false = nodelist _ true , nodelist _ false
self . _ varlist = varlist
def render ( self , context ) :
state _ frame = self . _ get _ context _ stack _ frame ( context )
if self not in state _ frame :
state _ frame &#91; self &#93; = None
nodelist _ true _ output = None
try :
if self . _ varlist :
compare _ to = &#91; var . resolve ( context , True ) for var in self . _ varlist &#93;
else :
compare _ to = nodelist _ true _ output = self . nodelist _ true . render ( context )
except VariableDoesNotExist :
compare _ to = None
if compare _ to ! = state _ frame &#91; self &#93; :
state _ frame &#91; self &#93; = compare _ to
return nodelist _ true _ output or self . nodelist _ true . render ( context )
elif self . nodelist _ false :
return self . nodelist _ false . render ( context )
return &apos; &apos;
def _ get _ context _ stack _ frame ( self , context ) :
if &apos; forloop &apos; in context :
return context &#91; &apos; forloop &apos; &#93;
else :
return context . render _ context
class IfEqualNode ( Node ) :
child _ nodelists = ( &apos; nodelist _ true &apos; , &apos; nodelist _ false &apos; )
def _ _ init _ _ ( self , var1 , var2 , nodelist _ true , nodelist _ false , negate ) :
self . var1 , self . var2 = var1 , var2
self . nodelist _ true , self . nodelist _ false = nodelist _ true , nodelist _ false
self . negate = negate
def _ _ repr _ _ ( self ) :
return &quot; &lt; IfEqualNode &gt; &quot;
def render ( self , context ) :
val1 = self . var1 . resolve ( context , True )
val2 = self . var2 . resolve ( context , True )
if ( self . negate and val1 ! = val2 ) or ( not self . negate and val1 = = val2 ) :
return self . nodelist _ true . render ( context )
return self . nodelist _ false . render ( context )
class IfNode ( Node ) :
def _ _ init _ _ ( self , conditions _ nodelists ) :
self . conditions _ nodelists = conditions _ nodelists
def _ _ repr _ _ ( self ) :
return &quot; &lt; IfNode &gt; &quot;
def _ _ iter _ _ ( self ) :
for _ , nodelist in self . conditions _ nodelists :
for node in nodelist :
yield node
@ property
def nodelist ( self ) :
return NodeList ( node for _ , nodelist in self . conditions _ nodelists for node in nodelist )
def render ( self , context ) :
for condition , nodelist in self . conditions _ nodelists :
if condition is not None :
try :
match = condition . eval ( context )
except VariableDoesNotExist :
match = None
else :
match = True
if match :
return nodelist . render ( context )
return &apos; &apos;
class RegroupNode ( Node ) :
def _ _ init _ _ ( self , target , expression , var _ name ) :
self . target , self . expression = target , expression
self . var _ name = var _ name
def resolve _ expression ( self , obj , context ) :
context &#91; self . var _ name &#93; = obj
return self . expression . resolve ( context , True )
def render ( self , context ) :
obj _ list = self . target . resolve ( context , True )
if obj _ list is None :
context &#91; self . var _ name &#93; = &#91; &#93;
return &apos; &apos;
context &#91; self . var _ name &#93; = &#91; { &apos; grouper &apos; : key , &apos; list &apos; : list ( val ) } for key , val in groupby ( obj _ list , lambda obj : self . resolve _ expression ( obj , context ) ) &#93;
return &apos; &apos;
def include _ is _ allowed ( filepath ) :
filepath = os . path . abspath ( filepath )
for root in settings . allowed _ INCLUDE _ ROOTS :
if filepath . startswith ( root ) :
return True
return False
class SsiNode ( Node ) :
def _ _ init _ _ ( self , filepath , parsed ) :
self . filepath = filepath
self . parsed = parsed
def render ( self , context ) :
filepath = self . filepath . resolve ( context )
if not include _ is _ allowed ( filepath ) :
if settings . DEBUG :
return &quot; &#91; Didn &apos;t have permission to include file &#93; &quot;
else :
return &apos; &apos;
try :
with open ( filepath , &apos; r &apos; ) as fp :
output = fp . read ( )
except IOError :
output = &apos; &apos;
if self . parsed :
try :
t = Template ( output , name = filepath )
return t . render ( context )
except TemplateSyntaxError as e :
if settings . DEBUG :
return &quot; &#91; Included template had syntax error : % s &#93; &quot; % e
else :
return &apos; &apos;
return output
class LoadNode ( Node ) :
def render ( self , context ) :
return &apos; &apos;
class NowNode ( Node ) :
def _ _ init _ _ ( self , format _ string ) :
self . format _ string = format _ string
def render ( self , context ) :
tzinfo = timezone . get _ current _ timezone ( ) if settings . use _ TZ else None
return date ( datetime . now ( tz = tzinfo ) , self . format _ string )
class SpacelessNode ( Node ) :
def _ _ init _ _ ( self , nodelist ) :
self . nodelist = nodelist
def render ( self , context ) :
from django . utils . html import strip _ spaces _ between _ tags
return strip _ spaces _ between _ tags ( self . nodelist . render ( context ) . strip ( ) )
class TemplateTagNode ( Node ) :
mapping = { &apos; openblock &apos; : block _ TAG _ START , &apos; closeblock &apos; : block _ TAG _ END , &apos; openvariable &apos; : variable _ TAG _ START , &apos; closevariable &apos; : variable _ TAG _ END , &apos; openbrace &apos; : SINGLE _ BRACE _ START , &apos; closebrace &apos; : SINGLE _ BRACE _ END , &apos; opencomment &apos; : COMMENT _ TAG _ START , &apos; closecomment &apos; : COMMENT _ TAG _ END , }
def _ _ init _ _ ( self , tagtype ) :
self . tagtype = tagtype
def render ( self , context ) :
return self . mapping . get ( self . tagtype , &apos; &apos; )
class URLNode ( Node ) :
def _ _ init _ _ ( self , view _ name , args , kwargs , asvar ) :
self . view _ name = view _ name
self . args = args
self . kwargs = kwargs
self . asvar = asvar
def render ( self , context ) :
from django . core . urlresolvers import reverse , NoReverseMatch
args = &#91; arg . resolve ( context ) for arg in self . args &#93;
kwargs = dict ( ( smart _ text ( k , &apos; ascii &apos; ) , v . resolve ( context ) ) for k , v in self . kwargs . items ( ) )
view _ name = self . view _ name . resolve ( context )
url = &apos; &apos;
try :
url = reverse ( view _ name , args = args , kwargs = kwargs , current _ app = context . current _ app )
except NoReverseMatch :
exc _ info = sys . exc _ info ( )
if settings . settings _ MODULE :
project _ name = settings . settings _ MODULE . split ( &apos; .&apos; ) &#91; 0 &#93;
try :
url = reverse ( project _ name + &apos; .&apos; + view _ name , args = args , kwargs = kwargs , current _ app = context . current _ app )
except NoReverseMatch :
if self . asvar is None :
six . reraise ( * exc _ info )
else :
if self . asvar is None :
raise
if self . asvar :
context &#91; self . asvar &#93; = url
return &apos; &apos;
else :
return url
class VerbatimNode ( Node ) :
def _ _ init _ _ ( self , content ) :
self . content = content
def render ( self , context ) :
return self . content
class WidthRatioNode ( Node ) :
def _ _ init _ _ ( self , val _ expr , max _ expr , max _ width , asvar = None ) :
self . val _ expr = val _ expr
self . max _ expr = max _ expr
self . max _ width = max _ width
self . asvar = asvar
def render ( self , context ) :
try :
value = self . val _ expr . resolve ( context )
max _ value = self . max _ expr . resolve ( context )
max _ width = int ( self . max _ width . resolve ( context ) )
except VariableDoesNotExist :
return &apos; &apos;
except ( ValueError , TypeError ) :
raise TemplateSyntaxError ( &quot; widthratio final argument must be a number &quot; )
try :
value = float ( value )
max _ value = float ( max _ value )
ratio = ( value / max _ value ) * max _ width
result = str ( int ( round ( ratio ) ) )
except ZeroDivisionError :
return &apos; 0&apos;
except ( ValueError , TypeError , OverflowError ) :
return &apos; &apos;
if self . asvar :
context &#91; self . asvar &#93; = result
return &apos; &apos;
else :
return result
class WithNode ( Node ) :
def _ _ init _ _ ( self , var , name , nodelist , extra _ context = None ) :
self . nodelist = nodelist
self . extra _ context = extra _ context or { }
if name :
self . extra _ context &#91; name &#93; = var
def _ _ repr _ _ ( self ) :
return &quot; &lt; WithNode &gt; &quot;
def render ( self , context ) :
values = dict ( ( key , val . resolve ( context ) ) for key , val in six . iteritems ( self . extra _ context ) )
with context . push ( * * values ) :
return self . nodelist . render ( context )
@ register . tag
def autoescape ( parser , token ) :
args = token . contents . split ( )
if len ( args ) ! = 2 :
raise TemplateSyntaxError ( &quot; &apos; autoescape &apos; tag requires exactly one argument . &quot; )
arg = args &#91; 1 &#93;
if arg not in ( &apos; on &apos; , &apos; off &apos; ) :
raise TemplateSyntaxError ( &quot; &apos; autoescape &apos; argument should be &apos; on &apos; or &apos; off &apos; &quot; )
nodelist = parser . parse ( ( &apos; endautoescape &apos; , ) )
parser . delete _ first _ token ( )
return AutoEscapeControlNode ( ( arg = = &apos; on &apos; ) , nodelist )
@ register . tag
def comment ( parser , token ) :
parser . skip _ past ( &apos; endcomment &apos; )
return CommentNode ( )
@ register . tag
def cycle ( parser , token ) :
args = token . split _ contents ( )
if len ( args ) &lt; 2 :
raise TemplateSyntaxError ( &quot; &apos; cycle &apos; tag requires at least two arguments &quot; )
if &apos; , &apos; in args &#91; 1 &#93; :
args &#91; 1 : 2 &#93; = &#91; &apos; &quot; % s &quot; &apos; % arg for arg in args &#91; 1 &#93; . split ( &quot; , &quot; ) &#93;
if len ( args ) = = 2 :
name = args &#91; 1 &#93;
if not hasattr ( parser , &apos; _ namedCycleNodes &apos; ) :
raise TemplateSyntaxError ( &quot; No named cycles in template . &apos; % s &apos; is not defined &quot; % name )
if name not in parser . _ namedCycleNodes :
raise TemplateSyntaxError ( &quot; Named cycle &apos; % s &apos; does not exist &quot; % name )
return parser . _ namedCycleNodes &#91; name &#93;
as _ form = False
if len ( args ) &gt; 4 :
if args &#91; - 3 &#93; = = &quot; as &quot; :
if args &#91; - 1 &#93; ! = &quot; silent &quot; :
raise TemplateSyntaxError ( &quot; Only &apos; silent &apos; flag is allowed after cycle &apos;s name , not &apos; % s &apos; . &quot; % args &#91; - 1 &#93; )
as _ form = True
silent = True
args = args &#91; : - 1 &#93;
elif args &#91; - 2 &#93; = = &quot; as &quot; :
as _ form = True
silent = False
if as _ form :
name = args &#91; - 1 &#93;
values = &#91; parser . compile _ filter ( arg ) for arg in args &#91; 1 : - 2 &#93; &#93;
node = CycleNode ( values , name , silent = silent )
if not hasattr ( parser , &apos; _ namedCycleNodes &apos; ) :
parser . _ namedCycleNodes = { }
parser . _ namedCycleNodes &#91; name &#93; = node
else :
values = &#91; parser . compile _ filter ( arg ) for arg in args &#91; 1 : &#93; &#93;
node = CycleNode ( values )
return node
@ register . tag
def csrf _ token ( parser , token ) :
return CsrfTokenNode ( )
@ register . tag
def debug ( parser , token ) :
return DebugNode ( )
@ register . tag ( &apos; filter &apos; )
def do _ filter ( parser , token ) :
_ , rest = token . contents . split ( None , 1 )
filter _ expr = parser . compile _ filter ( &quot; var &#124; % s &quot; % ( rest ) )
for func , unused in filter _ expr . filters :
filter _ name = getattr ( func , &apos; _ filter _ name &apos; , None )
if filter _ name in ( &apos; escape &apos; , &apos; safe &apos; ) :
raise TemplateSyntaxError ( &apos; &quot; filter % s &quot; is not permitted . use the &quot; autoescape &quot; tag instead . &apos; % filter _ name )
nodelist = parser . parse ( ( &apos; endfilter &apos; , ) )
parser . delete _ first _ token ( )
return FilterNode ( filter _ expr , nodelist )
@ register . tag
def firstof ( parser , token ) :
bits = token . split _ contents ( ) &#91; 1 : &#93;
if len ( bits ) &lt; 1 :
raise TemplateSyntaxError ( &quot; &apos; firstof &apos; statement requires at least one argument &quot; )
return FirstOfNode ( &#91; parser . compile _ filter ( bit ) for bit in bits &#93; )
@ register . tag ( &apos; for &apos; )
def do _ for ( parser , token ) :
bits = token . split _ contents ( )
if len ( bits ) &lt; 4 :
raise TemplateSyntaxError ( &quot; &apos; for &apos; statements should have at least four &quot; &quot; words : % s &quot; % token . contents )
is _ reversed = bits &#91; - 1 &#93; = = &apos; reversed&apos;
in _ index = - 3 if is _ reversed else - 2
if bits &#91; in _ index &#93; ! = &apos; in &apos; :
raise TemplateSyntaxError ( &quot; &apos; for &apos; statements should use the format &quot; &quot; &apos; for x in y &apos; : % s &quot; % token . contents )
loopvars = re . split ( r &apos; * , * &apos; , &apos; &apos; . join ( bits &#91; 1 : in _ index &#93; ) )
for var in loopvars :
if not var or &apos; &apos; in var :
raise TemplateSyntaxError ( &quot; &apos; for &apos; tag received an invalid argument : &quot; &quot; % s &quot; % token . contents )
sequence = parser . compile _ filter ( bits &#91; in _ index + 1 &#93; )
nodelist _ loop = parser . parse ( ( &apos; empty &apos; , &apos; endfor &apos; , ) )
token = parser . next _ token ( )
if token . contents = = &apos; empty &apos; :
nodelist _ empty = parser . parse ( ( &apos; endfor &apos; , ) )
parser . delete _ first _ token ( )
else :
nodelist _ empty = None
return ForNode ( loopvars , sequence , is _ reversed , nodelist _ loop , nodelist _ empty )
def do _ ifequal ( parser , token , negate ) :
bits = list ( token . split _ contents ( ) )
if len ( bits ) ! = 3 :
raise TemplateSyntaxError ( &quot; % r takes two arguments &quot; % bits &#91; 0 &#93; )
end _ tag = &apos; end &apos; + bits &#91; 0 &#93;
nodelist _ loop = parser . parse ( ( &apos; else &apos; , end _ tag ) )
token = parser . next _ token ( )
if token . contents = = &apos; else &apos; :
nodelist _ false = parser . parse ( ( end _ tag , ) )
parser . delete _ first _ token ( )
else :
nodelist _ false = NodeList ( )
val1 = parser . compile _ filter ( bits &#91; 1 &#93; )
val2 = parser . compile _ filter ( bits &#91; 2 &#93; )
return IfEqualNode ( val1 , val2 , nodelist _ true , nodelist _ false , negate )
@ register . tag
def ifequal ( parser , token ) :
return do _ ifequal ( parser , token , False )
@ register . tag
def ifnotequal ( parser , token ) :
return do _ ifequal ( parser , token , True )
class TemplateLiteral ( Literal ) :
def _ _ init _ _ ( self , value , text ) :
self . value = value
self . text = text
def display ( self ) :
return self . text
def eval ( self , context ) :
return self . value . resolve ( context , ignore _ failures = True )
class TemplateIfParser ( IfParser ) :
error _ class = TemplateSyntaxError
def _ _ init _ _ ( self , parser , * args , * * kwargs ) :
self . template _ parser = parser
super ( TemplateIfParser , self ) . _ _ init _ _ ( * args , * * kwargs )
def create _ var ( self , value ) :
return TemplateLiteral ( self . template _ parser . compile _ filter ( value ) , value )
@ register . tag ( &apos; if &apos; )
def do _ if ( parser , token ) :
bits = token . split _ contents ( ) &#91; 1 : &#93;
condition = TemplateIfParser ( parser , bits ) . parse ( )
nodelist = parser . parse ( ( &apos; elif &apos; , &apos; else &apos; , &apos; endif &apos; ) )
conditions _ nodelists = &#91; ( condition , nodelist ) &#93;
token = parser . next _ token ( )
while token . contents . startswith ( &apos; elif &apos; ) :
bits = token . split _ contents ( ) &#91; 1 : &#93;
condition = TemplateIfParser ( parser , bits ) . parse ( )
nodelist = parser . parse ( ( &apos; elif &apos; , &apos; else &apos; , &apos; endif &apos; ) )
conditions _ nodelists . append ( ( condition , nodelist ) )
token = parser . next _ token ( )
if token . contents = = &apos; else &apos; :
nodelist = parser . parse ( ( &apos; endif &apos; , ) )
conditions _ nodelists . append ( ( None , nodelist ) )
token = parser . next _ token ( )
assert token . contents = = &apos; endif&apos;
return IfNode ( conditions _ nodelists )
@ register . tag
def ifchanged ( parser , token ) :
bits = token . split _ contents ( )
nodelist _ true = parser . parse ( ( &apos; else &apos; , &apos; endifchanged &apos; ) )
token = parser . next _ token ( )
if token . contents = = &apos; else &apos; :
nodelist _ false = parser . parse ( ( &apos; endifchanged &apos; , ) )
parser . delete _ first _ token ( )
else :
nodelist _ false = NodeList ( )
values = &#91; parser . compile _ filter ( bit ) for bit in bits &#91; 1 : &#93; &#93;
return IfChangedNode ( nodelist _ true , nodelist _ false , * values )
@ register . tag
def ssi ( parser , token ) :
bits = token . split _ contents ( )
parsed = False
if len ( bits ) not in ( 2 , 3 ) :
raise TemplateSyntaxError ( &quot; &apos; ssi &apos; tag takes one argument : the path to &quot; &quot; the file to be included &quot; )
if len ( bits ) = = 3 :
if bits &#91; 2 &#93; = = &apos; parsed &apos; :
parsed = True
else :
raise TemplateSyntaxError ( &quot; Second ( optional ) argument to % s tag &quot; &quot; must be &apos; parsed &apos; &quot; % bits &#91; 0 &#93; )
filepath = parser . compile _ filter ( bits &#91; 1 &#93; )
return SsiNode ( filepath , parsed )
@ register . tag
def load ( parser , token ) :
bits = token . contents . split ( )
if len ( bits ) &gt; = 4 and bits &#91; - 2 &#93; = = &quot; from &quot; :
try :
taglib = bits &#91; - 1 &#93;
lib = get _ library ( taglib )
except InvalidTemplateLibrary as e :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; is not a valid tag library : % s &quot; % ( taglib , e ) )
else :
temp _ lib = Library ( )
for name in bits &#91; 1 : - 2 &#93; :
if name in lib . tags :
temp _ lib . tags &#91; name &#93; = lib . tags &#91; name &#93;
if name in lib . filters :
temp _ lib . filters &#91; name &#93; = lib . filters &#91; name &#93;
elif name in lib . filters :
temp _ lib . filters &#91; name &#93; = lib . filters &#91; name &#93;
else :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; is not a valid tag or filter in tag library &apos; % s &apos; &quot; % ( name , taglib ) )
parser . add _ library ( temp _ lib )
else :
for taglib in bits &#91; 1 : &#93; :
try :
lib = get _ library ( taglib )
parser . add _ library ( lib )
except InvalidTemplateLibrary as e :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; is not a valid tag library : % s &quot; % ( taglib , e ) )
return LoadNode ( )
@ register . tag
def now ( parser , token ) :
bits = token . split _ contents ( )
if len ( bits ) ! = 2 :
raise TemplateSyntaxError ( &quot; &apos; now &apos; statement takes one argument &quot; )
format _ string = bits &#91; 1 &#93; &#91; 1 : - 1 &#93;
return NowNode ( format _ string )
@ register . tag
def regroup ( parser , token ) :
bits = token . split _ contents ( )
if len ( bits ) ! = 6 :
raise TemplateSyntaxError ( &quot; &apos; regroup &apos; tag takes five arguments &quot; )
target = parser . compile _ filter ( bits &#91; 1 &#93; )
if bits &#91; 2 &#93; ! = &apos; by &apos; :
raise TemplateSyntaxError ( &quot; second argument to &apos; regroup &apos; tag must be &apos; by &apos; &quot; )
if bits &#91; 4 &#93; ! = &apos; as &apos; :
raise TemplateSyntaxError ( &quot; next-to-last argument to &apos; regroup &apos; tag must &quot; &quot; be &apos; as &apos; &quot; )
var _ name = bits &#91; 5 &#93;
expression = parser . compile _ filter ( var _ name + VARIABLE _ ATTRIBUTE _ SEPARATOR + bits &#91; 3 &#93; )
return RegroupNode ( target , expression , var _ name )
@ register . tag
def spaceless ( parser , token ) :
nodelist = parser . parse ( ( &apos; endspaceless &apos; , ) )
parser . delete _ first _ token ( )
return SpacelessNode ( nodelist )
@ register . tag
def templatetag ( parser , token ) :
bits = token . contents . split ( )
if len ( bits ) ! = 2 :
raise TemplateSyntaxError ( &quot; &apos; templatetag &apos; statement takes one argument &quot; )
tag = bits &#91; 1 &#93;
if tag not in TemplateTagNode . mapping :
raise TemplateSyntaxError ( &quot; Invalid templatetag argument : &apos; % s &apos; . &quot; &quot; must be one of : % s &quot; % ( tag , list ( TemplateTagNode . mapping ) ) )
return TemplateTagNode ( tag )
@ register . tag
def url ( parser , token ) :
bits = token . split _ contents ( )
if len ( bits ) &lt; 2 :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; takes at least one argument &quot; &quot; ( path to a view ) &quot; % bits &#91; 0 &#93; )
viewname = parser . compile _ filter ( bits &#91; 1 &#93; )
args = &#91; &#93;
kwargs = { }
asvar = None
bits = bits &#91; 2 : &#93;
if len ( bits ) &gt; = 2 and bits &#91; - 2 &#93; = = &apos; as &apos; :
asvar = bits &#91; - 1 &#93;
bits = bits &#91; : - 2 &#93;
if len ( bits ) :
for bit in bits :
match = kwarg _ re . match ( bit )
if not match :
raise TemplateSyntaxError ( &quot; Malformed arguments to url tag &quot; )
name , value = match . groups ( )
if name :
kwargs &#91; name &#93; = parser . compile _ filter ( value )
else :
args . append ( parser . compile _ filter ( value ) )
return URLNode ( viewname , args , kwargs , asvar )
@ register . tag
def verbatim ( parser , token ) :
nodelist = parser . parse ( ( &apos; endverbatim &apos; , ) )
parser . delete _ first _ token ( )
return VerbatimNode ( nodelist . render ( Context ( ) ) )
@ register . tag
def widthratio ( parser , token ) :
bits = token . split _ contents ( )
if len ( bits ) = = 4 :
tag , this _ value _ expr , max _ value _ expr , max _ width = bits
asvar = None
elif len ( bits ) = = 6 :
tag , this _ value _ expr , max _ value _ expr , max _ width , as _ , asvar = bits
if as _ ! = &apos; as &apos; :
raise TemplateSyntaxError ( &quot; Invalid syntax in widthratio tag . expecting &apos; as &apos; keyword &quot; )
else :
raise TemplateSyntaxError ( &quot; widthratio takes at least three arguments &quot; )
return WidthRatioNode ( parser . compile _ filter ( this _ value _ expr ) , parser . compile _ filter ( max _ value _ expr ) , parser . compile _ filter ( max _ width ) , asvar = asvar )
@ register . tag ( &apos; with &apos; )
def do _ with ( parser , token ) :
bits = token . split _ contents ( )
remaining _ bits = bits &#91; 1 : &#93;
extra _ context = token _ kwargs ( remaining _ bits , parser , support _ legacy = True )
if not extra _ context :
raise TemplateSyntaxError ( &quot; % r expected at least one variable &quot; &quot; assignment &quot; % bits &#91; 0 &#93; )
if remaining _ bits :
raise TemplateSyntaxError ( &quot; % r received an invalid token : % r &quot; % ( bits &#91; 0 &#93; , remaining _ bits &#91; 0 &#93; ) )
nodelist = parser . parse ( ( &apos; endwith &apos; , ) )
parser . delete _ first _ token ( )
return WithNode ( None , None , nodelist , extra _ context = extra _ context )
from django . core . exceptions import ImproperlyConfigured
from django . template . base import Origin , Template , Context , TemplateDoesNotExist
from django . conf import settings
from django . utils . module _ loading import import _ string
from django . utils import six
template _ source _ loaders = None
class BaseLoader ( object ) :
is _ usable = False
def _ _ init _ _ ( self , * args , * * kwargs ) :
pass
def _ _ call _ _ ( self , template _ name , template _ dirs = None ) :
return self . load _ template ( template _ name , template _ dirs )
def load _ template ( self , template _ name , template _ dirs = None ) :
source , display _ name = self . load _ template _ source ( template _ name , template _ dirs )
origin = make _ origin ( display _ name , self . load _ template _ source , template _ name , template _ dirs )
try :
template = get _ template _ from _ string ( source , origin , template _ name )
return template , None
except TemplateDoesNotExist :
return source , display _ name
def load _ template _ source ( self , template _ name , template _ dirs = None ) :
raise NotImplementedError ( &apos; subclasses of BaseLoader must provide a load _ template _ source ( ) method &apos; )
def reset ( self ) :
pass
class LoaderOrigin ( Origin ) :
def _ _ init _ _ ( self , display _ name , loader , name , dirs ) :
super ( LoaderOrigin , self ) . _ _ init _ _ ( display _ name )
self . loader , self . loadname , self . dirs = loader , name , dirs
def reload ( self ) :
return self . loader ( self . loadname , self . dirs ) &#91; 0 &#93;
def make _ origin ( display _ name , loader , name , dirs ) :
if settings . template _ DEBUG and display _ name :
return LoaderOrigin ( display _ name , loader , name , dirs )
else :
return None
def find _ template _ loader ( loader ) :
if isinstance ( loader , ( tuple , list ) ) :
loader , args = loader &#91; 0 &#93; , loader &#91; 1 : &#93;
else :
args = &#91; &#93;
if isinstance ( loader , six . string _ types ) :
TemplateLoader = import _ string ( loader )
if hasattr ( TemplateLoader , &apos; load _ template _ source &apos; ) :
func = TemplateLoader ( * args )
else :
if args :
raise ImproperlyConfigured ( &quot; Error importing template source loader % s - can &apos;t pass arguments to function-based loader . &quot; % loader )
func = TemplateLoader
if not func . is _ usable :
import warnings
warnings . warn ( &quot; Your TEMPLATE _ LOADERS setting includes % r , but your Python installation doesn &apos;t support that type of template loading . Consider removing that line from TEMPLATE _ LOADERS . &quot; % loader )
return None
else :
return func
else :
raise ImproperlyConfigured ( &apos; Loader does not define a &quot; load _ template &quot; callable template source loader &apos; )
def find _ template ( name , dirs = None ) :
global template _ source _ loaders
if template _ source _ loaders is None :
loaders = &#91; &#93;
for loader _ name in settings . template _ LOADERS :
loader = find _ template _ loader ( loader _ name )
if loader is not None :
loaders . append ( loader )
template _ source _ loaders = tuple ( loaders )
for loader in template _ source _ loaders :
try :
source , display _ name = loader ( name , dirs )
return ( source , make _ origin ( display _ name , loader , name , dirs ) )
except TemplateDoesNotExist :
pass
raise TemplateDoesNotExist ( name )
def get _ template ( template _ name , dirs = None ) :
template , origin = find _ template ( template _ name , dirs )
if not hasattr ( template , &apos; render &apos; ) :
template = get _ template _ from _ string ( template , origin , template _ name )
return template
def get _ template _ from _ string ( source , origin = None , name = None ) :
return Template ( source , origin , name )
def render _ to _ string ( template _ name , dictionary = None , context _ instance = None , dirs = None ) :
if isinstance ( template _ name , ( list , tuple ) ) :
t = select _ template ( template _ name , dirs )
else :
t = get _ template ( template _ name , dirs )
if not context _ instance :
return t . render ( Context ( dictionary ) )
if not dictionary :
return t . render ( context _ instance )
with context _ instance . push ( dictionary ) :
return t . render ( context _ instance )
def select _ template ( template _ name _ list , dirs = None ) :
if not template _ name _ list :
raise TemplateDoesNotExist ( &quot; No template names provided &quot; )
not _ found = &#91; &#93;
for template _ name in template _ name _ list :
try :
return get _ template ( template _ name , dirs )
except TemplateDoesNotExist as e :
if e . args &#91; 0 &#93; not in not _ found :
not _ found . append ( e . args &#91; 0 &#93; )
continue
raise TemplateDoesNotExist ( &apos; , &apos; . join ( not _ found ) )
from collections import defaultdict
from django . conf import settings
from django . template . base import TemplateSyntaxError , Library , Node , TextNode , token _ kwargs , Variable
from django . template . loader import get _ template
from django . utils . SafeString import mark _ safe
from django . utils import six
register = Library ( )
block _ CONTEXT _ KEY = &apos; block _ context&apos;
class ExtendsError ( Exception ) :
pass
class BlockContext ( object ) :
def _ _ init _ _ ( self ) :
self . blocks = defaultdict ( list )
def add _ blocks ( self , blocks ) :
for name , block in six . iteritems ( blocks ) :
self . blocks &#91; name &#93; . insert ( 0 , block )
def pop ( self , name ) :
try :
return self . blocks &#91; name &#93; . pop ( )
except IndexError :
return None
def push ( self , name , block ) :
self . blocks &#91; name &#93; . append ( block )
def get _ block ( self , name ) :
try :
return self . blocks &#91; name &#93; &#91; - 1 &#93;
except IndexError :
return None
class BlockNode ( Node ) :
def _ _ init _ _ ( self , name , nodelist , parent = None ) :
self . name , self . nodelist , self . parent = name , nodelist , parent
def _ _ repr _ _ ( self ) :
return &quot; &lt; Block Node : % s . contents : % r &gt; &quot; % ( self . name , self . nodelist )
def render ( self , context ) :
block _ context = context . render _ context . get ( BLOCK _ CONTEXT _ KEY )
with context . push ( ) :
if block _ context is None :
context &#91; &apos; block &apos; &#93; = self
result = self . nodelist . render ( context )
else :
push = block = block _ context . pop ( self . name )
if block is None :
block = self
block = type ( self ) ( block . name , block . nodelist )
block . context = context
context &#91; &apos; block &apos; &#93; = block
result = block . nodelist . render ( context )
if push is not None :
block _ context . push ( self . name , push )
return result
def super ( self ) :
render _ context = self . context . render _ context
if ( BLOCK _ CONTEXT _ KEY in render _ context and render _ context &#91; BLOCK _ CONTEXT _ KEY &#93; . get _ block ( self . name ) is not None ) :
return mark _ safe ( self . render ( self . context ) )
return &apos; &apos;
class ExtendsNode ( Node ) :
must _ be _ first = True
def _ _ init _ _ ( self , nodelist , parent _ name , template _ dirs = None ) :
self . nodelist = nodelist
self . parent _ name = parent _ name
self . template _ dirs = template _ dirs
self . blocks = dict ( ( n . name , n ) for n in nodelist . get _ nodes _ by _ type ( BlockNode ) )
def _ _ repr _ _ ( self ) :
return &apos; &lt; ExtendsNode : extends % s &gt; &apos; % self . parent _ name . token
def get _ parent ( self , context ) :
parent = self . parent _ name . resolve ( context )
if not parent :
error _ msg = &quot; Invalid template name in &apos; extends &apos; tag : % r . &quot; % parent
if self . parent _ name . filters or isinstance ( self . parent _ name . var , Variable ) :
error _ msg + = &quot; Got this from the &apos; % s &apos; variable . &quot; % self . parent _ name . token
raise TemplateSyntaxError ( error _ msg )
if hasattr ( parent , &apos; render &apos; ) :
return parent
return get _ template ( parent )
def render ( self , context ) :
compiled _ parent = self . get _ parent ( context )
if BLOCK _ CONTEXT _ KEY not in context . render _ context :
context . render _ context &#91; BLOCK _ CONTEXT _ KEY &#93; = BlockContext ( )
block _ context = context . render _ context &#91; BLOCK _ CONTEXT _ KEY &#93;
block _ context . add _ blocks ( self . blocks )
for node in compiled _ parent . nodelist :
if not isinstance ( node , TextNode ) :
if not isinstance ( node , ExtendsNode ) :
blocks = dict ( ( n . name , n ) for n in compiled _ parent . nodelist . get _ nodes _ by _ type ( BlockNode ) )
block _ context . add _ blocks ( blocks )
break
return compiled _ parent . _ render ( context )
class IncludeNode ( Node ) :
def _ _ init _ _ ( self , template , * args , * * kwargs ) :
self . template = template
self . extra _ context = kwargs . pop ( &apos; extra _ context &apos; , { } )
self . isolated _ context = kwargs . pop ( &apos; isolated _ context &apos; , False )
super ( IncludeNode , self ) . _ _ init _ _ ( * args , * * kwargs )
def render ( self , context ) :
try :
template = self . template . resolve ( context )
if not callable ( getattr ( template , &apos; render &apos; , None ) ) :
template = get _ template ( template )
values = { name : var . resolve ( context ) for name , var in six . iteritems ( self . extra _ context ) }
if self . isolated _ context :
return template . render ( context . new ( values ) )
with context . push ( * * values ) :
return template . render ( context )
except Exception :
if settings . template _ DEBUG :
raise
return &apos; &apos;
@ register . tag ( &apos; block &apos; )
def do _ block ( parser , token ) :
bits = token . contents . split ( )
if len ( bits ) ! = 2 :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; tag takes only one argument &quot; % bits &#91; 0 &#93; )
block _ name = bits &#91; 1 &#93;
try :
if block _ name in parser . _ _ loaded _ blocks :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; tag with name &apos; % s &apos; appears more than once &quot; % ( bits &#91; 0 &#93; , block _ name ) )
parser . _ _ loaded _ blocks . append ( block _ name )
except AttributeError :
parser . _ _ loaded _ blocks = &#91; block _ name &#93;
nodelist = parser . parse ( ( &apos; endblock &apos; , ) )
endblock = parser . next _ token ( )
acceptable _ endblocks = ( &apos; endblock &apos; , &apos; endblock % s &apos; % block _ name )
if endblock . contents not in acceptable _ endblocks :
parser . invalid _ block _ tag ( endblock , &apos; endblock &apos; , acceptable _ endblocks )
return BlockNode ( block _ name , nodelist )
@ register . tag ( &apos; extends &apos; )
def do _ extends ( parser , token ) :
bits = token . split _ contents ( )
if len ( bits ) ! = 2 :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; takes one argument &quot; % bits &#91; 0 &#93; )
parent _ name = parser . compile _ filter ( bits &#91; 1 &#93; )
nodelist = parser . parse ( )
if nodelist . get _ nodes _ by _ type ( ExtendsNode ) :
raise TemplateSyntaxError ( &quot; &apos; % s &apos; cannot appear more than once in the same template &quot; % bits &#91; 0 &#93; )
return ExtendsNode ( nodelist , parent _ name )
@ register . tag ( &apos; include &apos; )
def do _ include ( parser , token ) :
bits = token . split _ contents ( )
if len ( bits ) &lt; 2 :
raise TemplateSyntaxError ( &quot; % r tag takes at least one argument : the name of the template to be included . &quot; % bits &#91; 0 &#93; )
options = { }
remaining _ bits = bits &#91; 2 : &#93;
while remaining _ bits :
option = remaining _ bits . pop ( 0 )
if option in options :
raise TemplateSyntaxError ( &apos; The % r option was specified more &apos; &apos; than once . &apos; % option )
if option = = &apos; with &apos; :
value = token _ kwargs ( remaining _ bits , parser , support _ legacy = False )
if not value :
raise TemplateSyntaxError ( &apos; &quot; with &quot; in % r tag needs at least &apos; &apos; one keyword argument . &apos; % bits &#91; 0 &#93; )
elif option = = &apos; only &apos; :
value = True
else :
raise TemplateSyntaxError ( &apos; Unknown argument for % r tag : % r . &apos; % ( bits &#91; 0 &#93; , option ) )
options &#91; option &#93; = value
isolated _ context = options . get ( &apos; only &apos; , False )
namemap = options . get ( &apos; with &apos; , { } )
return IncludeNode ( parser . compile _ filter ( bits &#91; 1 &#93; ) , extra _ context = namemap , isolated _ context = isolated _ context )
import os
import sys
from django . apps import apps
from django . conf import settings
from django . template . base import TemplateDoesNotExist
from django . template . loader import BaseLoader
from django . utils . _ os import safe _ join
from django . utils import six
def calculate _ app _ template _ dirs ( ) :
if six . PY2 :
fs _ encoding = sys . getfilesystemencoding ( ) or sys . getdefaultencoding ( )
app _ template _ dirs = &#91; &#93;
for app _ config in apps . get _ app _ configs ( ) :
if not app _ config . path :
continue
template _ dir = os . path . join ( app _ config . path , &apos; templates &apos; )
if os . path . isdir ( template _ dir ) :
if six . PY2 :
template _ dir = template _ dir . decode ( fs _ encoding )
app _ template _ dirs . append ( template _ dir )
return tuple ( app _ template _ dirs )
app _ template _ dirs = calculate _ app _ template _ dirs ( )
class Loader ( BaseLoader ) :
is _ usable = True
def get _ template _ sources ( self , template _ name , template _ dirs = None ) :
if not template _ dirs :
template _ dirs = app _ template _ dirs
for template _ dir in template _ dirs :
try :
yield safe _ join ( template _ dir , template _ name )
except UnicodeDecodeError :
raise
except ValueError :
pass
def load _ template _ source ( self , template _ name , template _ dirs = None ) :
for filepath in self . get _ template _ sources ( template _ name , template _ dirs ) :
try :
with open ( filepath , &apos; rb &apos; ) as fp :
return ( fp . read ( ) . decode ( settings . file _ CHARSET ) , filepath )
except IOError :
pass
raise TemplateDoesNotExist ( template _ name )
import hashlib
from django . template . base import TemplateDoesNotExist
from django . template . loader import BaseLoader , get _ template _ from _ string , find _ template _ loader , make _ origin
from django . utils . encoding import force _ bytes
class Loader ( BaseLoader ) :
is _ usable = True
def _ _ init _ _ ( self , loaders ) :
self . template _ cache = { }
self . find _ template _ cache = { }
self . _ loaders = loaders
self . _ cached _ loaders = &#91; &#93;
@ property
def loaders ( self ) :
if not self . _ cached _ loaders :
cached _ loaders = &#91; &#93;
for loader in self . _ loaders :
cached _ loaders . append ( find _ template _ loader ( loader ) )
self . _ cached _ loaders = cached _ loaders
return self . _ cached _ loaders
def cache _ key ( self , template _ name , template _ dirs ) :
if template _ dirs :
return &apos; -&apos; . join ( &#91; template _ name , hashlib . sha1 ( force _ bytes ( &apos; &#124; &apos; . join ( template _ dirs ) ) ) . hexdigest ( ) &#93; )
else :
return template _ name
def find _ template ( self , name , dirs = None ) :
key = self . cache _ key ( name , dirs )
try :
result = self . find _ template _ cache &#91; key &#93;
except KeyError :
result = None
for loader in self . loaders :
try :
template , display _ name = loader ( name , dirs )
except TemplateDoesNotExist :
pass
else :
result = ( template , make _ origin ( display _ name , loader , name , dirs ) )
break
self . find _ template _ cache &#91; key &#93; = result
if result :
return result
else :
self . template _ cache &#91; key &#93; = TemplateDoesNotExist
raise TemplateDoesNotExist ( name )
def load _ template ( self , template _ name , template _ dirs = None ) :
key = self . cache _ key ( template _ name , template _ dirs )
template _ tuple = self . template _ cache . get ( key )
if template _ tuple is TemplateDoesNotExist :
raise TemplateDoesNotExist
elif template _ tuple is None :
template , origin = self . find _ template ( template _ name , template _ dirs )
if not hasattr ( template , &apos; render &apos; ) :
try :
template = get _ template _ from _ string ( template , origin , template _ name )
except TemplateDoesNotExist :
self . template _ cache &#91; key &#93; = ( template , origin )
self . template _ cache &#91; key &#93; = ( template , None )
return self . template _ cache &#91; key &#93;
def reset ( self ) :
self . template _ cache . clear ( )
self . find _ template _ cache . clear ( )
from _ _ future _ _ import unicode _ literals
try :
from pkg _ resources import resource _ string
except ImportError :
resource _ string = None
from django . apps import apps
from django . conf import settings
from django . template . base import TemplateDoesNotExist
from django . template . loader import BaseLoader
from django . utils import six
class Loader ( BaseLoader ) :
is _ usable = resource _ string is not None
def load _ template _ source ( self , template _ name , template _ dirs = None ) :
if resource _ string is not None :
pkg _ name = &apos; templates / &apos; + template _ name
for app _ config in apps . get _ app _ configs ( ) :
try :
resource = resource _ string ( app _ config . name , pkg _ name )
except Exception :
continue
if six . PY2 :
resource = resource . decode ( settings . file _ CHARSET )
return ( resource , &apos; egg : % s : % s &apos; % ( app _ config . name , pkg _ name ) )
raise TemplateDoesNotExist ( template _ name )
from django . conf import settings
from django . template . base import TemplateDoesNotExist
from django . template . loader import BaseLoader
from django . utils . _ os import safe _ join
class Loader ( BaseLoader ) :
is _ usable = True
def get _ template _ sources ( self , template _ name , template _ dirs = None ) :
if not template _ dirs :
template _ dirs = settings . template _ DIRS
for template _ dir in template _ dirs :
try :
yield safe _ join ( template _ dir , template _ name )
except UnicodeDecodeError :
raise
except ValueError :
pass
def load _ template _ source ( self , template _ name , template _ dirs = None ) :
tried = &#91; &#93;
for filepath in self . get _ template _ sources ( template _ name , template _ dirs ) :
try :
with open ( filepath , &apos; rb &apos; ) as fp :
return ( fp . read ( ) . decode ( settings . file _ CHARSET ) , filepath )
except IOError :
tried . append ( filepath )
if tried :
error _ msg = &quot; Tried % s &quot; % tried
else :
error _ msg = &quot; Your TEMPLATE _ DIRS setting is empty . change it to point to at least one template directory . &quot;
raise TemplateDoesNotExist ( error _ msg )
load _ template _ source . is _ usable = True
from django . http import HttpResponse
from django . template import loader , Context , RequestContext
from django . utils import six
class ContentNotRenderedError ( Exception ) :
pass
class SimpleTemplateResponse ( HttpResponse ) :
Rendering _ attrs = &#91; &apos; template _ name &apos; , &apos; context _ data &apos; , &apos; _ post _ render _ callbacks &apos; &#93;
def _ _ init _ _ ( self , template , context = None , content _ type = None , status = None ) :
self . template _ name = template
self . context _ data = context
self . _ post _ render _ callbacks = &#91; &#93;
super ( SimpleTemplateResponse , self ) . _ _ init _ _ ( &apos; &apos; , content _ type , status )
self . _ is _ rendered = False
def _ _ getstate _ _ ( self ) :
obj _ dict = super ( SimpleTemplateResponse , self ) . _ _ getstate _ _ ( )
if not self . _ is _ rendered :
raise ContentNotRenderedError ( &apos; The response content must be &apos; &apos; rendered before it can be pickled . &apos; )
for attr in self . Rendering _ attrs :
if attr in obj _ dict :
del obj _ dict &#91; attr &#93;
return obj _ dict
def resolve _ template ( self , template ) :
if isinstance ( template , ( list , tuple ) ) :
return loader . select _ template ( template )
elif isinstance ( template , six . string _ types ) :
return loader . get _ template ( template )
else :
return template
def resolve _ context ( self , context ) :
if isinstance ( context , Context ) :
return context
else :
return Context ( context )
@ property
def rendered _ content ( self ) :
template = self . resolve _ template ( self . template _ name )
context = self . resolve _ context ( self . context _ data )
content = template . render ( context )
return content
def add _ post _ render _ callback ( self , callback ) :
if self . _ is _ rendered :
callback ( self )
else :
self . _ post _ render _ callbacks . append ( callback )
def render ( self ) :
retval = self
if not self . _ is _ rendered :
self . content = self . rendered _ content
for post _ callback in self . _ post _ render _ callbacks :
newretval = post _ callback ( retval )
if newretval is not None :
retval = newretval
return retval
@ property
def is _ rendered ( self ) :
return self . _ is _ rendered
def _ _ iter _ _ ( self ) :
if not self . _ is _ rendered :
raise ContentNotRenderedError ( &apos; The response content must be &apos; &apos; rendered before it can be iterated over . &apos; )
return super ( SimpleTemplateResponse , self ) . _ _ iter _ _ ( )
@ property
def content ( self ) :
if not self . _ is _ rendered :
raise ContentNotRenderedError ( &apos; The response content must be &apos; &apos; rendered before it can be accessed . &apos; )
return super ( SimpleTemplateResponse , self ) . content
@ content . setter
def content ( self , value ) :
HttpResponse . content . fset ( self , value )
self . _ is _ rendered = True
class TemplateResponse ( SimpleTemplateResponse ) :
Rendering _ attrs = SimpleTemplateResponse . Rendering _ attrs + &#91; &apos; _ request &apos; , &apos; _ current _ app &apos; &#93;
def _ _ init _ _ ( self , request , template , context = None , content _ type = None , status = None , current _ app = None ) :
self . _ request = request
self . _ current _ app = current _ app
super ( TemplateResponse , self ) . _ _ init _ _ ( template , context , content _ type , status )
def resolve _ context ( self , context ) :
if isinstance ( context , Context ) :
return context
return RequestContext ( self . _ request , context , current _ app = self . _ current _ app )
class TokenBase ( object ) :
id = None
value = None
first = second = None
def nud ( self , parser ) :
raise parser . error _ class ( &quot; Not expecting &apos; % s &apos; in this position in if tag . &quot; % self . id )
def led ( self , left , parser ) :
raise parser . error _ class ( &quot; Not expecting &apos; % s &apos; as infix operator in if tag . &quot; % self . id )
def display ( self ) :
return self . id
def _ _ repr _ _ ( self ) :
out = &#91; str ( x ) for x in &#91; self . id , self . first , self . second &#93; if x is not None &#93;
return &quot; ( &quot; + &quot; &quot; . join ( out ) + &quot; ) &quot;
def infix ( bp , func ) :
class Operator ( TokenBase ) :
lbp = bp
def led ( self , left , parser ) :
self . first = left
self . second = parser . expression ( bp )
return self
def eval ( self , context ) :
try :
return func ( context , self . first , self . second )
except Exception :
return False
return Operator
def prefix ( bp , func ) :
class Operator ( TokenBase ) :
lbp = bp
def nud ( self , parser ) :
self . first = parser . expression ( bp )
self . second = None
return self
def eval ( self , context ) :
try :
return func ( context , self . first )
except Exception :
return False
return Operator
OPERATORS = { &apos; or &apos; : infix ( 6 , lambda context , x , y : x . eval ( context ) or y . eval ( context ) ) , &apos; and &apos; : infix ( 7 , lambda context , x , y : x . eval ( context ) and y . eval ( context ) ) , &apos; not &apos; : prefix ( 8 , lambda context , x : not x . eval ( context ) ) , &apos; in &apos; : infix ( 9 , lambda context , x , y : x . eval ( context ) in y . eval ( context ) ) , &apos; not in &apos; : infix ( 9 , lambda context , x , y : x . eval ( context ) not in y . eval ( context ) ) , &apos; = &apos; : infix ( 10 , lambda context , x , y : x . eval ( context ) = = y . eval ( context ) ) , &apos; = = &apos; : infix ( 10 , lambda context , x , y : x . eval ( context ) = = y . eval ( context ) ) , &apos; ! = &apos; : infix ( 10 , lambda context , x , y : x . eval ( context ) ! = y . eval ( context ) ) , &apos; &gt; &apos; : infix ( 10 , lambda context , x , y : x . eval ( context ) &gt; y . eval ( context ) ) , &apos; &gt; = &apos; : infix ( 10 , lambda context , x , y : x . eval ( context ) &gt; = y . eval ( context ) ) , &apos; &lt; &apos; : infix ( 10 , lambda context , x , y : x . eval ( context ) &lt; y . eval ( context ) ) , &apos; &lt; = &apos; : infix ( 10 , lambda context , x , y : x . eval ( context ) &lt; = y . eval ( context ) ) , }
for key , op in OPERATORS . items ( ) :
op . id = key
class Literal ( TokenBase ) :
id = &quot; literal &quot;
lbp = 0
def _ _ init _ _ ( self , value ) :
self . value = value
def display ( self ) :
return repr ( self . value )
def nud ( self , parser ) :
return self
def eval ( self , context ) :
return self . value
def _ _ repr _ _ ( self ) :
return &quot; ( % s % r ) &quot; % ( self . id , self . value )
class EndToken ( TokenBase ) :
lbp = 0
def nud ( self , parser ) :
raise parser . error _ class ( &quot; Unexpected end of expression in if tag . &quot; )
EndToken = EndToken ( )
class IfParser ( object ) :
error _ class = ValueError
def _ _ init _ _ ( self , tokens ) :
l = len ( tokens )
mapped _ tokens = &#91; &#93;
i = 0
while i &lt; l :
token = tokens &#91; i &#93;
if token = = &quot; not &quot; and i + 1 &lt; l and tokens &#91; i + 1 &#93; = = &quot; in &quot; :
token = &quot; not in &quot;
i + = 1
mapped _ tokens . append ( self . translate _ token ( token ) )
i + = 1
self . tokens = mapped _ tokens
self . pos = 0
self . current _ token = self . next _ token ( )
def translate _ token ( self , token ) :
try :
op = OPERATORS &#91; token &#93;
except ( KeyError , TypeError ) :
return self . create _ var ( token )
else :
return op ( )
def next _ token ( self ) :
if self . pos &gt; = len ( self . tokens ) :
return EndToken
else :
retval = self . tokens &#91; self . pos &#93;
self . pos + = 1
return retval
def parse ( self ) :
retval = self . expression ( )
if self . current _ token is not EndToken :
raise self . error _ class ( &quot; Unused &apos; % s &apos; at end of if expression . &quot; % self . current _ token . display ( ) )
return retval
def expression ( self , rbp = 0 ) :
t = self . current _ token
self . current _ token = self . next _ token ( )
left = t . nud ( self )
while rbp &lt; self . current _ token . lbp :
t = self . current _ token
self . current _ token = self . next _ token ( )
left = t . led ( left , self )
return left
def create _ var ( self , value ) :
return Literal ( value )
from _ _ future _ _ import unicode _ literals
from lib2to3 import fixer _ base
from lib2to3 . fixer _ util import find _ indentation , Name , syms , touch _ import
from lib2to3 . pgen2 import token
from lib2to3 . pytree import Leaf , Node
class FixUnicode ( fixer _ base . BaseFix ) :
BM _ compatible = True
pattern = &quot; &quot; &quot; classdef &lt; &apos; class &apos; any + &apos; : &apos; suite &lt; any * funcdef &lt; &apos; def &apos; unifunc = &apos; _ _ unicode _ _ &apos; parameters &lt; &apos; ( &apos; NAME &apos; ) &apos; &gt; any + &gt; any * &gt; &gt; &quot; &quot; &quot;
def transform ( self , node , results ) :
unifunc = results &#91; &quot; unifunc &quot; &#93;
strfunc = Name ( &quot; _ _ str _ _ &quot; , prefix = unifunc . prefix )
unifunc . replace ( strfunc )
klass = node . clone ( )
klass . prefix = &apos; \ n &apos; + find _ indentation ( node )
decorator = Node ( syms . decorator , &#91; Leaf ( token . at , &quot; @ &quot; ) , Name ( &apos; python _ 2 _ unicode _ compatible &apos; ) &#93; )
decorated = Node ( syms . decorated , &#91; decorator , klass &#93; , prefix = node . prefix )
node . replace ( decorated )
touch _ import ( &apos; django.utils.encoding &apos; , &apos; python _ 2 _ unicode _ compatible &apos; , decorated )
import os
import stat
import sys
import tempfile
from os . path import join , normcase , normpath , abspath , isabs , sep , dirname
from django . utils . encoding import force _ text
from django . utils import six
try :
WindowsError = WindowsError
except NameError :
class WindowsError ( Exception ) :
pass
if six . PY2 :
fs _ encoding = sys . getfilesystemencoding ( ) or sys . getdefaultencoding ( )
if six . PY3 or os . name = = &apos; nt &apos; :
abspathu = abspath
else :
def abspathu ( path ) :
if not isabs ( path ) :
path = join ( os . getcwdu ( ) , path )
return normpath ( path )
def upath ( path ) :
if six . PY2 and not isinstance ( path , six . text _ type ) :
return path . decode ( fs _ encoding )
return path
def npath ( path ) :
if six . PY2 and not isinstance ( path , bytes ) :
return path . encode ( fs _ encoding )
return path
def safe _ join ( base , * paths ) :
base = force _ text ( base )
paths = &#91; force _ text ( p ) for p in paths &#93;
final _ path = abspathu ( join ( base , * paths ) )
base _ path = abspathu ( base )
if ( not normcase ( final _ path ) . startswith ( normcase ( base _ path + sep ) ) and normcase ( final _ path ) ! = normcase ( base _ path ) and dirname ( normcase ( base _ path ) ) ! = normcase ( base _ path ) ) :
raise ValueError ( &apos; The joined path ( % s ) is located outside of the base &apos; &apos; path component ( % s ) &apos; % ( final _ path , base _ path ) )
return final _ path
def rmtree _ errorhandler ( func , path , exc _ info ) :
exctype , value = exc _ info &#91; : 2 &#93;
if exctype is not WindowsError or &apos; Access is denied &apos; not in str ( value ) :
raise
if ( ( os . stat ( path ) . st _ mode &amp; stat . s _ IREAD ) ! = stat . s _ IREAD ) :
raise
os . chmod ( path , stat . s _ IWRITE )
func ( path )
def symlinks _ supported ( ) :
tmpdir = tempfile . mkdtemp ( )
original _ path = os . path . join ( tmpdir , &apos; original &apos; )
symlink _ path = os . path . join ( tmpdir , &apos; symlink &apos; )
os . makedirs ( original _ path )
try :
os . symlink ( original _ path , symlink _ path )
supported = True
except ( OSError , NotImplementedError , AttributeError ) :
supported = False
else :
os . remove ( symlink _ path )
finally :
os . rmdir ( original _ path )
os . rmdir ( tmpdir )
return supported
import os
import shutil
import tarfile
import zipfile
from django . utils import six
class ArchiveException ( Exception ) :
class UnrecognizedArchiveFormat ( ArchiveException ) :
def extract ( path , to _ path = &apos; &apos; ) :
with Archive ( path ) as archive :
archive . extract ( to _ path )
class Archive ( object ) :
def _ _ init _ _ ( self , file ) :
self . _ archive = self . _ archive _ cls ( file ) ( file )
@ staticmethod
def _ archive _ cls ( file ) :
cls = None
if isinstance ( file , six . string _ types ) :
filename = file
else :
try :
filename = file . name
except AttributeError :
raise UnrecognizedArchiveFormat ( &quot; File object not a recognized archive format . &quot; )
base , tail _ ext = os . path . splitext ( filename . lower ( ) )
cls = extension _ map . get ( tail _ ext )
if not cls :
base , ext = os . path . splitext ( base )
cls = extension _ map . get ( ext )
if not cls :
raise UnrecognizedArchiveFormat ( &quot; Path not a recognized archive format : % s &quot; % filename )
return cls
def _ _ enter _ _ ( self ) :
return self
def _ _ exit _ _ ( self , exc _ type , exc _ value , traceback ) :
self . close ( )
def extract ( self , to _ path = &apos; &apos; ) :
self . _ archive . extract ( to _ path )
def list ( self ) :
self . _ archive . list ( )
def close ( self ) :
self . _ archive . close ( )
class BaseArchive ( object ) :
def split _ leading _ dir ( self , path ) :
path = str ( path )
path = path . lstrip ( &apos; / &apos; ) . lstrip ( &apos; \ \ &apos; )
if &apos; / &apos; in path and ( ( &apos; \ \ &apos; in path and path . find ( &apos; / &apos; ) &lt; path . find ( &apos; \ \ &apos; ) ) or &apos; \ \ &apos; not in path ) :
return path . split ( &apos; / &apos; , 1 )
elif &apos; \ \ &apos; in path :
return path . split ( &apos; \ \ &apos; , 1 )
else :
return path , &apos; &apos;
def has _ leading _ dir ( self , paths ) :
common _ prefix = None
for path in paths :
prefix , rest = self . split _ leading _ dir ( path )
if not prefix :
return False
elif common _ prefix is None :
common _ prefix = prefix
elif prefix ! = common _ prefix :
return False
return True
def extract ( self ) :
raise NotImplementedError ( &apos; subclasses of BaseArchive must provide an extract ( ) method &apos; )
def list ( self ) :
raise NotImplementedError ( &apos; subclasses of BaseArchive must provide a list ( ) method &apos; )
class TarArchive ( BaseArchive ) :
def _ _ init _ _ ( self , file ) :
self . _ archive = tarfile . open ( file )
def list ( self , * args , * * kwargs ) :
self . _ archive . list ( * args , * * kwargs )
def extract ( self , to _ path ) :
members = &#91; member for member in self . _ archive . getmembers ( ) if member . name ! = &apos; pax _ global _ header &apos; &#93;
leading = self . has _ leading _ dir ( x . name for x in members )
for member in members :
name = member . name
if leading :
name = self . split _ leading _ dir ( name ) &#91; 1 &#93;
filename = os . path . join ( to _ path , name )
if member . isdir ( ) :
if filename and not os . path . exists ( filename ) :
os . makedirs ( filename )
else :
try :
extracted = self . _ archive . extractfile ( member )
except ( KeyError , AttributeError ) as exc :
print ( &quot; In the tar file % s the member % s is invalid : % s &quot; % ( name , member . name , exc ) )
else :
dirname = os . path . dirname ( filename )
if dirname and not os . path . exists ( dirname ) :
os . makedirs ( dirname )
with open ( filename , &apos; wb &apos; ) as outfile :
shutil . copyfileobj ( extracted , outfile )
finally :
if extracted :
extracted . close ( )
def close ( self ) :
self . _ archive . close ( )
class ZipArchive ( BaseArchive ) :
def _ _ init _ _ ( self , file ) :
self . _ archive = zipfile . zipfile ( file )
def list ( self , * args , * * kwargs ) :
self . _ archive . printdir ( * args , * * kwargs )
def extract ( self , to _ path ) :
namelist = self . _ archive . namelist ( )
leading = self . has _ leading _ dir ( namelist )
for name in namelist :
data = self . _ archive . read ( name )
if leading :
name = self . split _ leading _ dir ( name ) &#91; 1 &#93;
filename = os . path . join ( to _ path , name )
dirname = os . path . dirname ( filename )
if dirname and not os . path . exists ( dirname ) :
os . makedirs ( dirname )
if filename . endswith ( ( &apos; / &apos; , &apos; \ \ &apos; ) ) :
if not os . path . exists ( filename ) :
os . makedirs ( filename )
else :
with open ( filename , &apos; wb &apos; ) as outfile :
outfile . write ( data )
def close ( self ) :
self . _ archive . close ( )
extension _ map = { &apos; .tar &apos; : TarArchive , &apos; .tar.bz2 &apos; : TarArchive , &apos; .tar.gz &apos; : TarArchive , &apos; .tgz &apos; : TarArchive , &apos; .tz2 &apos; : TarArchive , &apos; .zip &apos; : ZipArchive , }
from _ _ future _ _ import absolute _ import
import os
import signal
import sys
import time
import traceback
from django . apps import apps
from django . conf import settings
from django . core . signals import request _ finished
try :
from django . utils . six . moves import _ thread as thread
except ImportError :
from django . utils . six . moves import _ dummy _ thread as thread
try :
import threading
except ImportError :
pass
try :
import termios
except ImportError :
termios = None
use _ INOTIFY = False
try :
import pyinotify
fd = pyinotify . INotifyWrapper . create ( ) . INOTIFY _ init ( )
if fd &gt; = 0 :
use _ INOTIFY = True
os . close ( fd )
except ImportError :
pass
run _ RELOADER = True
file _ MODIFIED = 1
i18n _ MODIFIED = 2
_ mtimes = { }
_ win = ( sys . platform = = &quot; win32 &quot; )
_ error _ files = &#91; &#93;
_ cached _ modules = set ( )
_ cached _ filenames = &#91; &#93;
def gen _ filenames ( only _ new = False ) :
global _ cached _ modules , _ cached _ filenames
module _ values = set ( sys . modules . values ( ) )
if _ cached _ modules = = module _ values :
if only _ new :
return &#91; &#93;
else :
return _ cached _ filenames
new _ modules = module _ values - _ cached _ modules
new _ filenames = &#91; filename . _ _ file _ _ for filename in new _ modules if hasattr ( filename , &apos; _ _ file _ _ &apos; ) &#93;
if not _ cached _ filenames and settings . use _ I18N :
basedirs = &#91; os . path . join ( os . path . dirname ( os . path . dirname ( _ _ file _ _ ) ) , &apos; conf &apos; , &apos; locale &apos; ) , &apos; locale &apos; &#93;
for app _ config in reversed ( list ( apps . get _ app _ configs ( ) ) ) :
basedirs . append ( os . path . join ( app _ config . path , &apos; locale &apos; ) )
basedirs . extend ( settings . locale _ PATHS )
basedirs = &#91; os . path . abspath ( basedir ) for basedir in basedirs if os . path . isdir ( basedir ) &#93;
for basedir in basedirs :
for dirpath , dirnames , locale _ filenames in os . walk ( basedir ) :
for filename in locale _ filenames :
if filename . endswith ( &apos; .mo &apos; ) :
new _ filenames . append ( os . path . join ( dirpath , filename ) )
if only _ new :
filelist = new _ filenames
else :
filelist = _ cached _ filenames + new _ filenames + _ error _ files
filenames = &#91; &#93;
for filename in filelist :
if not filename :
continue
if filename . endswith ( &quot; .pyc &quot; ) or filename . endswith ( &quot; .pyo &quot; ) :
filename = filename &#91; : - 1 &#93;
if filename . endswith ( &quot; $ py.class &quot; ) :
filename = filename &#91; : - 9 &#93; + &quot; .py &quot;
if os . path . exists ( filename ) :
filenames . append ( filename )
_ cached _ modules = _ cached _ modules . union ( new _ modules )
_ cached _ filenames + = new _ filenames
return filenames
def reset _ translations ( ) :
import gettext
from django . utils . translation import trans _ real
gettext . _ translations = { }
trans _ real . _ translations = { }
trans _ real . _ default = None
trans _ real . _ active = threading . local ( )
def inotify _ code _ changed ( ) :
class EventHandler ( pyinotify . ProcessEvent ) :
MODIFIED _ code = None
def process _ default ( self , event ) :
if event . path . endswith ( &apos; .mo &apos; ) :
EventHandler . MODIFIED _ code = I18N _ MODIFIED
else :
EventHandler . MODIFIED _ code = FILE _ MODIFIED
wm = pyinotify . WatchManager ( )
notifier = pyinotify . notifier ( wm , EventHandler ( ) )
def update _ watch ( sender = None , * * kwargs ) :
if sender and getattr ( sender , &apos; handles _ files &apos; , False ) :
return
mask = ( pyinotify . in _ MODIFY &#124; pyinotify . in _ DELETE &#124; pyinotify . in _ ATTRIB &#124; pyinotify . in _ MOVED _ FROM &#124; pyinotify . in _ MOVED _ TO &#124; pyinotify . in _ CREATE )
for path in gen _ filenames ( only _ new = True ) :
wm . add _ watch ( path , mask )
request _ finished . connect ( update _ watch )
update _ watch ( )
notifier . check _ events ( timeout = None )
notifier . read _ events ( )
notifier . process _ events ( )
notifier . stop ( )
return EventHandler . MODIFIED _ code
def code _ changed ( ) :
global _ mtimes , _ win
for filename in gen _ filenames ( ) :
stat = os . stat ( filename )
mtime = stat . st _ mtime
if _ win :
mtime - = stat . st _ ctime
if filename not in _ mtimes :
_ mtimes &#91; filename &#93; = mtime
continue
if mtime ! = _ mtimes &#91; filename &#93; :
_ mtimes = { }
try :
del _ error _ files &#91; _ error _ files . index ( filename ) &#93;
except ValueError :
pass
return I18N _ MODIFIED if filename . endswith ( &apos; .mo &apos; ) else FILE _ MODIFIED
return False
def check _ errors ( fn ) :
def wrapper ( * args , * * kwargs ) :
try :
fn ( * args , * * kwargs )
except ( ImportError , IndentationError , NameError , SyntaxError , TypeError , AttributeError ) :
et , ev , tb = sys . exc _ info ( )
if getattr ( ev , &apos; filename &apos; , None ) is None :
filename = traceback . extract _ tb ( tb ) &#91; - 1 &#93; &#91; 0 &#93;
else :
filename = ev . filename
if filename not in _ error _ files :
_ error _ files . append ( filename )
raise
return wrapper
def ensure _ echo _ on ( ) :
if termios :
fd = sys . stdin
if fd . isatty ( ) :
attr _ list = termios . tcgetattr ( fd )
if not attr _ list &#91; 3 &#93; &amp; termios . echo :
attr _ list &#91; 3 &#93; &#124; = termios . echo
if hasattr ( signal , &apos; SIGTTOU &apos; ) :
old _ handler = signal . signal ( signal . SIGTTOU , signal . sig _ IGN )
else :
old _ handler = None
termios . tcsetattr ( fd , termios . TCSANOW , attr _ list )
if old _ handler is not None :
signal . signal ( signal . SIGTTOU , old _ handler )
def reloader _ thread ( ) :
Ensure _ echo _ on ( )
if USE _ INOTIFY :
fn = inotify _ code _ changed
else :
fn = code _ changed
while RUN _ RELOADER :
change = fn ( )
if change = = FILE _ MODIFIED :
sys . exit ( 3 )
elif change = = I18N _ MODIFIED :
reset _ translations ( )
time . sleep ( 1 )
def restart _ with _ reloader ( ) :
while True :
args = &#91; sys . executable &#93; + &#91; &apos; -W % s &apos; % o for o in sys . warnoptions &#93; + sys . argv
if sys . platform = = &quot; win32 &quot; :
args = &#91; &apos; &quot; % s &quot; &apos; % arg for arg in args &#93;
new _ environ = os . environ . copy ( )
new _ environ &#91; &quot; RUN _ MAIN &quot; &#93; = &apos; true&apos;
exit _ code = os . spawnve ( os . p _ WAIT , sys . executable , args , new _ environ )
if exit _ code ! = 3 :
return exit _ code
def python _ reloader ( main _ func , args , kwargs ) :
if os . environ . get ( &quot; RUN _ MAIN &quot; ) = = &quot; true &quot; :
thread . start _ new _ thread ( main _ func , args , kwargs )
try :
reloader _ thread ( )
except KeyboardInterrupt :
pass
else :
try :
exit _ code = restart _ with _ reloader ( )
if exit _ code &lt; 0 :
os . kill ( os . getpid ( ) , - exit _ code )
else :
sys . exit ( exit _ code )
except KeyboardInterrupt :
pass
def jython _ reloader ( main _ func , args , kwargs ) :
from _ systemrestart import SystemRestart
thread . start _ new _ thread ( main _ func , args )
while True :
if code _ changed ( ) :
raise SystemRestart
time . sleep ( 1 )
def main ( main _ func , args = None , kwargs = None ) :
if args is None :
args = ( )
if kwargs is None :
kwargs = { }
if sys . platform . startswith ( &apos; java &apos; ) :
reloader = jython _ reloader
else :
reloader = python _ reloader
wrapped _ main _ func = check _ errors ( main _ func )
reloader ( wrapped _ main _ func , args , kwargs )
BASE2 _ ALPHABET = &apos; 01&apos;
BASE16 _ ALPHABET = &apos; 0123456789ABCDEF&apos;
base56 _ ALPHABET = &apos; 23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz&apos;
base36 _ ALPHABET = &apos; 0123456789abcdefghijklmnopqrstuvwxyz&apos;
BASE62 _ ALPHABET = &apos; 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos;
base64 _ ALPHABET = BASE62 _ ALPHABET + &apos; - _ &apos;
class BaseConverter ( object ) :
decimal _ digits = &apos; 0123456789&apos;
def _ _ init _ _ ( self , digits , sign = &apos; -&apos; ) :
self . sign = sign
self . digits = digits
if sign in self . digits :
raise ValueError ( &apos; Sign character found in converter base digits . &apos; )
def _ _ repr _ _ ( self ) :
return &quot; &lt; BaseConverter : base % s ( % s ) &gt; &quot; % ( len ( self . digits ) , self . digits )
def encode ( self , i ) :
neg , value = self . convert ( i , self . decimal _ digits , self . digits , &apos; -&apos; )
if neg :
return self . sign + value
return value
def decode ( self , s ) :
neg , value = self . convert ( s , self . digits , self . decimal _ digits , self . sign )
if neg :
value = &apos; -&apos; + value
return int ( value )
def convert ( self , number , from _ digits , to _ digits , sign ) :
if str ( number ) &#91; 0 &#93; = = sign :
number = str ( number ) &#91; 1 : &#93;
neg = 1
else :
neg = 0
x = 0
for digit in str ( number ) :
x = x * len ( from _ digits ) + from _ digits . index ( digit )
if x = = 0 :
res = to _ digits &#91; 0 &#93;
else :
res = &apos; &apos;
while x &gt; 0 :
digit = x % len ( to _ digits )
res = to _ digits &#91; digit &#93; + res
x = int ( x / / len ( to _ digits ) )
return neg , res
BASE2 = BaseConverter ( BASE2 _ ALPHABET )
BASE16 = BaseConverter ( BASE16 _ ALPHABET )
base36 = BaseConverter ( BASE36 _ ALPHABET )
base56 = BaseConverter ( BASE56 _ ALPHABET )
BASE62 = BaseConverter ( BASE62 _ ALPHABET )
base64 = BaseConverter ( BASE64 _ ALPHABET , sign = &apos; $ &apos; )
from _ _ future _ _ import unicode _ literals
import hashlib
import re
import time
from django . conf import settings
from django . core . cache import caches
from django . utils . encoding import iri _ to _ uri , force _ bytes , force _ text
from django . utils . http import http _ date
from django . utils . timezone import get _ current _ timezone _ name
from django . utils . translation import get _ language
cc _ delim _ re = re . compile ( r &apos; \ s * , \ s * &apos; )
def patch _ cache _ control ( response , * * kwargs ) :
def dictitem ( s ) :
t = s . split ( &apos; = &apos; , 1 )
if len ( t ) &gt; 1 :
return ( t &#91; 0 &#93; . lower ( ) , t &#91; 1 &#93; )
else :
return ( t &#91; 0 &#93; . lower ( ) , True )
def dictvalue ( t ) :
if t &#91; 1 &#93; is True :
return t &#91; 0 &#93;
else :
return &apos; % s = % s &apos; % ( t &#91; 0 &#93; , t &#91; 1 &#93; )
if response . has _ header ( &apos; Cache-Control &apos; ) :
cc = cc _ delim _ re . split ( response &#91; &apos; Cache-Control &apos; &#93; )
cc = dict ( dictitem ( el ) for el in cc )
else :
cc = { }
if &apos; max-age &apos; in cc and &apos; max _ age &apos; in kwargs :
kwargs &#91; &apos; max _ age &apos; &#93; = min ( int ( cc &#91; &apos; max-age &apos; &#93; ) , kwargs &#91; &apos; max _ age &apos; &#93; )
if &apos; private &apos; in cc and &apos; public &apos; in kwargs :
del cc &#91; &apos; private &apos; &#93;
elif &apos; public &apos; in cc and &apos; private &apos; in kwargs :
del cc &#91; &apos; public &apos; &#93;
for ( k , v ) in kwargs . items ( ) :
cc &#91; k . replace ( &apos; _ &apos; , &apos; -&apos; ) &#93; = v
cc = &apos; , &apos; . join ( dictvalue ( el ) for el in cc . items ( ) )
response &#91; &apos; Cache-Control &apos; &#93; = cc
def get _ max _ age ( response ) :
if not response . has _ header ( &apos; Cache-Control &apos; ) :
return
cc = dict ( _ to _ tuple ( el ) for el in cc _ delim _ re . split ( response &#91; &apos; Cache-Control &apos; &#93; ) )
if &apos; max-age &apos; in cc :
try :
return int ( cc &#91; &apos; max-age &apos; &#93; )
except ( ValueError , TypeError ) :
pass
def _ set _ response _ etag ( response ) :
if not response . streaming :
response &#91; &apos; ETag &apos; &#93; = &apos; &quot; % s &quot; &apos; % hashlib . md5 ( response . content ) . hexdigest ( )
return response
def patch _ response _ headers ( response , cache _ timeout = None ) :
if cache _ timeout is None :
cache _ timeout = settings . cache _ MIDDLEWARE _ SECONDS
if cache _ timeout &lt; 0 :
cache _ timeout = 0
if settings . use _ ETAGS and not response . has _ header ( &apos; ETag &apos; ) :
if hasattr ( response , &apos; render &apos; ) and callable ( response . render ) :
response . add _ post _ render _ callback ( _ set _ response _ etag )
else :
response = _ set _ response _ etag ( response )
if not response . has _ header ( &apos; Last-Modified &apos; ) :
response &#91; &apos; Last-Modified &apos; &#93; = http _ date ( )
if not response . has _ header ( &apos; Expires &apos; ) :
response &#91; &apos; Expires &apos; &#93; = http _ date ( time . time ( ) + cache _ timeout )
patch _ cache _ control ( response , max _ age = cache _ timeout )
def add _ never _ cache _ headers ( response ) :
patch _ response _ headers ( response , cache _ timeout = - 1 )
def patch _ vary _ headers ( response , newheaders ) :
&quot; &quot; &quot; Adds ( or updates ) the &quot; Vary &quot; header in the given HttpResponse object. newheaders is a list of header names that should be in &quot; Vary &quot; . existing headers in &quot; Vary &quot; aren &apos;t removed . &quot; &quot; &quot;
if response . has _ header ( &apos; Vary &apos; ) :
vary _ headers = cc _ delim _ re . split ( response &#91; &apos; Vary &apos; &#93; )
else :
vary _ headers = &#91; &#93;
existing _ headers = set ( header . lower ( ) for header in vary _ headers )
additional _ headers = &#91; newheader for newheader in newheaders if newheader . lower ( ) not in existing _ headers &#93;
response &#91; &apos; Vary &apos; &#93; = &apos; , &apos; . join ( vary _ headers + additional _ headers )
def has _ vary _ header ( response , header _ query ) :
if not response . has _ header ( &apos; Vary &apos; ) :
return False
vary _ headers = cc _ delim _ re . split ( response &#91; &apos; Vary &apos; &#93; )
existing _ headers = set ( header . lower ( ) for header in vary _ headers )
return header _ query . lower ( ) in existing _ headers
def _ i18n _ cache _ key _ suffix ( request , cache _ key ) :
if settings . use _ I18N or settings . use _ L10N :
cache _ key + = &apos; . % s &apos; % getattr ( request , &apos; LANGUAGE _ CODE &apos; , get _ language ( ) )
if settings . use _ TZ :
tz _ name = force _ text ( get _ current _ timezone _ name ( ) , errors = &apos; ignore &apos; )
cache _ key + = &apos; . % s &apos; % tz _ name . encode ( &apos; ascii &apos; , &apos; ignore &apos; ) . decode ( &apos; ascii &apos; ) . replace ( &apos; &apos; , &apos; _ &apos; )
return cache _ key
def _ generate _ cache _ key ( request , method , headerlist , key _ prefix ) :
ctx = hashlib . md5 ( )
for header in headerlist :
value = request . meta . get ( header , None )
if value is not None :
ctx . update ( force _ bytes ( value ) )
url = hashlib . md5 ( force _ bytes ( iri _ to _ uri ( request . build _ absolute _ uri ( ) ) ) )
cache _ key = &apos; views.decorators.cache.cache _ page . % s . % s . % s . % s &apos; % ( key _ prefix , method , url . hexdigest ( ) , ctx . hexdigest ( ) )
return _ i18n _ cache _ key _ suffix ( request , cache _ key )
def _ generate _ cache _ header _ key ( key _ prefix , request ) :
url = hashlib . md5 ( force _ bytes ( iri _ to _ uri ( request . build _ absolute _ uri ( ) ) ) )
cache _ key = &apos; views.decorators.cache.cache _ header . % s . % s &apos; % ( key _ prefix , url . hexdigest ( ) )
return _ i18n _ cache _ key _ suffix ( request , cache _ key )
def get _ cache _ key ( request , key _ prefix = None , method = &apos; GET &apos; , cache = None ) :
if key _ prefix is None :
key _ prefix = settings . cache _ MIDDLEWARE _ KEY _ PREFIX
cache _ key = _ generate _ cache _ header _ key ( key _ prefix , request )
if cache is None :
cache = caches &#91; settings . cache _ MIDDLEWARE _ ALIAS &#93;
headerlist = cache . get ( cache _ key , None )
if headerlist is not None :
return _ generate _ cache _ key ( request , method , headerlist , key _ prefix )
else :
return None
def learn _ cache _ key ( request , response , cache _ timeout = None , key _ prefix = None , cache = None ) :
if key _ prefix is None :
key _ prefix = settings . cache _ MIDDLEWARE _ KEY _ PREFIX
if cache _ timeout is None :
cache _ timeout = settings . cache _ MIDDLEWARE _ SECONDS
cache _ key = _ generate _ cache _ header _ key ( key _ prefix , request )
if cache is None :
cache = caches &#91; settings . cache _ MIDDLEWARE _ ALIAS &#93;
if response . has _ header ( &apos; Vary &apos; ) :
is _ accept _ language _ redundant = settings . use _ I18N or settings . use _ L10N
headerlist = &#91; &#93;
for header in cc _ delim _ re . split ( response &#91; &apos; Vary &apos; &#93; ) :
header = header . upper ( ) . replace ( &apos; -&apos; , &apos; _ &apos; )
if header = = &apos; ACCEPT _ LANGUAGE &apos; and is _ accept _ language _ redundant :
continue
headerlist . append ( &apos; HTTP _ &apos; + header )
headerlist . sort ( )
cache . set ( cache _ key , headerlist , cache _ timeout )
return _ generate _ cache _ key ( request , request . method , headerlist , key _ prefix )
else :
cache . set ( cache _ key , &#91; &#93; , cache _ timeout )
return _ generate _ cache _ key ( request , request . method , &#91; &#93; , key _ prefix )
def _ to _ tuple ( s ) :
t = s . split ( &apos; = &apos; , 1 )
if len ( t ) = = 2 :
return t &#91; 0 &#93; . lower ( ) , t &#91; 1 &#93;
return t &#91; 0 &#93; . lower ( ) , True
_ _ all _ _ = &#91; &apos; luhn &apos; &#93;
from django . utils import six
luhn _ ODD _ LOOKUP = ( 0 , 2 , 4 , 6 , 8 , 1 , 3 , 5 , 7 , 9 )
def luhn ( candidate ) :
if not isinstance ( candidate , six . string _ types ) :
candidate = str ( candidate )
try :
evens = sum ( int ( c ) for c in candidate &#91; - 1 : : - 2 &#93; )
odds = sum ( LUHN _ ODD _ LOOKUP &#91; int ( c ) &#93; for c in candidate &#91; - 2 : : - 2 &#93; )
return ( ( evens + odds ) % 10 = = 0 )
except ValueError :
return False
from _ _ future _ _ import unicode _ literals
import hmac
import struct
import hashlib
import binascii
import time
import random
try :
random = random . SystemRandom ( )
using _ sysrandom = True
except NotImplementedError :
import warnings
warnings . warn ( &apos; A secure pseudo-random number generator is not available &apos; &apos; on your system . Falling back to Mersenne Twister . &apos; )
using _ sysrandom = False
from django . conf import settings
from django . utils . encoding import force _ bytes
from django . utils import six
from django . utils . six . moves import xrange
def salted _ hmac ( key _ salt , value , secret = None ) :
if secret is None :
secret = settings . secret _ KEY
key _ salt = force _ bytes ( key _ salt )
secret = force _ bytes ( secret )
key = hashlib . sha1 ( key _ salt + secret ) . digest ( )
return hmac . new ( key , msg = force _ bytes ( value ) , digestmod = hashlib . sha1 )
def get _ random _ string ( length = 12 , allowed _ chars = &apos; abcdefghijklmnopqrstuvwxyz &apos; &apos; abcdefghijklmnopqrstuvwxyz0123456789 &apos; ) :
if not using _ sysrandom :
random . seed ( hashlib . sha256 ( ( &quot; % s % s % s &quot; % ( random . getstate ( ) , time . time ( ) , settings . secret _ KEY ) ) . encode ( &apos; utf-8 &apos; ) ) . digest ( ) )
return &apos; &apos; . join ( random . choice ( allowed _ chars ) for i in range ( length ) )
if hasattr ( hmac , &quot; compare _ digest &quot; ) :
def constant _ time _ compare ( val1 , val2 ) :
return hmac . compare _ digest ( force _ bytes ( val1 ) , force _ bytes ( val2 ) )
else :
def constant _ time _ compare ( val1 , val2 ) :
if len ( val1 ) ! = len ( val2 ) :
return False
result = 0
if six . PY3 and isinstance ( val1 , bytes ) and isinstance ( val2 , bytes ) :
for x , y in zip ( val1 , val2 ) :
result &#124; = x ^ y
else :
for x , y in zip ( val1 , val2 ) :
result &#124; = ord ( x ) ^ ord ( y )
return result = = 0
def _ bin _ to _ long ( x ) :
return int ( binascii . hexlify ( x ) , 16 )
def _ long _ to _ bin ( x , hex _ format _ string ) :
return binascii . unhexlify ( ( hex _ format _ string % x ) . encode ( &apos; ascii &apos; ) )
if hasattr ( hashlib , &quot; pbkdf2 _ hmac &quot; ) :
def pbkdf2 ( password , salt , iterations , dklen = 0 , digest = None ) :
if digest is None :
digest = hashlib . sha256
if not dklen :
dklen = None
password = force _ bytes ( password )
salt = force _ bytes ( salt )
return hashlib . pbkdf2 _ hmac ( digest ( ) . name , password , salt , iterations , dklen )
else :
def pbkdf2 ( password , salt , iterations , dklen = 0 , digest = None ) :
assert iterations &gt; 0
if not digest :
digest = hashlib . sha256
password = force _ bytes ( password )
salt = force _ bytes ( salt )
hlen = digest ( ) . digest _ size
if not dklen :
dklen = hlen
if dklen &gt; ( 2 * * 32 - 1 ) * hlen :
raise OverflowError ( &apos; dklen too big &apos; )
l = - ( - dklen / / hlen )
r = dklen - ( l - 1 ) * hlen
hex _ format _ string = &quot; % % 0 % ix &quot; % ( hlen * 2 )
inner , outer = digest ( ) , digest ( )
if len ( password ) &gt; inner . block _ size :
password = digest ( password ) . digest ( )
password + = b &apos; \ x00 &apos; * ( inner . block _ size - len ( password ) )
inner . update ( password . translate ( hmac . trans _ 36 ) )
outer . update ( password . translate ( hmac . trans _ 5C ) )
def F ( i ) :
u = salt + struct . pack ( b &apos; &gt; I &apos; , i )
result = 0
for j in xrange ( int ( iterations ) ) :
dig1 , dig2 = inner . copy ( ) , outer . copy ( )
dig1 . update ( u )
dig2 . update ( dig1 . digest ( ) )
u = dig2 . digest ( )
result ^ = _ bin _ to _ long ( u )
return _ long _ to _ bin ( result , hex _ format _ string )
t = &#91; F ( x ) for x in range ( 1 , l ) &#93;
return b &apos; &apos; . join ( T ) + F ( l ) &#91; : r &#93;
import os
import sys
from . import six
buffering = int ( six . PY3 )
if os . name = = &apos; posix &apos; :
def become _ daemon ( our _ home _ dir = &apos; .&apos; , out _ log = &apos; / dev / null &apos; , err _ log = &apos; / dev / null &apos; , umask = 0o022 ) :
try :
if os . fork ( ) &gt; 0 :
sys . exit ( 0 )
except OSError as e :
sys . stderr . write ( &quot; fork # 1 failed : ( % d ) % s \ n &quot; % ( e . errno , e . strerror ) )
sys . exit ( 1 )
os . setsid ( )
os . chdir ( our _ home _ dir )
os . umask ( umask )
try :
if os . fork ( ) &gt; 0 :
os . _ exit ( 0 )
except OSError as e :
sys . stderr . write ( &quot; fork # 2 failed : ( % d ) % s \ n &quot; % ( e . errno , e . strerror ) )
os . _ exit ( 1 )
si = open ( &apos; / dev / null &apos; , &apos; r &apos; )
so = open ( out _ log , &apos; a + &apos; , buffering )
se = open ( err _ log , &apos; a + &apos; , buffering )
os . dup2 ( si . fileno ( ) , sys . stdin . fileno ( ) )
os . dup2 ( so . fileno ( ) , sys . stdout . fileno ( ) )
os . dup2 ( se . fileno ( ) , sys . stderr . fileno ( ) )
sys . stdout , sys . stderr = so , se
else :
def become _ daemon ( our _ home _ dir = &apos; .&apos; , out _ log = None , err _ log = None , umask = 0o022 ) :
os . chdir ( our _ home _ dir )
os . umask ( umask )
sys . stdin . close ( )
sys . stdout . close ( )
sys . stderr . close ( )
if err _ log :
sys . stderr = open ( err _ log , &apos; a &apos; , buffering )
else :
sys . stderr = NullDevice ( )
if out _ log :
sys . stdout = open ( out _ log , &apos; a &apos; , buffering )
else :
sys . stdout = NullDevice ( )
class NullDevice :
def write ( self , s ) :
pass
import copy
import warnings
from collections import OrderedDict
from django . utils import six
from django . utils . deprecation import RemovedInDjango19Warning
class MergeDict ( object ) :
def _ _ init _ _ ( self , * dicts ) :
warnings . warn ( &apos; `MergeDict` is deprecated , use `dict.update ( ) ` &apos; &apos; instead . &apos; , RemovedInDjango19Warning , 2 )
self . dicts = dicts
def _ _ bool _ _ ( self ) :
return any ( self . dicts )
def _ _ nonzero _ _ ( self ) :
return type ( self ) . _ _ bool _ _ ( self )
def _ _ getitem _ _ ( self , key ) :
for dict _ in self . dicts :
try :
return dict _ &#91; key &#93;
except KeyError :
pass
raise KeyError ( key )
def _ _ copy _ _ ( self ) :
return self . _ _ class _ _ ( * self . dicts )
def get ( self , key , default = None ) :
try :
return self &#91; key &#93;
except KeyError :
return default
def getlist ( self , key ) :
for dict _ in self . dicts :
if key in dict _ :
return dict _ . getlist ( key )
return &#91; &#93;
def _ iteritems ( self ) :
seen = set ( )
for dict _ in self . dicts :
for item in six . iteritems ( dict _ ) :
k = item &#91; 0 &#93;
if k in seen :
continue
seen . add ( k )
yield item
def _ iterkeys ( self ) :
for k , v in self . _ iteritems ( ) :
yield k
def _ itervalues ( self ) :
for k , v in self . _ iteritems ( ) :
yield v
if six . PY3 :
items = _ iteritems
keys = _ iterkeys
values = _ itervalues
else :
iteritems = _ iteritems
iterkeys = _ iterkeys
itervalues = _ itervalues
def items ( self ) :
return list ( self . iteritems ( ) )
def keys ( self ) :
return list ( self . iterkeys ( ) )
def values ( self ) :
return list ( self . itervalues ( ) )
def has _ key ( self , key ) :
for dict _ in self . dicts :
if key in dict _ :
return True
return False
_ _ contains _ _ = has _ key
_ _ iter _ _ = _ iterkeys
def copy ( self ) :
return self . _ _ copy _ _ ( )
def _ _ str _ _ ( self ) :
return str ( dict ( self . items ( ) ) )
def _ _ repr _ _ ( self ) :
dictreprs = &apos; , &apos; . join ( repr ( d ) for d in self . dicts )
return &apos; % s ( % s ) &apos; % ( self . _ _ class _ _ . _ _ name _ _ , dictreprs )
class SortedDict ( dict ) :
def _ _ new _ _ ( cls , * args , * * kwargs ) :
instance = super ( SortedDict , cls ) . _ _ new _ _ ( cls , * args , * * kwargs )
instance . keyOrder = &#91; &#93;
return instance
def _ _ init _ _ ( self , data = None ) :
warnings . warn ( &quot; SortedDict is deprecated and will be removed in Django 1.9 . &quot; , RemovedInDjango19Warning , stacklevel = 2 )
if data is None or isinstance ( data , dict ) :
data = data or &#91; &#93;
super ( SortedDict , self ) . _ _ init _ _ ( data )
self . keyOrder = list ( data ) if data else &#91; &#93;
else :
super ( SortedDict , self ) . _ _ init _ _ ( )
super _ set = super ( SortedDict , self ) . _ _ setitem _ _
for key , value in data :
if key not in self :
self . keyOrder . append ( key )
super _ set ( key , value )
def _ _ deepcopy _ _ ( self , memo ) :
return self . _ _ class _ _ ( &#91; ( key , copy . deepcopy ( value , memo ) ) for key , value in self . items ( ) &#93; )
def _ _ copy _ _ ( self ) :
return self . copy ( )
def _ _ setitem _ _ ( self , key , value ) :
if key not in self :
self . keyOrder . append ( key )
super ( SortedDict , self ) . _ _ setitem _ _ ( key , value )
def _ _ delitem _ _ ( self , key ) :
super ( SortedDict , self ) . _ _ delitem _ _ ( key )
self . keyOrder . remove ( key )
def _ _ iter _ _ ( self ) :
return iter ( self . keyOrder )
def _ _ reversed _ _ ( self ) :
return reversed ( self . keyOrder )
def pop ( self , k , * args ) :
result = super ( SortedDict , self ) . pop ( k , * args )
try :
self . keyOrder . remove ( k )
except ValueError :
pass
return result
def popitem ( self ) :
result = super ( SortedDict , self ) . popitem ( )
self . keyOrder . remove ( result &#91; 0 &#93; )
return result
def _ iteritems ( self ) :
for key in self . keyOrder :
yield key , self &#91; key &#93;
def _ iterkeys ( self ) :
for key in self . keyOrder :
yield key
def _ itervalues ( self ) :
for key in self . keyOrder :
yield self &#91; key &#93;
if six . PY3 :
items = _ iteritems
keys = _ iterkeys
values = _ itervalues
else :
iteritems = _ iteritems
iterkeys = _ iterkeys
itervalues = _ itervalues
def items ( self ) :
return &#91; ( k , self &#91; k &#93; ) for k in self . keyOrder &#93;
def keys ( self ) :
return self . keyOrder &#91; : &#93;
def values ( self ) :
return &#91; self &#91; k &#93; for k in self . keyOrder &#93;
def update ( self , dict _ ) :
for k , v in six . iteritems ( dict _ ) :
self &#91; k &#93; = v
def setdefault ( self , key , default ) :
if key not in self :
self . keyOrder . append ( key )
return super ( SortedDict , self ) . setdefault ( key , default )
def copy ( self ) :
return self . _ _ class _ _ ( self )
def _ _ repr _ _ ( self ) :
return &apos; { % s } &apos; % &apos; , &apos; . join ( &apos; % r : % r &apos; % ( k , v ) for k , v in six . iteritems ( self ) )
def clear ( self ) :
super ( SortedDict , self ) . clear ( )
self . keyOrder = &#91; &#93;
class OrderedSet ( object ) :
def _ _ init _ _ ( self , iterable = None ) :
self . dict = OrderedDict ( ( ( x , None ) for x in iterable ) if iterable else &#91; &#93; )
def add ( self , item ) :
self . dict &#91; item &#93; = None
def remove ( self , item ) :
del self . dict &#91; item &#93;
def discard ( self , item ) :
try :
self . remove ( item )
except KeyError :
pass
def _ _ iter _ _ ( self ) :
return iter ( self . dict . keys ( ) )
def _ _ contains _ _ ( self , item ) :
return item in self . dict
def _ _ nonzero _ _ ( self ) :
return bool ( self . dict )
class MultiValueDictKeyError ( KeyError ) :
pass
class MultiValueDict ( dict ) :
def _ _ init _ _ ( self , key _ to _ list _ mapping = ( ) ) :
super ( MultiValueDict , self ) . _ _ init _ _ ( key _ to _ list _ mapping )
def _ _ repr _ _ ( self ) :
return &quot; &lt; % s : % s &gt; &quot; % ( self . _ _ class _ _ . _ _ name _ _ , super ( MultiValueDict , self ) . _ _ repr _ _ ( ) )
def _ _ getitem _ _ ( self , key ) :
try :
list _ = super ( MultiValueDict , self ) . _ _ getitem _ _ ( key )
except KeyError :
raise MultiValueDictKeyError ( repr ( key ) )
try :
return list _ &#91; - 1 &#93;
except IndexError :
return &#91; &#93;
def _ _ setitem _ _ ( self , key , value ) :
super ( MultiValueDict , self ) . _ _ setitem _ _ ( key , &#91; value &#93; )
def _ _ copy _ _ ( self ) :
return self . _ _ class _ _ ( &#91; ( k , v &#91; : &#93; ) for k , v in self . lists ( ) &#93; )
def _ _ deepcopy _ _ ( self , memo = None ) :
if memo is None :
memo = { }
result = self . _ _ class _ _ ( )
memo &#91; id ( self ) &#93; = result
for key , value in dict . items ( self ) :
dict . _ _ setitem _ _ ( result , copy . deepcopy ( key , memo ) , copy . deepcopy ( value , memo ) )
return result
def _ _ getstate _ _ ( self ) :
obj _ dict = self . _ _ dict _ _ . copy ( )
obj _ dict &#91; &apos; _ data &apos; &#93; = dict ( ( k , self . getlist ( k ) ) for k in self )
return obj _ dict
def _ _ setstate _ _ ( self , obj _ dict ) :
data = obj _ dict . pop ( &apos; _ data &apos; , { } )
for k , v in data . items ( ) :
self . setlist ( k , v )
self . _ _ dict _ _ . update ( obj _ dict )
def get ( self , key , default = None ) :
try :
val = self &#91; key &#93;
except KeyError :
return default
if val = = &#91; &#93; :
return default
return val
def getlist ( self , key , default = None ) :
try :
return super ( MultiValueDict , self ) . _ _ getitem _ _ ( key )
except KeyError :
if default is None :
return &#91; &#93;
return default
def setlist ( self , key , list _ ) :
super ( MultiValueDict , self ) . _ _ setitem _ _ ( key , list _ )
def setdefault ( self , key , default = None ) :
if key not in self :
self &#91; key &#93; = default
return self &#91; key &#93;
def setlistdefault ( self , key , default _ list = None ) :
if key not in self :
if default _ list is None :
default _ list = &#91; &#93;
self . setlist ( key , default _ list )
return self . getlist ( key )
def appendlist ( self , key , value ) :
self . setlistdefault ( key ) . append ( value )
def _ iteritems ( self ) :
for key in self :
yield key , self &#91; key &#93;
def _ iterlists ( self ) :
return six . iteritems ( super ( MultiValueDict , self ) )
def _ itervalues ( self ) :
for key in self :
yield self &#91; key &#93;
if six . PY3 :
items = _ iteritems
lists = _ iterlists
values = _ itervalues
else :
iteritems = _ iteritems
iterlists = _ iterlists
itervalues = _ itervalues
def items ( self ) :
return list ( self . iteritems ( ) )
def lists ( self ) :
return list ( self . iterlists ( ) )
def values ( self ) :
return list ( self . itervalues ( ) )
def copy ( self ) :
return copy . copy ( self )
def update ( self , * args , * * kwargs ) :
if len ( args ) &gt; 1 :
raise TypeError ( &quot; update expected at most 1 arguments , got % d &quot; % len ( args ) )
if args :
other _ dict = args &#91; 0 &#93;
if isinstance ( other _ dict , MultiValueDict ) :
for key , value _ list in other _ dict . lists ( ) :
self . setlistdefault ( key ) . extend ( value _ list )
else :
try :
for key , value in other _ dict . items ( ) :
self . setlistdefault ( key ) . append ( value )
except TypeError :
raise ValueError ( &quot; MultiValueDict.update ( ) takes either a MultiValueDict or dictionary &quot; )
for key , value in six . iteritems ( kwargs ) :
self . setlistdefault ( key ) . append ( value )
def dict ( self ) :
return dict ( ( key , self &#91; key &#93; ) for key in self )
class ImmutableList ( tuple ) :
def _ _ new _ _ ( cls , * args , * * kwargs ) :
if &apos; warning &apos; in kwargs :
warning = kwargs &#91; &apos; warning &apos; &#93;
del kwargs &#91; &apos; warning &apos; &#93;
else :
warning = &apos; ImmutableList object is immutable . &apos;
self = tuple . _ _ new _ _ ( cls , * args , * * kwargs )
self . warning = warning
return self
def complain ( self , * wargs , * * kwargs ) :
if isinstance ( self . warning , Exception ) :
raise self . warning
else :
raise AttributeError ( self . warning )
_ _ delitem _ _ = complain
_ _ delslice _ _ = complain
_ _ iadd _ _ = complain
_ _ imul _ _ = complain
_ _ setitem _ _ = complain
_ _ setslice _ _ = complain
append = complain
extend = complain
insert = complain
pop = complain
remove = complain
sort = complain
reverse = complain
class DictWrapper ( dict ) :
def _ _ init _ _ ( self , data , func , prefix ) :
super ( DictWrapper , self ) . _ _ init _ _ ( data )
self . func = func
self . prefix = prefix
def _ _ getitem _ _ ( self , key ) :
if key . startswith ( self . prefix ) :
use _ func = True
key = key &#91; len ( self . prefix ) : &#93;
else :
use _ func = False
value = super ( DictWrapper , self ) . _ _ getitem _ _ ( key )
if use _ func :
return self . func ( value )
return value
from _ _ future _ _ import unicode _ literals
import re
import time
import calendar
import datetime
from django . utils . dates import MONTHS , MONTHS _ 3 , MONTHS _ ALT , MONTHS _ AP , WEEKDAYS , WEEKDAYS _ ABBR
from django . utils . translation import ugettext as _
from django . utils . encoding import force _ text
from django . utils import six
from django . utils . timezone import get _ default _ timezone , is _ aware , is _ naive
re _ formatchars = re . compile ( r &apos; ( ? &lt; ! \ \ ) ( &#91; aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ &#93; ) &apos; )
re _ escaped = re . compile ( r &apos; \ \ ( . ) &apos; )
class Formatter ( object ) :
def format ( self , formatstr ) :
pieces = &#91; &#93;
for i , piece in enumerate ( re _ formatchars . split ( force _ text ( formatstr ) ) ) :
if i % 2 :
pieces . append ( force _ text ( getattr ( self , piece ) ( ) ) )
elif piece :
pieces . append ( re _ escaped . sub ( r &apos; \ 1 &apos; , piece ) )
return &apos; &apos; . join ( pieces )
class TimeFormat ( Formatter ) :
def _ _ init _ _ ( self , obj ) :
self . data = obj
self . timezone = None
if isinstance ( obj , datetime . datetime ) :
if is _ naive ( obj ) :
self . timezone = get _ default _ timezone ( )
else :
self . timezone = obj . tzinfo
def a ( self ) :
if self . data . hour &gt; 11 :
return _ ( &apos; p.m. &apos; )
return _ ( &apos; a.m. &apos; )
def A ( self ) :
if self . data . hour &gt; 11 :
return _ ( &apos; PM &apos; )
return _ ( &apos; AM &apos; )
def B ( self ) :
raise NotImplementedError ( &apos; may be implemented in a future release &apos; )
def e ( self ) :
if not self . timezone :
return &quot; &quot;
try :
if hasattr ( self . data , &apos; tzinfo &apos; ) and self . data . tzinfo :
return self . data . tzinfo . tzname ( self . data ) or &quot; &quot;
except NotImplementedError :
pass
return &quot; &quot;
def f ( self ) :
if self . data . minute = = 0 :
return self . g ( )
return &apos; % s : % s &apos; % ( self . g ( ) , self . i ( ) )
def g ( self ) :
if self . data . hour = = 0 :
return 12
if self . data . hour &gt; 12 :
return self . data . hour - 12
return self . data . hour
def G ( self ) :
return self . data . hour
def h ( self ) :
return &apos; % 02d &apos; % self . g ( )
def H ( self ) :
return &apos; % 02d &apos; % self . g ( )
def i ( self ) :
return &apos; % 02d &apos; % self . data . minute
def O ( self ) :
if not self . timezone :
return &quot; &quot;
seconds = self . Z ( )
sign = &apos; -&apos; if seconds &lt; 0 else &apos; + &apos;
seconds = abs ( seconds )
return &quot; % s % 02d % 02d &quot; % ( sign , seconds / / 3600 , ( seconds / / 60 ) % 60 )
def P ( self ) :
if self . data . minute = = 0 and self . data . hour = = 0 :
return _ ( &apos; midnight &apos; )
if self . data . minute = = 0 and self . data . hour = = 12 :
return _ ( &apos; noon &apos; )
return &apos; % s % s &apos; % ( self . f ( ) , self . a ( ) )
def s ( self ) :
return &apos; % 02d &apos; % self . data . second
def T ( self ) :
if not self . timezone :
return &quot; &quot;
name = self . timezone . tzname ( self . data ) if self . timezone else None
if name is None :
name = self . format ( &apos; O &apos; )
return six . text _ type ( name )
def u ( self ) :
return &apos; % 06d &apos; % self . data . microsecond
def Z ( self ) :
if not self . timezone :
return &quot; &quot;
offset = self . timezone . utcoffset ( self . data )
return offset . days * 86400 + offset . seconds
class DateFormat ( TimeFormat ) :
year _ days = &#91; None , 0 , 31 , 59 , 90 , 120 , 151 , 181 , 212 , 243 , 273 , 304 , 334 &#93;
def b ( self ) :
return MONTHS _ 3 &#91; self . data . month &#93;
def c ( self ) :
return self . data . isoformat ( )
def d ( self ) :
return &apos; % 02d &apos; % self . data . day
def D ( self ) :
return WEEKDAYS _ ABBR &#91; self . data . weekday ( ) &#93;
def E ( self ) :
return MONTHS _ ALT &#91; self . data . month &#93;
def F ( self ) :
return MONTHS &#91; self . data . month &#93;
def I ( self ) :
if self . timezone and self . timezone . dst ( self . data ) :
return &apos; 1&apos;
else :
return &apos; 0&apos;
def j ( self ) :
return self . data . day
def l ( self ) :
return WEEKDAYS &#91; self . data . weekday ( ) &#93;
def L ( self ) :
return calendar . isleap ( self . data . year )
def m ( self ) :
return &apos; % 02d &apos; % self . data . month
def M ( self ) :
return MONTHS _ 3 &#91; self . data . month &#93; . title ( )
def n ( self ) :
return self . data . month
def N ( self ) :
return MONTHS _ AP &#91; self . data . month &#93;
def o ( self ) :
return self . data . isocalendar ( ) &#91; 0 &#93;
def r ( self ) :
return self . format ( &apos; D , j M Y H : i : s O &apos; )
def S ( self ) :
if self . data . day in ( 11 , 12 , 13 ) :
return &apos; th&apos;
last = self . data . day % 10
if last = = 1 :
return &apos; st&apos;
if last = = 2 :
return &apos; nd&apos;
if last = = 3 :
return &apos; rd&apos;
return &apos; th&apos;
def t ( self ) :
return &apos; % 02d &apos; % calendar . monthrange ( self . data . year , self . data . month ) &#91; 1 &#93;
def U ( self ) :
if isinstance ( self . data , datetime . datetime ) and is _ aware ( self . data ) :
return int ( calendar . timegm ( self . data . utctimetuple ( ) ) )
else :
return int ( time . mktime ( self . data . timetuple ( ) ) )
def w ( self ) :
return ( self . data . weekday ( ) + 1 ) % 7
def W ( self ) :
week _ number = None
jan1 _ weekday = self . data . replace ( month = 1 , day = 1 ) . weekday ( ) + 1
weekday = self . data . weekday ( ) + 1
day _ of _ year = self . Z ( )
if day _ of _ year &lt; = ( 8 - jan1 _ weekday ) and jan1 _ weekday &gt; 4 :
if jan1 _ weekday = = 5 or ( jan1 _ weekday = = 6 and calendar . isleap ( self . data . year - 1 ) ) :
week _ number = 53
else :
week _ number = 52
else :
if calendar . isleap ( self . data . year ) :
i = 366
else :
i = 365
if ( i - day _ of _ year ) &lt; ( 4 - weekday ) :
week _ number = 1
else :
j = day _ of _ year + ( 7 - weekday ) + ( jan1 _ weekday - 1 )
week _ number = j / / 7
if jan1 _ weekday &gt; 4 :
week _ number - = 1
return week _ number
def y ( self ) :
return six . text _ type ( self . data . year ) &#91; 2 : &#93;
def Y ( self ) :
return self . data . year
def z ( self ) :
doy = self . year _ days &#91; self . data . month &#93; + self . data . day
if self . l ( ) and self . data . month &gt; 2 :
doy + = 1
return doy
def format ( value , format _ string ) :
df = DateFormat ( value )
return df . format ( format _ string )
def time _ format ( value , format _ string ) :
tf = TimeFormat ( value )
return tf . format ( format _ string )
import datetime
import re
from django . utils import six
from django . utils . timezone import utc , get _ fixed _ timezone
date _ re = re . compile ( r &apos; ( ? p &lt; year &gt; \ d { 4 } ) - ( ? p &lt; month &gt; \ d { 1,2 } ) - ( ? p &lt; day &gt; \ d { 1,2 } ) $ &apos; )
time _ re = re . compile ( r &apos; ( ? p &lt; hour &gt; \ d { 1,2 } ) : ( ? p &lt; minute &gt; \ d { 1,2 } ) &apos; r &apos; ( ? : : ( ? p &lt; second &gt; \ d { 1,2 } ) ( ? : \ . ( ? p &lt; microsecond &gt; \ d { 1,6 } ) \ d { 0,6 } ) ? ) ? &apos; )
datetime _ re = re . compile ( r &apos; ( ? p &lt; year &gt; \ d { 4 } ) - ( ? p &lt; month &gt; \ d { 1,2 } ) - ( ? p &lt; day &gt; \ d { 1,2 } ) &apos; r &apos; &#91; T &#93; ( ? p &lt; hour &gt; \ d { 1,2 } ) : ( ? p &lt; minute &gt; \ d { 1,2 } ) &apos; r &apos; ( ? : : ( ? p &lt; second &gt; \ d { 1,2 } ) ( ? : \ . ( ? p &lt; microsecond &gt; \ d { 1,6 } ) \ d { 0,6 } ) ? ) ? &apos; r &apos; ( ? p &lt; tzinfo &gt; Z &#124; &#91; + - &#93; \ d { 2 } ( ? : : ? \ d { 2 } ) ? ) ? $ &apos; )
def parse _ date ( value ) :
match = date _ re . match ( value )
if match :
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( match . groupdict ( ) ) )
return datetime . date ( * * kw )
def parse _ time ( value ) :
match = time _ re . match ( value )
if match :
kw = match . groupdict ( )
if kw &#91; &apos; microsecond &apos; &#93; :
kw &#91; &apos; microsecond &apos; &#93; = kw &#91; &apos; microsecond &apos; &#93; . ljust ( 6 , &apos; 0&apos; )
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )
return datetime . time ( * * kw )
def parse _ datetime ( value ) :
match = datetime _ re . match ( value )
if match :
kw = match . groupdict ( )
if kw &#91; &apos; microsecond &apos; &#93; :
kw &#91; &apos; microsecond &apos; &#93; = kw &#91; &apos; microsecond &apos; &#93; . ljust ( 6 , &apos; 0&apos; )
tzinfo = kw . pop ( &apos; tzinfo &apos; )
if tzinfo = = &apos; Z &apos; :
tzinfo = utc
elif tzinfo is not None :
offset _ mins = int ( tzinfo &#91; - 2 : &#93; ) if len ( tzinfo ) &gt; 3 else 0
offset = 60 * int ( tzinfo &#91; 1 : 3 &#93; ) + offset _ mins
if tzinfo &#91; 0 &#93; = = &apos; -&apos; :
offset = - offset
tzinfo = get _ fixed _ timezone ( offset )
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )
kw &#91; &apos; tzinfo &apos; &#93; = tzinfo
return datetime . datetime ( * * kw )
from django . utils . translation import ugettext _ lazy as _ , pgettext _ lazy
WEEKDAYS = { 0 : _ ( &apos; Monday &apos; ) , 1 : _ ( &apos; Tuesday &apos; ) , 2 : _ ( &apos; Wednesday &apos; ) , 3 : _ ( &apos; Thursday &apos; ) , 4 : _ ( &apos; Friday &apos; ) , 5 : _ ( &apos; Saturday &apos; ) , 6 : _ ( &apos; Sunday &apos; ) }
WEEKDAYS _ ABBR = { 0 : _ ( &apos; Mon &apos; ) , 1 : _ ( &apos; Tue &apos; ) , 2 : _ ( &apos; Wed &apos; ) , 3 : _ ( &apos; Thu &apos; ) , 4 : _ ( &apos; Fri &apos; ) , 5 : _ ( &apos; Sat &apos; ) , 6 : _ ( &apos; Sun &apos; ) }
WEEKDAYS _ REV = { &apos; monday &apos; : 0 , &apos; tuesday &apos; : 1 , &apos; wednesday &apos; : 2 , &apos; thursday &apos; : 3 , &apos; friday &apos; : 4 , &apos; saturday &apos; : 5 , &apos; sunday &apos; : 6 }
MONTHS = { 1 : _ ( &apos; January &apos; ) , 2 : _ ( &apos; February &apos; ) , 3 : _ ( &apos; March &apos; ) , 4 : _ ( &apos; April &apos; ) , 5 : _ ( &apos; May &apos; ) , 6 : _ ( &apos; June &apos; ) , 7 : _ ( &apos; July &apos; ) , 8 : _ ( &apos; August &apos; ) , 9 : _ ( &apos; September &apos; ) , 10 : _ ( &apos; October &apos; ) , 11 : _ ( &apos; November &apos; ) , 12 : _ ( &apos; December &apos; ) }
MONTHS _ 3 = { 1 : _ ( &apos; jan &apos; ) , 2 : _ ( &apos; feb &apos; ) , 3 : _ ( &apos; mar &apos; ) , 4 : _ ( &apos; apr &apos; ) , 5 : _ ( &apos; may &apos; ) , 6 : _ ( &apos; jun &apos; ) , 7 : _ ( &apos; jul &apos; ) , 8 : _ ( &apos; aug &apos; ) , 9 : _ ( &apos; sep &apos; ) , 10 : _ ( &apos; oct &apos; ) , 11 : _ ( &apos; nov &apos; ) , 12 : _ ( &apos; dec &apos; ) }
MONTHS _ 3 _ REV = { &apos; jan &apos; : 1 , &apos; feb &apos; : 2 , &apos; mar &apos; : 3 , &apos; apr &apos; : 4 , &apos; may &apos; : 5 , &apos; jun &apos; : 6 , &apos; jul &apos; : 7 , &apos; aug &apos; : 8 , &apos; sep &apos; : 9 , &apos; oct &apos; : 10 , &apos; nov &apos; : 11 , &apos; dec &apos; : 12 }
MONTHS _ AP = { 1 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; Jan. &apos; ) , 2 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; Feb. &apos; ) , 3 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; March &apos; ) , 4 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; April &apos; ) , 5 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; May &apos; ) , 6 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; June &apos; ) , 7 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; July &apos; ) , 8 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; Aug. &apos; ) , 9 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; Sept . &apos; ) , 10 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; Oct. &apos; ) , 11 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; Nov. &apos; ) , 12 : pgettext _ lazy ( &apos; abbrev. month &apos; , &apos; Dec. &apos; ) }
MONTHS _ ALT = { 1 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; January &apos; ) , 2 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; February &apos; ) , 3 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; March &apos; ) , 4 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; April &apos; ) , 5 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; May &apos; ) , 6 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; June &apos; ) , 7 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; July &apos; ) , 8 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; August &apos; ) , 9 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; September &apos; ) , 10 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; October &apos; ) , 11 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; November &apos; ) , 12 : pgettext _ lazy ( &apos; alt. month &apos; , &apos; December &apos; ) }
from datetime import date as real _ date , datetime as real _ datetime
import re
import time
class date ( real _ date ) :
def strftime ( self , fmt ) :
return strftime ( self , fmt )
class datetime ( real _ datetime ) :
def strftime ( self , fmt ) :
return strftime ( self , fmt )
@ classmethod
def combine ( cls , date , time ) :
return cls ( date . year , date . month , date . day , time . hour , time . minute , time . second , time . microsecond , time . tzinfo )
def date ( self ) :
return date ( self . year , self . month , self . day )
def new _ date ( d ) :
return date ( d . year , d . month , d . day )
def new _ datetime ( d ) :
kw = &#91; d . year , d . month , d . day &#93;
if isinstance ( d , real _ datetime ) :
kw . extend ( &#91; d . hour , d . minute , d . second , d . microsecond , d . tzinfo &#93; )
return datetime ( * kw )
_ illegal _ formatting = re . compile ( r &quot; ( ( ^ &#124; &#91; ^ % &#93; ) ( % % ) * % &#91; sy &#93; ) &quot; )
def _ findall ( text , substr ) :
sites = &#91; &#93;
i = 0
while 1 :
j = text . find ( substr , i )
if j = = - 1 :
break
sites . append ( j )
i = j + 1
return sites
def strftime ( dt , fmt ) :
if dt . year &gt; = 1900 :
return super ( type ( dt ) , dt ) . strftime ( fmt )
illegal _ formatting = _ illegal _ formatting . search ( fmt )
if illegal _ formatting :
raise TypeError ( &quot; strftime of dates before 1900 does not handle &quot; + illegal _ formatting . Group ( 0 ) )
year = dt . year
delta = 2000 - year
off = 6 * ( delta / / 100 + delta / / 400 )
year = year + off
year = year + ( ( 2000 - year ) / / 28 ) * 28
timetuple = dt . timetuple ( )
s1 = time . strftime ( fmt , ( year , ) + timetuple &#91; 1 : &#93; )
sites1 = _ findall ( s1 , str ( year ) )
s2 = time . strftime ( fmt , ( year + 28 , ) + timetuple &#91; 1 : &#93; )
sites2 = _ findall ( s2 , str ( year + 28 ) )
sites = &#91; &#93;
for site in sites1 :
if site in sites2 :
sites . append ( site )
s = s1
syear = &quot; % 04d &quot; % ( dt . year , )
for site in sites :
s = s &#91; : site &#93; + syear + s &#91; site + 4 : &#93;
return s
def deconstructible ( * args , * * kwargs ) :
path = kwargs . pop ( &apos; path &apos; , None )
def decorator ( klass ) :
def _ _ new _ _ ( cls , * args , * * kwargs ) :
obj = super ( klass , cls ) . _ _ new _ _ ( cls )
obj . _ constructor _ args = ( args , kwargs )
return obj
def deconstruct ( obj ) :
return ( path or &apos; % s . % s &apos; % ( obj . _ _ class _ _ . _ _ module _ _ , obj . _ _ class _ _ . _ _ name _ _ ) , obj . _ constructor _ args &#91; 0 &#93; , obj . _ constructor _ args &#91; 1 &#93; , )
klass . _ _ new _ _ = staticmethod ( _ _ new _ _ )
klass . deconstruct = deconstruct
return klass
if not args :
return decorator
return decorator ( * args , * * kwargs )
from functools import wraps , update _ wrapper , WRAPPER _ ASSIGNMENTS
from django . utils import six
class classonlymethod ( classmethod ) :
def _ _ get _ _ ( self , instance , owner ) :
if instance is not None :
raise AttributeError ( &quot; This method is available only on the view class . &quot; )
return super ( classonlymethod , self ) . _ _ get _ _ ( instance , owner )
def method _ decorator ( decorator ) :
def _ dec ( func ) :
def _ wrapper ( self , * args , * * kwargs ) :
@ decorator
def bound _ func ( * args2 , * * kwargs2 ) :
return func . _ _ get _ _ ( self , type ( self ) ) ( * args2 , * * kwargs2 )
return bound _ func ( * args , * * kwargs )
@ decorator
def dummy ( * args , * * kwargs ) :
pass
update _ wrapper ( _ wrapper , dummy )
update _ wrapper ( _ wrapper , func )
return _ wrapper
update _ wrapper ( _ dec , decorator , assigned = available _ attrs ( decorator ) )
if hasattr ( decorator , &apos; _ _ name _ _ &apos; ) :
_ dec . _ _ name _ _ = &apos; method _ decorator ( % s ) &apos; % decorator . _ _ name _ _
else :
_ dec . _ _ name _ _ = &apos; method _ decorator ( % s ) &apos; % decorator . _ _ class _ _ . _ _ name _ _
return _ dec
def decorator _ from _ middleware _ with _ args ( middleware _ class ) :
return make _ middleware _ decorator ( middleware _ class )
def decorator _ from _ middleware ( middleware _ class ) :
return make _ middleware _ decorator ( middleware _ class ) ( )
def available _ attrs ( fn ) :
if six . PY3 :
return WRAPPER _ ASSIGNMENTS
else :
return tuple ( a for a in WRAPPER _ ASSIGNMENTS if hasattr ( fn , a ) )
def make _ middleware _ decorator ( middleware _ class ) :
def _ make _ decorator ( * m _ args , * * m _ kwargs ) :
middleware = middleware _ class ( * m _ args , * * m _ kwargs )
def _ decorator ( view _ func ) :
@ wraps ( view _ func , assigned = available _ attrs ( view _ func ) )
def _ wrapped _ view ( request , * args , * * kwargs ) :
if hasattr ( middleware , &apos; process _ request &apos; ) :
result = middleware . process _ request ( request )
if result is not None :
return result
if hasattr ( middleware , &apos; process _ view &apos; ) :
result = middleware . process _ view ( request , view _ func , args , kwargs )
if result is not None :
return result
try :
response = view _ func ( request , * args , * * kwargs )
except Exception as e :
if hasattr ( middleware , &apos; process _ exception &apos; ) :
result = middleware . process _ exception ( request , e )
if result is not None :
return result
raise
if hasattr ( response , &apos; render &apos; ) and callable ( response . render ) :
if hasattr ( middleware , &apos; process _ template _ response &apos; ) :
response = middleware . process _ template _ response ( request , response )
if hasattr ( middleware , &apos; process _ response &apos; ) :
callback = lambda response : middleware . process _ response ( request , response )
response . add _ post _ render _ callback ( callback )
else :
if hasattr ( middleware , &apos; process _ response &apos; ) :
return middleware . process _ response ( request , response )
return response
return _ wrapped _ view
return _ decorator
return _ make _ decorator
import inspect
import warnings
class RemovedInDjango20Warning ( PendingDeprecationWarning ) :
pass
class RemovedInDjango19Warning ( DeprecationWarning ) :
pass
RemovedInNextVersionWarning = RemovedInDjango19Warning
class warn _ about _ renamed _ method ( object ) :
def _ _ init _ _ ( self , class _ name , old _ method _ name , new _ method _ name , deprecation _ warning ) :
self . class _ name = class _ name
self . old _ method _ name = old _ method _ name
self . new _ method _ name = new _ method _ name
self . deprecation _ warning = deprecation _ warning
def _ _ call _ _ ( self , f ) :
def wrapped ( * args , * * kwargs ) :
warnings . warn ( &quot; ` % s . % s` is deprecated , use ` % s` instead . &quot; % ( self . class _ name , self . old _ method _ name , self . new _ method _ name ) , self . deprecation _ warning , 2 )
return f ( * args , * * kwargs )
return wrapped
class RenameMethodsBase ( type ) :
renamed _ methods = ( )
def _ _ new _ _ ( cls , name , bases , attrs ) :
new _ class = super ( RenameMethodsBase , cls ) . _ _ new _ _ ( cls , name , bases , attrs )
for base in inspect . getmro ( new _ class ) :
class _ name = base . _ _ name _ _
for renamed _ method in cls . renamed _ methods :
old _ method _ name = renamed _ method &#91; 0 &#93;
old _ method = base . _ _ dict _ _ . get ( old _ method _ name )
new _ method _ name = renamed _ method &#91; 1 &#93;
new _ method = base . _ _ dict _ _ . get ( new _ method _ name )
deprecation _ warning = renamed _ method &#91; 2 &#93;
wrapper = warn _ about _ renamed _ method ( class _ name , * renamed _ method )
if not new _ method and old _ method :
warnings . warn ( &quot; ` % s . % s` method should be renamed ` % s` . &quot; % ( class _ name , old _ method _ name , new _ method _ name ) , deprecation _ warning , 2 )
setattr ( base , new _ method _ name , old _ method )
setattr ( base , old _ method _ name , wrapper ( old _ method ) )
if not old _ method and new _ method :
setattr ( base , old _ method _ name , wrapper ( new _ method ) )
return new _ class
import warnings
from django . utils . deprecation import RemovedInDjango19Warning
warnings . warn ( &quot; django.utils.dictconfig will be removed in Django 1.9 . &quot; , RemovedInDjango19Warning , stacklevel = 2 )
import logging . handlers
import re
import sys
import types
from django . utils import six
identifier = re . compile ( &apos; ^ &#91; a-z _ &#93; &#91; a-z0-9 _ &#93; * $ &apos; , re . i )
def valid _ ident ( s ) :
m = IDENTIFIER . match ( s )
if not m :
raise ValueError ( &apos; Not a valid Python identifier : % r &apos; % s )
return True
try :
from logging import _ checkLevel
except ImportError :
def _ checkLevel ( level ) :
if isinstance ( level , int ) :
rv = level
elif str ( level ) = = level :
if level not in logging . _ levelNames :
raise ValueError ( &apos; Unknown level : % r &apos; % level )
rv = logging . _ levelNames &#91; level &#93;
else :
raise TypeError ( &apos; Level not an integer or a &apos; &apos; valid string : % r &apos; % level )
return rv
class ConvertingDict ( dict ) :
def _ _ getitem _ _ ( self , key ) :
value = dict . _ _ getitem _ _ ( self , key )
result = self . configurator . convert ( value )
if value is not result :
self &#91; key &#93; = result
if type ( result ) in ( ConvertingDict , ConvertingList , ConvertingTuple ) :
result . parent = self
result . key = key
return result
def get ( self , key , default = None ) :
value = dict . get ( self , key , default )
result = self . configurator . convert ( value )
if value is not result :
self &#91; key &#93; = result
if type ( result ) in ( ConvertingDict , ConvertingList , ConvertingTuple ) :
result . parent = self
result . key = key
return result
def pop ( self , key , default = None ) :
value = dict . pop ( self , key , default )
result = self . configurator . convert ( value )
if value is not result :
if type ( result ) in ( ConvertingDict , ConvertingList , ConvertingTuple ) :
result . parent = self
result . key = key
return result
class ConvertingList ( list ) :
def _ _ getitem _ _ ( self , key ) :
value = list . _ _ getitem _ _ ( self , key )
result = self . configurator . convert ( value )
if value is not result :
self &#91; key &#93; = result
if type ( result ) in ( ConvertingDict , ConvertingList , ConvertingTuple ) :
result . parent = self
result . key = key
return result
def pop ( self , idx = - 1 ) :
value = list . pop ( self , idx )
result = self . configurator . convert ( value )
if value is not result :
if type ( result ) in ( ConvertingDict , ConvertingList , ConvertingTuple ) :
result . parent = self
return result
class ConvertingTuple ( tuple ) :
def _ _ getitem _ _ ( self , key ) :
value = tuple . _ _ getitem _ _ ( self , key )
result = self . configurator . convert ( value )
if value is not result :
if type ( result ) in ( ConvertingDict , ConvertingList , ConvertingTuple ) :
result . parent = self
result . key = key
return result
class BaseConfigurator ( object ) :
convert _ PATTERN = re . compile ( r &apos; ^ ( ? p &lt; prefix &gt; &#91; a-z &#93; + ) : / / ( ? p &lt; suffix &gt; . * ) $ &apos; )
word _ PATTERN = re . compile ( r &apos; ^ \ s * ( \ w + ) \ s * &apos; )
dot _ PATTERN = re . compile ( r &apos; ^ \ . \ s * ( \ w + ) \ s * &apos; )
index _ PATTERN = re . compile ( r &apos; ^ \ &#91; \ s * ( \ w + ) \ s * \ &#93; \ s * &apos; )
digit _ PATTERN = re . compile ( r &apos; ^ \ d + $ &apos; )
value _ converters = { &apos; ext &apos; : &apos; ext _ convert &apos; , &apos; cfg &apos; : &apos; cfg _ convert &apos; , }
importer = _ _ import _ _
def _ _ init _ _ ( self , config ) :
self . config = ConvertingDict ( config )
self . config . configurator = self
def resolve ( self , s ) :
name = s . split ( &apos; .&apos; )
used = name . pop ( 0 )
try :
found = self . importer ( used )
for frag in name :
used + = &apos; .&apos; + frag
try :
found = getattr ( found , frag )
except AttributeError :
self . importer ( used )
found = getattr ( found , frag )
return found
except ImportError :
e , tb = sys . exc _ info ( ) &#91; 1 : &#93;
v = ValueError ( &apos; Cannot resolve % r : % s &apos; % ( s , e ) )
v . _ _ cause _ _ , v . _ _ traceback _ _ = e , tb
raise v
def ext _ convert ( self , value ) :
return self . resolve ( value )
def cfg _ convert ( self , value ) :
rest = value
m = self . word _ PATTERN . match ( rest )
if m is None :
raise ValueError ( &quot; Unable to convert % r &quot; % value )
else :
rest = rest &#91; m . end ( ) : &#93;
d = self . config &#91; m . groups ( ) &#91; 0 &#93; &#93;
while rest :
m = self . dot _ PATTERN . match ( rest )
if m :
d = d &#91; m . groups ( ) &#91; 0 &#93; &#93;
else :
m = self . index _ PATTERN . match ( rest )
if m :
idx = m . groups ( ) &#91; 0 &#93;
if not self . digit _ PATTERN . match ( idx ) :
d = d &#91; idx &#93;
else :
try :
n = int ( idx )
d = d &#91; n &#93;
except TypeError :
d = d &#91; idx &#93;
if m :
rest = rest &#91; m . end ( ) : &#93;
else :
raise ValueError ( &apos; Unable to convert &apos; &apos; % r at % r &apos; % ( value , rest ) )
return d
def convert ( self , value ) :
if not isinstance ( value , ConvertingDict ) and isinstance ( value , dict ) :
value = ConvertingDict ( value )
value . configurator = self
elif not isinstance ( value , ConvertingList ) and isinstance ( value , list ) :
value = ConvertingList ( value )
value . configurator = self
elif not isinstance ( value , ConvertingTuple ) and isinstance ( value , tuple ) :
value = ConvertingTuple ( value )
value . configurator = self
elif isinstance ( value , six . string _ types ) :
m = self . convert _ PATTERN . match ( value )
if m :
d = m . groupdict ( )
prefix = d &#91; &apos; prefix &apos; &#93;
converter = self . value _ converters . get ( prefix , None )
if converter :
suffix = d &#91; &apos; suffix &apos; &#93;
converter = getattr ( self , converter )
value = converter ( suffix )
return value
def configure _ custom ( self , config ) :
c = config . pop ( &apos; ( ) &apos; )
if not hasattr ( c , &apos; _ _ call _ _ &apos; ) and hasattr ( types , &apos; ClassType &apos; ) and type ( c ) ! = types . ClassType :
c = self . resolve ( c )
props = config . pop ( &apos; .&apos; , None )
kwargs = dict ( ( k , config &#91; k &#93; ) for k in config if valid _ ident ( k ) )
result = c ( * * kwargs )
if props :
for name , value in props . items ( ) :
setattr ( result , name , value )
return result
def as _ tuple ( self , value ) :
if isinstance ( value , list ) :
value = tuple ( value )
return value
class DictConfigurator ( BaseConfigurator ) :
def configure ( self ) :
config = self . config
if &apos; version &apos; not in config :
raise ValueError ( &quot; dictionary doesn &apos;t specify a version &quot; )
if config &#91; &apos; version &apos; &#93; ! = 1 :
raise ValueError ( &quot; Unsupported version : % s &quot; % config &#91; &apos; version &apos; &#93; )
incremental = config . pop ( &apos; incremental &apos; , False )
empty _ DICT = { }
logging . _ acquireLock ( )
try :
if incremental :
handlers = config . get ( &apos; handlers &apos; , EMPTY _ DICT )
if sys . version _ info &#91; : 2 &#93; = = ( 2 , 7 ) :
for name in handlers :
if name not in logging . _ handlers :
raise ValueError ( &apos; No handler found with &apos; &apos; name % r &apos; % name )
else :
try :
handler = logging . _ handlers &#91; name &#93;
handler _ config = handlers &#91; name &#93;
level = handler _ config . get ( &apos; level &apos; , None )
if level :
handler . setLevel ( _ checkLevel ( level ) )
except StandardError as e :
raise ValueError ( &apos; Unable to configure handler &apos; &apos; % r : % s &apos; % ( name , e ) )
loggers = config . get ( &apos; loggers &apos; , EMPTY _ DICT )
for name in loggers :
try :
self . configure _ logger ( name , loggers &#91; name &#93; , True )
except StandardError as e :
raise ValueError ( &apos; Unable to configure logger &apos; &apos; % r : % s &apos; % ( name , e ) )
root = config . get ( &apos; root &apos; , None )
if root :
try :
self . configure _ root ( root , True )
except StandardError as e :
raise ValueError ( &apos; Unable to configure root &apos; &apos; logger : % s &apos; % e )
else :
disable _ existing = config . pop ( &apos; disable _ existing _ loggers &apos; , True )
logging . _ handlers . clear ( )
del logging . _ handlerList &#91; : &#93;
formatters = config . get ( &apos; formatters &apos; , EMPTY _ DICT )
for name in formatters :
try :
formatters &#91; name &#93; = self . configure _ formatter ( formatters &#91; name &#93; )
except StandardError as e :
raise ValueError ( &apos; Unable to configure &apos; &apos; formatter % r : % s &apos; % ( name , e ) )
filters = config . get ( &apos; filters &apos; , EMPTY _ DICT )
for name in filters :
try :
filters &#91; name &#93; = self . configure _ filter ( filters &#91; name &#93; )
except StandardError as e :
raise ValueError ( &apos; Unable to configure &apos; &apos; filter % r : % s &apos; % ( name , e ) )
handlers = config . get ( &apos; handlers &apos; , EMPTY _ DICT )
for name in sorted ( handlers ) :
try :
handler = self . configure _ handler ( handlers &#91; name &#93; )
handler . name = name
handlers &#91; name &#93; = handler
except StandardError as e :
raise ValueError ( &apos; Unable to configure handler &apos; &apos; % r : % s &apos; % ( name , e ) )
root = logging . root
existing = list ( root . manager . loggerDict )
existing . sort ( )
child _ loggers = &#91; &#93;
loggers = config . get ( &apos; loggers &apos; , EMPTY _ DICT )
for name in loggers :
if name in existing :
i = existing . index ( name )
prefixed = name + &quot; . &quot;
pflen = len ( prefixed )
num _ existing = len ( existing )
i = i + 1
while ( i &lt; num _ existing ) and ( existing &#91; i &#93; &#91; : pflen &#93; = = prefixed ) :
child _ loggers . append ( existing &#91; i &#93; )
i = i + 1
existing . remove ( name )
try :
self . configure _ logger ( name , loggers &#91; name &#93; )
except StandardError as e :
raise ValueError ( &apos; Unable to configure logger &apos; &apos; % r : % s &apos; % ( name , e ) )
for log in existing :
logger = root . manager . loggerDict &#91; log &#93;
if log in child _ loggers :
logger . level = logging . NOTSET
logger . handlers = &#91; &#93;
logger . propagate = True
elif disable _ existing :
logger . disabled = True
root = config . get ( &apos; root &apos; , None )
if root :
try :
self . configure _ root ( root )
except StandardError as e :
raise ValueError ( &apos; Unable to configure root &apos; &apos; logger : % s &apos; % e )
finally :
logging . _ releaseLock ( )
def configure _ formatter ( self , config ) :
if &apos; ( ) &apos; in config :
factory = config &#91; &apos; ( ) &apos; &#93;
try :
result = self . configure _ custom ( config )
except TypeError as te :
if &quot; &apos; format &apos; &quot; not in str ( te ) :
raise
config &#91; &apos; fmt &apos; &#93; = config . pop ( &apos; format &apos; )
config &#91; &apos; ( ) &apos; &#93; = factory
result = self . configure _ custom ( config )
else :
fmt = config . get ( &apos; format &apos; , None )
dfmt = config . get ( &apos; datefmt &apos; , None )
result = logging . formatter ( fmt , dfmt )
return result
def configure _ filter ( self , config ) :
if &apos; ( ) &apos; in config :
result = self . configure _ custom ( config )
else :
name = config . get ( &apos; name &apos; , &apos; &apos; )
result = logging . filter ( name )
return result
def add _ filters ( self , filterer , filters ) :
for f in filters :
try :
filterer . addFilter ( self . config &#91; &apos; filters &apos; &#93; &#91; f &#93; )
except StandardError as e :
raise ValueError ( &apos; Unable to add filter % r : % s &apos; % ( f , e ) )
def configure _ handler ( self , config ) :
formatter = config . pop ( &apos; formatter &apos; , None )
if formatter :
try :
formatter = self . config &#91; &apos; formatters &apos; &#93; &#91; formatter &#93;
except StandardError as e :
raise ValueError ( &apos; Unable to set formatter &apos; &apos; % r : % s &apos; % ( formatter , e ) )
level = config . pop ( &apos; level &apos; , None )
filters = config . pop ( &apos; filters &apos; , None )
if &apos; ( ) &apos; in config :
c = config . pop ( &apos; ( ) &apos; )
if not hasattr ( c , &apos; _ _ call _ _ &apos; ) and hasattr ( types , &apos; ClassType &apos; ) and type ( c ) ! = types . ClassType :
c = self . resolve ( c )
factory = c
else :
klass = self . resolve ( config . pop ( &apos; class &apos; ) )
if issubclass ( klass , logging . handlers . MemoryHandler ) and &apos; target &apos; in config :
try :
config &#91; &apos; target &apos; &#93; = self . config &#91; &apos; handlers &apos; &#93; &#91; config &#91; &apos; target &apos; &#93; &#93;
except StandardError as e :
raise ValueError ( &apos; Unable to set target handler &apos; &apos; % r : % s &apos; % ( config &#91; &apos; target &apos; &#93; , e ) )
elif issubclass ( klass , logging . handlers . SMTPHandler ) and &apos; mailhost &apos; in config :
config &#91; &apos; mailhost &apos; &#93; = self . as _ tuple ( config &#91; &apos; mailhost &apos; &#93; )
elif issubclass ( klass , logging . handlers . SysLogHandler ) and &apos; address &apos; in config :
config &#91; &apos; address &apos; &#93; = self . as _ tuple ( config &#91; &apos; address &apos; &#93; )
factory = klass
kwargs = dict ( ( k , config &#91; k &#93; ) for k in config if valid _ ident ( k ) )
try :
result = factory ( * * kwargs )
except TypeError as te :
if &quot; &apos; stream &apos; &quot; not in str ( te ) :
raise
kwargs &#91; &apos; strm &apos; &#93; = kwargs . pop ( &apos; stream &apos; )
result = factory ( * * kwargs )
if formatter :
result . setFormatter ( formatter )
if level is not None :
result . setLevel ( _ checkLevel ( level ) )
if filters :
self . add _ filters ( result , filters )
return result
def add _ handlers ( self , logger , handlers ) :
for h in handlers :
try :
logger . addHandler ( self . config &#91; &apos; handlers &apos; &#93; &#91; h &#93; )
except StandardError as e :
raise ValueError ( &apos; Unable to add handler % r : % s &apos; % ( h , e ) )
def common _ logger _ config ( self , logger , config , incremental = False ) :
level = config . get ( &apos; level &apos; , None )
if level is not None :
logger . setLevel ( _ checkLevel ( level ) )
if not incremental :
for h in logger . handlers &#91; : &#93; :
logger . removeHandler ( h )
handlers = config . get ( &apos; handlers &apos; , None )
if handlers :
self . add _ handlers ( logger , handlers )
filters = config . get ( &apos; filters &apos; , None )
if filters :
self . add _ filters ( logger , filters )
def configure _ logger ( self , name , config , incremental = False ) :
logger = logging . getLogger ( name )
self . common _ logger _ config ( logger , config , incremental )
propagate = config . get ( &apos; propagate &apos; , None )
if propagate is not None :
logger . propagate = propagate
def configure _ root ( self , config , incremental = False ) :
root = logging . getLogger ( )
self . common _ logger _ config ( root , config , incremental )
dictConfigClass = DictConfigurator
def dictConfig ( config ) :
dictConfigClass ( config ) . configure ( )
from _ _ future _ _ import unicode _ literals
import codecs
import datetime
from decimal import Decimal
import locale
from django . utils . functional import Promise
from django . utils import six
from django . utils . six . moves . urllib . parse import quote
class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
def _ _ init _ _ ( self , obj , * args ) :
self . obj = obj
UnicodeDecodeError . _ _ init _ _ ( self , * args )
def _ _ str _ _ ( self ) :
original = UnicodeDecodeError . _ _ str _ _ ( self )
return &apos; % s . you passed in % r ( % s ) &apos; % ( original , self . obj , type ( self . obj ) )
def python _ 2 _ unicode _ compatible ( klass ) :
if six . PY2 :
if &apos; _ _ str _ _ &apos; not in klass . _ _ dict _ _ :
raise ValueError ( &quot; @ python _ 2 _ unicode _ compatible cannot be applied &quot; &quot; to % s because it doesn &apos;t define _ _ str _ _ ( ) . &quot; % klass . _ _ name _ _ )
klass . _ _ unicode _ _ = klass . _ _ str _ _
klass . _ _ str _ _ = lambda self : self . _ _ unicode _ _ ( ) . encode ( &apos; utf-8 &apos; )
return klass
def smart _ text ( s , encoding = &apos; utf-8 &apos; , strings _ only = False , errors = &apos; strict &apos; ) :
if isinstance ( s , Promise ) :
return s
return force _ text ( s , encoding , strings _ only , errors )
_ PROTECTED _ TYPES = six . integer _ types + ( type ( None ) , float , Decimal , datetime . datetime , datetime . date , datetime . time )
def is _ protected _ type ( obj ) :
return isinstance ( obj , _ PROTECTED _ TYPES )
def force _ text ( s , encoding = &apos; utf-8 &apos; , strings _ only = False , errors = &apos; strict &apos; ) :
if isinstance ( s , six . text _ type ) :
return s
if strings _ only and is _ protected _ type ( s ) :
return s
try :
if not isinstance ( s , six . string _ types ) :
if six . PY3 :
if isinstance ( s , bytes ) :
s = six . text _ type ( s , encoding , errors )
else :
s = six . text _ type ( s )
elif hasattr ( s , &apos; _ _ unicode _ _ &apos; ) :
s = six . text _ type ( s )
else :
s = six . text _ type ( bytes ( s ) , encoding , errors )
else :
s = s . decode ( encoding , errors )
except UnicodeDecodeError as e :
if not isinstance ( s , Exception ) :
raise DjangoUnicodeDecodeError ( s , * e . args )
else :
s = &apos; &apos; . join ( &#91; force _ text ( arg , encoding , strings _ only , errors ) for arg in s &#93; )
return s
def smart _ bytes ( s , encoding = &apos; utf-8 &apos; , strings _ only = False , errors = &apos; strict &apos; ) :
if isinstance ( s , Promise ) :
return s
return force _ bytes ( s , encoding , strings _ only , errors )
def force _ bytes ( s , encoding = &apos; utf-8 &apos; , strings _ only = False , errors = &apos; strict &apos; ) :
if isinstance ( s , bytes ) :
if encoding = = &apos; utf-8 &apos; :
return s
else :
return s . decode ( &apos; utf-8 &apos; , errors ) . encode ( encoding , errors )
if strings _ only and is _ protected _ type ( s ) :
return s
if isinstance ( s , six . memoryview ) :
return bytes ( s )
if isinstance ( s , Promise ) :
return six . text _ type ( s ) . encode ( encoding , errors )
if not isinstance ( s , six . string _ types ) :
try :
if six . PY3 :
return six . text _ type ( s ) . encode ( encoding )
else :
return bytes ( s )
except UnicodeEncodeError :
if isinstance ( s , Exception ) :
return b &apos; &apos; . join ( &#91; force _ bytes ( arg , encoding , strings _ only , errors ) for arg in s &#93; )
return six . text _ type ( s ) . encode ( encoding , errors )
else :
return s . encode ( encoding , errors )
if six . PY3 :
smart _ str = smart _ text
force _ str = force _ text
else :
smart _ str = smart _ bytes
force _ str = force _ bytes
smart _ unicode = smart _ text
force _ unicode = force _ text
def iri _ to _ uri ( iri ) :
if iri is None :
return iri
return quote ( force _ bytes ( iri ) , safe = b &quot; / # % &#91; &#93; = : ; $ &amp; ( ) + , ! ? * @ &apos; ~ &quot; )
def filepath _ to _ uri ( path ) :
if path is None :
return path
return quote ( force _ bytes ( path ) . replace ( b &quot; \ \ &quot; , b &quot; / &quot; ) , safe = b &quot; / ~ ! * ( ) &apos; &quot; )
def get _ system _ encoding ( ) :
try :
encoding = locale . getdefaultlocale ( ) &#91; 1 &#93; or &apos; ascii&apos;
codecs . lookup ( encoding )
except Exception :
encoding = &apos; ascii&apos;
return encoding
default _ LOCALE _ ENCODING = get _ system _ encoding ( )
from _ _ future _ _ import unicode _ literals
import datetime
from django . utils . xmlutils import SimplerXMLGenerator
from django . utils . encoding import force _ text , iri _ to _ uri
from django . utils import datetime _ safe
from django . utils import six
from django . utils . six import StringIO
from django . utils . six . moves . urllib . parse import urlparse
from django . utils . timezone import is _ aware
def rfc2822 _ date ( date ) :
MONTHS = ( &apos; Jan &apos; , &apos; Feb &apos; , &apos; Mar &apos; , &apos; Apr &apos; , &apos; May &apos; , &apos; Jun &apos; , &apos; Jul &apos; , &apos; Aug &apos; , &apos; Sep &apos; , &apos; Oct &apos; , &apos; Nov &apos; , &apos; Dec &apos; , )
days = ( &apos; Mon &apos; , &apos; Tue &apos; , &apos; Wed &apos; , &apos; Thu &apos; , &apos; Fri &apos; , &apos; Sat &apos; , &apos; Sun &apos; )
date = datetime _ safe . new _ datetime ( date )
dow = days &#91; date . weekday ( ) &#93;
month = months &#91; date . month - 1 &#93;
time _ str = date . strftime ( &apos; % s , % % d % s % % Y % % H : % % M : % % S &apos; % ( dow , month ) )
if six . PY2 :
time _ str = time _ str . decode ( &apos; utf-8 &apos; )
if is _ aware ( date ) :
offset = date . tzinfo . utcoffset ( date )
timezone = ( offset . days * 24 * 60 ) + ( offset . seconds / / 60 )
hour , minute = divmod ( timezone , 60 )
return time _ str + &apos; % + 03d % 02d &apos; % ( hour , minute )
else :
return time _ str + &apos; -0000&apos;
def rfc3339 _ date ( date ) :
date = datetime _ safe . new _ datetime ( date )
time _ str = date . strftime ( &apos; % Y- % m- % dT % H : % M : % S &apos; )
if six . PY2 :
time _ str = time _ str . decode ( &apos; utf-8 &apos; )
if is _ aware ( date ) :
offset = date . tzinfo . utcoffset ( date )
timezone = ( offset . days * 24 * 60 ) + ( offset . seconds / / 60 )
hour , minute = divmod ( timezone , 60 )
return time _ str + &apos; % + 03d : % 02d &apos; % ( hour , minute )
else :
return time _ str + &apos; Z&apos;
def get _ tag _ uri ( url , date ) :
bits = urlparse ( url )
d = &apos; &apos;
if date is not None :
d = &apos; , % s &apos; % datetime _ safe . new _ datetime ( date ) . strftime ( &apos; % Y- % m- % d &apos; )
return &apos; tag : % s % s : % s / % s &apos; % ( bits . hostname , d , bits . path , bits . fragment )
class SyndicationFeed ( object ) :
def _ _ init _ _ ( self , title , link , description , language = None , author _ email = None , author _ name = None , author _ link = None , subtitle = None , categories = None , feed _ url = None , feed _ copyright = None , feed _ guid = None , ttl = None , * * kwargs ) :
to _ unicode = lambda s : force _ text ( s , strings _ only = True )
if categories :
categories = &#91; force _ text ( c ) for c in categories &#93;
if ttl is not None :
ttl = force _ text ( ttl )
self . feed = { &apos; title &apos; : to _ unicode ( title ) , &apos; link &apos; : iri _ to _ uri ( link ) , &apos; description &apos; : to _ unicode ( description ) , &apos; language &apos; : to _ unicode ( language ) , &apos; author _ email &apos; : to _ unicode ( author _ email ) , &apos; author _ name &apos; : to _ unicode ( author _ name ) , &apos; author _ link &apos; : iri _ to _ uri ( author _ link ) , &apos; subtitle &apos; : to _ unicode ( subtitle ) , &apos; categories &apos; : categories or ( ) , &apos; feed _ url &apos; : iri _ to _ uri ( feed _ url ) , &apos; feed _ copyright &apos; : to _ unicode ( feed _ copyright ) , &apos; id &apos; : feed _ guid or link , &apos; ttl &apos; : ttl , }
self . feed . update ( kwargs )
self . items = &#91; &#93;
def add _ item ( self , title , link , description , author _ email = None , author _ name = None , author _ link = None , pubdate = None , comments = None , unique _ id = None , unique _ id _ is _ permalink = None , enclosure = None , categories = ( ) , item _ copyright = None , ttl = None , updateddate = None , * * kwargs ) :
to _ unicode = lambda s : force _ text ( s , strings _ only = True )
if categories :
categories = &#91; ( c ) for c in categories &#93;
if ttl is not None :
ttl = force _ text ( ttl )
item = { &apos; title &apos; : to _ unicode ( title ) , &apos; link &apos; : iri _ to _ uri ( link ) , &apos; description &apos; : to _ unicode ( description ) , &apos; author _ email &apos; : to _ unicode ( author _ email ) , &apos; author _ name &apos; : to _ unicode ( author _ name ) , &apos; author _ link &apos; : iri _ to _ uri ( author _ link ) , &apos; pubdate &apos; : pubdate , &apos; updateddate &apos; : updateddate , &apos; comments &apos; : to _ unicode ( comments ) , &apos; unique _ id &apos; : to _ unicode ( unique _ id ) , &apos; unique _ id _ is _ permalink &apos; : unique _ id _ is _ permalink , &apos; enclosure &apos; : enclosure , &apos; categories &apos; : categories or ( ) , &apos; item _ copyright &apos; : to _ unicode ( item _ copyright ) , &apos; ttl &apos; : ttl , }
item . update ( kwargs )
self . items . append ( item )
def num _ items ( self ) :
return len ( self . items )
def root _ attributes ( self ) :
return { }
def add _ root _ elements ( self , handler ) :
pass
def item _ attributes ( self , item ) :
return { }
def add _ item _ elements ( self , handler , item ) :
pass
def write ( self , outfile , encoding ) :
raise NotImplementedError ( &apos; subclasses of SyndicationFeed must provide a write ( ) method &apos; )
def writeString ( self , encoding ) :
s = StringIO ( )
self . write ( s , encoding )
return s . getvalue ( )
def latest _ post _ date ( self ) :
latest _ date = None
date _ keys = ( &apos; updateddate &apos; , &apos; pubdate &apos; )
for item in self . items :
for date _ key in date _ keys :
item _ date = item . get ( date _ key )
if item _ date :
if latest _ date is None or item _ date &gt; latest _ date :
latest _ date = item _ date
return latest _ date or datetime . datetime . now ( )
class Enclosure ( object ) :
def _ _ init _ _ ( self , url , length , mime _ type ) :
self . length , self . mime _ type = length , mime _ type
self . url = iri _ to _ uri ( url )
class RssFeed ( SyndicationFeed ) :
mime _ type = &apos; application / rss + xml ; charset = utf-8&apos;
def write ( self , outfile , encoding ) :
handler = SimplerXMLGenerator ( outfile , encoding )
handler . startDocument ( )
handler . startElement ( &quot; rss &quot; , self . rss _ attributes ( ) )
handler . startElement ( &quot; channel &quot; , self . root _ attributes ( ) )
self . add _ root _ elements ( handler )
self . write _ items ( handler )
self . endChannelElement ( handler )
handler . endElement ( &quot; rss &quot; )
def rss _ attributes ( self ) :
return { &quot; version &quot; : self . _ version , &quot; xmlns : atom &quot; : &quot; http : / / www.w3.org / 2005 / Atom &quot; }
def write _ items ( self , handler ) :
for item in self . items :
handler . startElement ( &apos; item &apos; , self . item _ attributes ( item ) )
self . add _ item _ elements ( handler , item )
handler . endElement ( &quot; item &quot; )
def add _ root _ elements ( self , handler ) :
handler . addQuickElement ( &quot; title &quot; , self . feed &#91; &apos; title &apos; &#93; )
handler . addQuickElement ( &quot; link &quot; , self . feed &#91; &apos; link &apos; &#93; )
handler . addQuickElement ( &quot; description &quot; , self . feed &#91; &apos; description &apos; &#93; )
if self . feed &#91; &apos; feed _ url &apos; &#93; is not None :
handler . addQuickElement ( &quot; atom : link &quot; , None , { &quot; rel &quot; : &quot; self &quot; , &quot; href &quot; : self . feed &#91; &apos; feed _ url &apos; &#93; } )
if self . feed &#91; &apos; language &apos; &#93; is not None :
handler . addQuickElement ( &quot; language &quot; , self . feed &#91; &apos; language &apos; &#93; )
for cat in self . feed &#91; &apos; categories &apos; &#93; :
handler . addQuickElement ( &quot; category &quot; , cat )
if self . feed &#91; &apos; feed _ copyright &apos; &#93; is not None :
handler . addQuickElement ( &quot; copyright &quot; , self . feed &#91; &apos; feed _ copyright &apos; &#93; )
handler . addQuickElement ( &quot; lastBuildDate &quot; , rfc2822 _ date ( self . latest _ post _ date ( ) ) )
if self . feed &#91; &apos; ttl &apos; &#93; is not None :
handler . addQuickElement ( &quot; ttl &quot; , self . feed &#91; &apos; ttl &apos; &#93; )
def endChannelElement ( self , handler ) :
handler . endElement ( &quot; channel &quot; )
class RssUserland091Feed ( RssFeed ) :
_ version = &quot; 0.91 &quot;
def add _ item _ elements ( self , handler , item ) :
handler . addQuickElement ( &quot; title &quot; , item &#91; &apos; title &apos; &#93; )
handler . addQuickElement ( &quot; link &quot; , item &#91; &apos; link &apos; &#93; )
if item &#91; &apos; description &apos; &#93; is not None :
handler . addQuickElement ( &quot; description &quot; , item &#91; &apos; description &apos; &#93; )
class Rss201rev2Feed ( RssFeed ) :
_ version = &quot; 2.0 &quot;
def add _ item _ elements ( self , handler , item ) :
handler . addQuickElement ( &quot; title &quot; , item &#91; &apos; title &apos; &#93; )
handler . addQuickElement ( &quot; link &quot; , item &#91; &apos; link &apos; &#93; )
if item &#91; &apos; description &apos; &#93; is not None :
handler . addQuickElement ( &quot; description &quot; , item &#91; &apos; description &apos; &#93; )
if item &#91; &quot; author _ name &quot; &#93; and item &#91; &quot; author _ email &quot; &#93; :
handler . addQuickElement ( &quot; author &quot; , &quot; % s ( % s ) &quot; % ( item &#91; &apos; author _ email &apos; &#93; , item &#91; &apos; author _ name &apos; &#93; ) )
elif item &#91; &quot; author _ email &quot; &#93; :
handler . addQuickElement ( &quot; author &quot; , item &#91; &quot; author _ email &quot; &#93; )
elif item &#91; &quot; author _ name &quot; &#93; :
handler . addQuickElement ( &quot; dc : creator &quot; , item &#91; &quot; author _ name &quot; &#93; , { &quot; xmlns : dc &quot; : &quot; http : / / purl.org / dc / elements / 1.1 / &quot; } )
if item &#91; &apos; pubdate &apos; &#93; is not None :
handler . addQuickElement ( &quot; pubDate &quot; , rfc2822 _ date ( item &#91; &apos; pubdate &apos; &#93; ) )
if item &#91; &apos; comments &apos; &#93; is not None :
handler . addQuickElement ( &quot; comments &quot; , item &#91; &apos; comments &apos; &#93; )
if item &#91; &apos; unique _ id &apos; &#93; is not None :
guid _ attrs = { }
if isinstance ( item . get ( &apos; unique _ id _ is _ permalink &apos; ) , bool ) :
guid _ attrs &#91; &apos; isPermaLink &apos; &#93; = str ( item &#91; &apos; unique _ id _ is _ permalink &apos; &#93; ) . lower ( )
handler . addQuickElement ( &quot; guid &quot; , item &#91; &apos; unique _ id &apos; &#93; , guid _ attrs )
if item &#91; &apos; ttl &apos; &#93; is not None :
handler . addQuickElement ( &quot; ttl &quot; , item &#91; &apos; ttl &apos; &#93; )
if item &#91; &apos; enclosure &apos; &#93; is not None :
handler . addQuickElement ( &quot; enclosure &quot; , &apos; &apos; , { &quot; url &quot; : item &#91; &apos; enclosure &apos; &#93; . url , &quot; length &quot; : item &#91; &apos; enclosure &apos; &#93; . length , &quot; type &quot; : item &#91; &apos; enclosure &apos; &#93; . mime _ type } )
for cat in item &#91; &apos; categories &apos; &#93; :
handler . addQuickElement ( &quot; category &quot; , cat )
class Atom1Feed ( SyndicationFeed ) :
mime _ type = &apos; application / atom + xml ; charset = utf-8&apos;
ns = &quot; http : / / www.w3.org / 2005 / Atom &quot;
def write ( self , outfile , encoding ) :
handler = SimplerXMLGenerator ( outfile , encoding )
handler . startDocument ( )
handler . startElement ( &apos; feed &apos; , self . root _ attributes ( ) )
self . add _ root _ elements ( handler )
self . write _ items ( handler )
handler . endElement ( &quot; feed &quot; )
def root _ attributes ( self ) :
if self . feed &#91; &apos; language &apos; &#93; is not None :
return { &quot; xmlns &quot; : self . ns , &quot; xml : lang &quot; : self . feed &#91; &apos; language &apos; &#93; }
else :
return { &quot; xmlns &quot; : self . ns }
def add _ root _ elements ( self , handler ) :
handler . addQuickElement ( &quot; title &quot; , self . feed &#91; &apos; title &apos; &#93; )
handler . addQuickElement ( &quot; link &quot; , &quot; &quot; , { &quot; rel &quot; : &quot; alternate &quot; , &quot; href &quot; : self . feed &#91; &apos; link &apos; &#93; } )
if self . feed &#91; &apos; feed _ url &apos; &#93; is not None :
handler . addQuickElement ( &quot; link &quot; , &quot; &quot; , { &quot; rel &quot; : &quot; self &quot; , &quot; href &quot; : self . feed &#91; &apos; feed _ url &apos; &#93; } )
handler . addQuickElement ( &quot; id &quot; , self . feed &#91; &apos; id &apos; &#93; )
handler . addQuickElement ( &quot; updated &quot; , rfc3339 _ date ( self . latest _ post _ date ( ) ) )
if self . feed &#91; &apos; author _ name &apos; &#93; is not None :
handler . startElement ( &quot; author &quot; , { } )
handler . addQuickElement ( &quot; name &quot; , self . feed &#91; &apos; author _ name &apos; &#93; )
if self . feed &#91; &apos; author _ email &apos; &#93; is not None :
handler . addQuickElement ( &quot; email &quot; , self . feed &#91; &apos; author _ email &apos; &#93; )
if self . feed &#91; &apos; author _ link &apos; &#93; is not None :
handler . addQuickElement ( &quot; uri &quot; , self . feed &#91; &apos; author _ link &apos; &#93; )
handler . endElement ( &quot; author &quot; )
if self . feed &#91; &apos; subtitle &apos; &#93; is not None :
handler . addQuickElement ( &quot; subtitle &quot; , self . feed &#91; &apos; subtitle &apos; &#93; )
for cat in self . feed &#91; &apos; categories &apos; &#93; :
handler . addQuickElement ( &quot; category &quot; , &quot; &quot; , { &quot; term &quot; : cat } )
if self . feed &#91; &apos; feed _ copyright &apos; &#93; is not None :
handler . addQuickElement ( &quot; rights &quot; , self . feed &#91; &apos; feed _ copyright &apos; &#93; )
def write _ items ( self , handler ) :
for item in self . items :
handler . startElement ( &quot; entry &quot; , self . item _ attributes ( item ) )
self . add _ item _ elements ( handler , item )
handler . endElement ( &quot; entry &quot; )
def add _ item _ elements ( self , handler , item ) :
handler . addQuickElement ( &quot; title &quot; , item &#91; &apos; title &apos; &#93; )
handler . addQuickElement ( &quot; link &quot; , &quot; &quot; , { &quot; href &quot; : item &#91; &apos; link &apos; &#93; , &quot; rel &quot; : &quot; alternate &quot; } )
if item &#91; &apos; pubdate &apos; &#93; is not None :
handler . addQuickElement ( &apos; published &apos; , rfc3339 _ date ( item &#91; &apos; pubdate &apos; &#93; ) )
if item &#91; &apos; updateddate &apos; &#93; is not None :
handler . addQuickElement ( &apos; updated &apos; , rfc3339 _ date ( item &#91; &apos; updateddate &apos; &#93; ) )
if item &#91; &apos; author _ name &apos; &#93; is not None :
handler . startElement ( &quot; author &quot; , { } )
handler . addQuickElement ( &quot; name &quot; , item &#91; &apos; author _ name &apos; &#93; )
if item &#91; &apos; author _ email &apos; &#93; is not None :
handler . addQuickElement ( &quot; email &quot; , item &#91; &apos; author _ email &apos; &#93; )
if item &#91; &apos; author _ link &apos; &#93; is not None :
handler . addQuickElement ( &quot; uri &quot; , item &#91; &apos; author _ link &apos; &#93; )
handler . endElement ( &quot; author &quot; )
if item &#91; &apos; unique _ id &apos; &#93; is not None :
unique _ id = item &#91; &apos; unique _ id &apos; &#93;
else :
unique _ id = get _ tag _ uri ( item &#91; &apos; link &apos; &#93; , item &#91; &apos; pubdate &apos; &#93; )
handler . addQuickElement ( &quot; id &quot; , unique _ id )
if item &#91; &apos; description &apos; &#93; is not None :
handler . addQuickElement ( &quot; summary &quot; , item &#91; &apos; description &apos; &#93; , { &quot; type &quot; : &quot; html &quot; } )
if item &#91; &apos; enclosure &apos; &#93; is not None :
handler . addQuickElement ( &quot; link &quot; , &apos; &apos; , { &quot; rel &quot; : &quot; enclosure &quot; , &quot; href &quot; : item &#91; &apos; enclosure &apos; &#93; . url , &quot; length &quot; : item &#91; &apos; enclosure &apos; &#93; . length , &quot; type &quot; : item &#91; &apos; enclosure &apos; &#93; . mime _ type } )
for cat in item &#91; &apos; categories &apos; &#93; :
handler . addQuickElement ( &quot; category &quot; , &quot; &quot; , { &quot; term &quot; : cat } )
if item &#91; &apos; item _ copyright &apos; &#93; is not None :
handler . addQuickElement ( &quot; rights &quot; , item &#91; &apos; item _ copyright &apos; &#93; )
DefaultFeed = Rss201rev2Feed
from _ _ future _ _ import absolute _ import
import decimal
import datetime
from importlib import import _ module
import unicodedata
from django . conf import settings
from django . utils import dateformat , numberformat , datetime _ safe
from django . utils . encoding import force _ str
from django . utils . functional import lazy
from django . utils . SafeString import mark _ safe
from django . utils import six
from django . utils . translation import get _ language , to _ locale , check _ for _ language
_ format _ cache = { }
_ format _ modules _ cache = { }
iso _ INPUT _ FORMATS = { &apos; DATE _ INPUT _ FORMATS &apos; : ( &apos; % Y- % m- % d &apos; , ) , &apos; TIME _ INPUT _ FORMATS &apos; : ( &apos; % H : % M : % S &apos; , &apos; % H : % M : % S. % f &apos; , &apos; % H : % M &apos; ) , &apos; DATETIME _ INPUT _ FORMATS &apos; : ( &apos; % Y- % m- % d % H : % M : % S &apos; , &apos; % Y- % m- % d % H : % M : % S. % f &apos; , &apos; % Y- % m- % d % H : % M &apos; , &apos; % Y- % m- % d &apos; ) , }
def reset _ format _ cache ( ) :
global _ format _ cache , _ format _ modules _ cache
_ format _ cache = { }
_ format _ modules _ cache = { }
def iter _ format _ modules ( lang , format _ module _ path = None ) :
if not check _ for _ language ( lang ) :
return
if format _ module _ path is None :
format _ module _ path = settings . format _ MODULE _ PATH
format _ locations = &#91; &#93;
if format _ module _ path :
if isinstance ( format _ module _ path , six . string _ types ) :
format _ module _ path = &#91; format _ module _ path &#93;
for path in format _ module _ path :
format _ locations . append ( path + &apos; . % s &apos; )
format _ locations . append ( &apos; django.conf.locale. % s &apos; )
locale = to _ locale ( lang )
locales = &#91; locale &#93;
if &apos; _ &apos; in locale :
locales . append ( locale . split ( &apos; _ &apos; ) &#91; 0 &#93; )
for location in format _ locations :
for loc in locales :
try :
yield import _ module ( &apos; % s.formats &apos; % ( location % loc ) )
except ImportError :
pass
def get _ format _ modules ( lang = None , reverse = False ) :
if lang is None :
lang = get _ language ( )
modules = _ format _ modules _ cache . setdefault ( lang , list ( iter _ format _ modules ( lang , settings . format _ MODULE _ PATH ) ) )
if reverse :
return list ( reversed ( modules ) )
return modules
def get _ format ( format _ type , lang = None , use _ l10n = None ) :
format _ type = force _ str ( format _ type )
if use _ l10n or ( use _ l10n is None and settings . use _ L10N ) :
if lang is None :
lang = get _ language ( )
cache _ key = ( format _ type , lang )
try :
cached = _ format _ cache &#91; cache _ key &#93;
if cached is not None :
return cached
else :
return getattr ( settings , format _ type )
except KeyError :
for module in get _ format _ modules ( lang ) :
try :
val = getattr ( module , format _ type )
for iso _ input in ISO _ INPUT _ FORMATS . get ( format _ type , ( ) ) :
if iso _ input not in val :
if isinstance ( val , tuple ) :
val = list ( val )
val . append ( iso _ input )
_ format _ cache &#91; cache _ key &#93; = val
return val
except AttributeError :
pass
_ format _ cache &#91; cache _ key &#93; = None
return getattr ( settings , format _ type )
get _ format _ lazy = lazy ( get _ format , six . text _ type , list , tuple )
def date _ format ( value , format = None , use _ l10n = None ) :
return dateformat . format ( value , get _ format ( format or &apos; DATE _ FORMAT &apos; , use _ l10n = use _ l10n ) )
def time _ format ( value , format = None , use _ l10n = None ) :
return dateformat . time _ format ( value , get _ format ( format or &apos; TIME _ FORMAT &apos; , use _ l10n = use _ l10n ) )
def number _ format ( value , decimal _ pos = None , use _ l10n = None , force _ grouping = False ) :
if use _ l10n or ( use _ l10n is None and settings . use _ L10N ) :
lang = get _ language ( )
else :
lang = None
return numberformat . format ( value , get _ format ( &apos; DECIMAL _ SEPARATOR &apos; , lang , use _ l10n = use _ l10n ) , decimal _ pos , get _ format ( &apos; NUMBER _ GROUPING &apos; , lang , use _ l10n = use _ l10n ) , get _ format ( &apos; THOUSAND _ SEPARATOR &apos; , lang , use _ l10n = use _ l10n ) , force _ grouping = force _ grouping )
def localize ( value , use _ l10n = None ) :
if isinstance ( value , bool ) :
return mark _ safe ( six . text _ type ( value ) )
elif isinstance ( value , ( decimal . decimal , float ) + six . integer _ types ) :
return number _ format ( value , use _ l10n = use _ l10n )
elif isinstance ( value , datetime . datetime ) :
return date _ format ( value , &apos; DATETIME _ FORMAT &apos; , use _ l10n = use _ l10n )
elif isinstance ( value , datetime . date ) :
return date _ format ( value , use _ l10n = use _ l10n )
elif isinstance ( value , datetime . time ) :
return time _ format ( value , &apos; TIME _ FORMAT &apos; , use _ l10n = use _ l10n )
else :
return value
def localize _ input ( value , default = None ) :
if isinstance ( value , ( decimal . decimal , float ) + six . integer _ types ) :
return number _ format ( value )
elif isinstance ( value , datetime . datetime ) :
value = datetime _ safe . new _ datetime ( value )
format = force _ str ( default or get _ format ( &apos; DATETIME _ INPUT _ FORMATS &apos; ) &#91; 0 &#93; )
return value . strftime ( format )
elif isinstance ( value , datetime . date ) :
value = datetime _ safe . new _ date ( value )
format = force _ str ( default or get _ format ( &apos; DATE _ INPUT _ FORMATS &apos; ) &#91; 0 &#93; )
return value . strftime ( format )
elif isinstance ( value , datetime . time ) :
format = force _ str ( default or get _ format ( &apos; TIME _ INPUT _ FORMATS &apos; ) &#91; 0 &#93; )
return value . strftime ( format )
return value
def sanitize _ separators ( value ) :
if settings . use _ L10N and isinstance ( value , six . string _ types ) :
parts = &#91; &#93;
decimal _ separator = get _ format ( &apos; DECIMAL _ SEPARATOR &apos; )
if decimal _ separator in value :
value , decimals = value . split ( decimal _ separator , 1 )
parts . append ( decimals )
if settings . use _ THOUSAND _ SEPARATOR :
thousand _ sep = get _ format ( &apos; THOUSAND _ SEPARATOR &apos; )
for replacement in set ( &#91; thousand _ sep , unicodedata . normalize ( &apos; NFKD &apos; , thousand _ sep ) &#93; ) :
value = value . replace ( replacement , &apos; &apos; )
parts . append ( value )
value = &apos; .&apos; . join ( reversed ( parts ) )
return value
import copy
import operator
from functools import wraps
import sys
import warnings
from django . utils import six
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . six . moves import copyreg
def curry ( _ curried _ func , * args , * * kwargs ) :
def _ curried ( * moreargs , * * morekwargs ) :
return _ curried _ func ( * ( args + moreargs ) , * * dict ( kwargs , * * morekwargs ) )
return _ curried
def memoize ( func , cache , num _ args ) :
warnings . warn ( &quot; memoize wrapper is deprecated and will be removed in &quot; &quot; Django 1.9 . use django.utils.lru _ cache instead . &quot; , RemovedInDjango19Warning , stacklevel = 2 )
@ wraps ( func )
def wrapper ( * args ) :
mem _ args = args &#91; : num _ args &#93;
if mem _ args in cache :
return cache &#91; mem _ args &#93;
result = func ( * args )
cache &#91; mem _ args &#93; = result
return result
return wrapper
class cached _ property ( object ) :
def _ _ init _ _ ( self , func , name = None ) :
self . func = func
self . name = name or func . _ _ name _ _
def _ _ get _ _ ( self , instance , type = None ) :
if instance is None :
return self
res = instance . _ _ dict _ _ &#91; self . name &#93; = self . func ( instance )
return res
class Promise ( object ) :
pass
def lazy ( func , * resultclasses ) :
@ total _ ordering
class _ _ proxy _ _ ( Promise ) :
_ _ dispatch = None
def _ _ init _ _ ( self , args , kw ) :
self . _ _ args = args
self . _ _ kw = kw
if self . _ _ dispatch is None :
self . _ _ prepare _ class _ _ ( )
def _ _ reduce _ _ ( self ) :
return ( _ lazy _ proxy _ unpickle , ( func , self . _ _ args , self . _ _ kw ) + resultclasses )
@ classmethod
def _ _ prepare _ class _ _ ( cls ) :
cls . _ _ dispatch = { }
for resultclass in resultclasses :
cls . _ _ dispatch &#91; resultclass &#93; = { }
for type _ in reversed ( resultclass . mro ( ) ) :
for ( k , v ) in type _ . _ _ dict _ _ . items ( ) :
meth = cls . _ _ promise _ _ ( resultclass , k , v )
if hasattr ( cls , k ) :
continue
setattr ( cls , k , meth )
cls . _ delegate _ bytes = bytes in resultclasses
cls . _ delegate _ text = six . text _ type in resultclasses
assert not ( cls . _ delegate _ bytes and cls . _ delegate _ text ) , &quot; Cannot call lazy ( ) with both bytes and text return types . &quot;
if cls . _ delegate _ text :
if six . PY3 :
cls . _ _ str _ _ = cls . _ _ text _ cast
else :
cls . _ _ unicode _ _ = cls . _ _ text _ cast
elif cls . _ delegate _ bytes :
if six . PY3 :
cls . _ _ bytes _ _ = cls . _ _ bytes _ cast
else :
cls . _ _ str _ _ = cls . _ _ bytes _ cast
@ classmethod
def _ _ promise _ _ ( cls , klass , funcname , method ) :
def _ _ wrapper _ _ ( self , * args , * * kw ) :
res = func ( * self . _ _ args , * * self . _ _ kw )
for t in type ( res ) . mro ( ) :
if t in self . _ _ dispatch :
return self . _ _ dispatch &#91; t &#93; &#91; funcname &#93; ( res , * args , * * kw )
raise TypeError ( &quot; Lazy object returned unexpected type . &quot; )
if klass not in cls . _ _ dispatch :
cls . _ _ dispatch &#91; klass &#93; = { }
cls . _ _ dispatch &#91; klass &#93; &#91; funcname &#93; = method
return _ _ wrapper _ _
def _ _ text _ cast ( self ) :
return func ( * self . _ _ args , * * self . _ _ kw )
def _ _ bytes _ cast ( self ) :
return bytes ( func ( * self . _ _ args , * * self . _ _ kw ) )
def _ _ cast ( self ) :
if self . _ delegate _ bytes :
return self . _ _ bytes _ cast ( )
elif self . _ delegate _ text :
return self . _ _ text _ cast ( )
else :
return func ( * self . _ _ args , * * self . _ _ kw )
def _ _ ne _ _ ( self , other ) :
if isinstance ( other , Promise ) :
other = other . _ _ cast ( )
return self . _ _ cast ( ) ! = other
def _ _ eq _ _ ( self , other ) :
if isinstance ( other , Promise ) :
other = other . _ _ cast ( )
return self . _ _ cast ( ) = = other
def _ _ lt _ _ ( self , other ) :
if isinstance ( other , Promise ) :
other = other . _ _ cast ( )
return self . _ _ cast ( ) &lt; other
def _ _ hash _ _ ( self ) :
return hash ( self . _ _ cast ( ) )
def _ _ mod _ _ ( self , rhs ) :
if self . _ delegate _ bytes and six . PY2 :
return bytes ( self ) % rhs
elif self . _ delegate _ text :
return six . text _ type ( self ) % rhs
return self . _ _ cast ( ) % rhs
def _ _ deepcopy _ _ ( self , memo ) :
memo &#91; id ( self ) &#93; = self
return self
@ wraps ( func )
def _ _ wrapper _ _ ( * args , * * kw ) :
return _ _ proxy _ _ ( args , kw )
return _ _ wrapper _ _
def _ lazy _ proxy _ unpickle ( func , args , kwargs , * resultclasses ) :
return lazy ( func , * resultclasses ) ( * args , * * kwargs )
def allow _ lazy ( func , * resultclasses ) :
@ wraps ( func )
def wrapper ( * args , * * kwargs ) :
for arg in list ( args ) + list ( six . itervalues ( kwargs ) ) :
if isinstance ( arg , Promise ) :
break
else :
return func ( * args , * * kwargs )
return lazy ( func , * resultclasses ) ( * args , * * kwargs )
return wrapper
empty = object ( )
def new _ method _ proxy ( func ) :
def inner ( self , * args ) :
if self . _ wrapped is empty :
self . _ setup ( )
return func ( self . _ wrapped , * args )
return inner
class LazyObject ( object ) :
_ wrapped = None
def _ _ init _ _ ( self ) :
self . _ wrapped = empty
_ _ getattr _ _ = new _ method _ proxy ( getattr )
def _ _ setattr _ _ ( self , name , value ) :
if name = = &quot; _ wrapped &quot; :
self . _ _ dict _ _ &#91; &quot; _ wrapped &quot; &#93; = value
else :
if self . _ wrapped is empty :
self . _ setup ( )
setattr ( self . _ wrapped , name , value )
def _ _ delattr _ _ ( self , name ) :
if name = = &quot; _ wrapped &quot; :
raise TypeError ( &quot; can &apos;t delete _ wrapped . &quot; )
if self . _ wrapped is empty :
self . _ setup ( )
delattr ( self . _ wrapped , name )
def _ setup ( self ) :
raise NotImplementedError ( &apos; subclasses of LazyObject must provide a _ setup ( ) method &apos; )
def _ _ getstate _ _ ( self ) :
if self . _ wrapped is empty :
self . _ setup ( )
return self . _ wrapped . _ _ dict _ _
@ classmethod
def _ _ newobj _ _ ( cls , * args ) :
return cls . _ _ new _ _ ( cls , * args )
def _ _ reduce _ ex _ _ ( self , proto ) :
if proto &gt; = 2 :
return ( self . _ _ newobj _ _ , ( self . _ _ class _ _ , ) , self . _ _ getstate _ _ ( ) )
else :
return ( copyreg . _ reconstructor , ( self . _ _ class _ _ , object , None ) , self . _ _ getstate _ _ ( ) )
def _ _ deepcopy _ _ ( self , memo ) :
if self . _ wrapped is empty :
result = type ( self ) ( )
memo &#91; id ( self ) &#93; = result
return result
return copy . deepcopy ( self . _ wrapped , memo )
if six . PY3 :
_ _ bytes _ _ = new _ method _ proxy ( bytes )
_ _ str _ _ = new _ method _ proxy ( str )
_ _ bool _ _ = new _ method _ proxy ( bool )
else :
_ _ str _ _ = new _ method _ proxy ( str )
_ _ unicode _ _ = new _ method _ proxy ( unicode )
_ _ nonzero _ _ = new _ method _ proxy ( bool )
_ _ dir _ _ = new _ method _ proxy ( dir )
_ _ class _ _ = property ( new _ method _ proxy ( operator . attrgetter ( &quot; _ _ class _ _ &quot; ) ) )
_ _ eq _ _ = new _ method _ proxy ( operator . eq )
_ _ ne _ _ = new _ method _ proxy ( operator . ne )
_ _ hash _ _ = new _ method _ proxy ( hash )
_ _ getitem _ _ = new _ method _ proxy ( operator . getitem )
_ _ setitem _ _ = new _ method _ proxy ( operator . setitem )
_ _ delitem _ _ = new _ method _ proxy ( operator . delitem )
_ _ len _ _ = new _ method _ proxy ( len )
_ _ contains _ _ = new _ method _ proxy ( operator . contains )
_ super = super
class SimpleLazyObject ( LazyObject ) :
def _ _ init _ _ ( self , func ) :
self . _ _ dict _ _ &#91; &apos; _ setupfunc &apos; &#93; = func
_ super ( SimpleLazyObject , self ) . _ _ init _ _ ( )
def _ setup ( self ) :
self . _ wrapped = self . _ setupfunc ( )
def _ _ repr _ _ ( self ) :
if self . _ wrapped is empty :
repr _ attr = self . _ setupfunc
else :
repr _ attr = self . _ wrapped
return &apos; &lt; % s : % r &gt; &apos; % ( type ( self ) . _ _ name _ _ , repr _ attr )
def _ _ deepcopy _ _ ( self , memo ) :
if self . _ wrapped is empty :
result = SimpleLazyObject ( self . _ setupfunc )
memo &#91; id ( self ) &#93; = result
return result
return copy . deepcopy ( self . _ wrapped , memo )
class lazy _ property ( property ) :
def _ _ new _ _ ( cls , fget = None , fset = None , fdel = None , doc = None ) :
if fget is not None :
@ wraps ( fget )
def fget ( instance , instance _ type = None , name = fget . _ _ name _ _ ) :
return getattr ( instance , name ) ( )
if fset is not None :
@ wraps ( fset )
def fset ( instance , value , name = fset . _ _ name _ _ ) :
return getattr ( instance , name ) ( value )
if fdel is not None :
@ wraps ( fdel )
def fdel ( instance , name = fdel . _ _ name _ _ ) :
return getattr ( instance , name ) ( )
return property ( fget , fset , fdel , doc )
def partition ( predicate , values ) :
results = ( &#91; &#93; , &#91; &#93; )
for item in values :
results &#91; predicate ( item ) &#93; . append ( item )
return results
if sys . version _ info &gt; = ( 2 , 7 , 2 ) :
from functools import total _ ordering
else :
def total _ ordering ( cls ) :
convert = { &apos; _ _ lt _ _ &apos; : &#91; ( &apos; _ _ gt _ _ &apos; , lambda self , other : not ( self &lt; other or self = = other ) ) , ( &apos; _ _ le _ _ &apos; , lambda self , other : self &lt; other or self = = other ) , ( &apos; _ _ ge _ _ &apos; , lambda self , other : not self &lt; other ) &#93; , &apos; _ _ le _ _ &apos; : &#91; ( &apos; _ _ ge _ _ &apos; , lambda self , other : not self &lt; = other or self = = other ) , ( &apos; _ _ lt _ _ &apos; , lambda self , other : self &lt; = other and not self = = other ) , ( &apos; _ _ gt _ _ &apos; , lambda self , other : not self &lt; = other ) &#93; , &apos; _ _ gt _ _ &apos; : &#91; ( &apos; _ _ lt _ _ &apos; , lambda self , other : not ( self &gt; other or self = = other ) ) , ( &apos; _ _ ge _ _ &apos; , lambda self , other : self &gt; other or self = = other ) , ( &apos; _ _ le _ _ &apos; , lambda self , other : not self &gt; other ) &#93; , &apos; _ _ ge _ _ &apos; : &#91; ( &apos; _ _ le _ _ &apos; , lambda self , other : ( not self &gt; = other ) or self = = other ) , ( &apos; _ _ gt _ _ &apos; , lambda self , other : self &gt; = other and not self = = other ) , ( &apos; _ _ lt _ _ &apos; , lambda self , other : not self &gt; = other ) &#93; }
roots = set ( dir ( cls ) ) &amp; set ( convert )
if not roots :
raise ValueError ( &apos; must define at least one ordering operation : &lt; &gt; &lt; = &gt; = &apos; )
root = max ( roots )
for opname , opfunc in convert &#91; root &#93; :
if opname not in roots :
opfunc . _ _ name _ _ = opname
opfunc . _ _ doc _ _ = getattr ( int , opname ) . _ _ doc _ _
setattr ( cls , opname , opfunc )
return cls
from _ _ future _ _ import unicode _ literals
import re
import sys
from django . utils . encoding import force _ text , force _ str
from django . utils . functional import allow _ lazy
from django . utils . SafeString import SafeData , mark _ safe
from django . utils import six
from django . utils . six . moves . urllib . parse import quote , unquote , urlsplit , urlunsplit
from django . utils . text import normalize _ newlines
from . html _ parser import HTMLParser , HTMLParseError
trailing _ PUNCTUATION = &#91; &apos; .&apos; , &apos; , &apos; , &apos; : &apos; , &apos; ; &apos; , &apos; . ) &apos; , &apos; &quot; &apos; , &apos; \ &apos; &apos; &#93;
wrapping _ PUNCTUATION = &#91; ( &apos; ( &apos; , &apos; ) &apos; ) , ( &apos; &lt; &apos; , &apos; &gt; &apos; ) , ( &apos; &#91; &apos; , &apos; &#93; &apos; ) , ( &apos; &amp; lt ; &apos; , &apos; &amp; gt ; &apos; ) , ( &apos; &quot; &apos; , &apos; &quot; &apos; ) , ( &apos; \ &apos; &apos; , &apos; \ &apos; &apos; ) &#93;
DOTS = &#91; &apos; &amp; middot ; &apos; , &apos; * &apos; , &apos; \ u2022 &apos; , &apos; &amp; # 149 ; &apos; , &apos; &amp; bull ; &apos; , &apos; &amp; # 8226 ; &apos; &#93;
unencoded _ ampersands _ re = re . compile ( r &apos; &amp; ( ? ! ( \ w + &#124; # \ d + ) ; ) &apos; )
word _ split _ re = re . compile ( r &apos; ( \ s + ) &apos; )
simple _ url _ re = re . compile ( r &apos; ^ https ? : / / \ &#91; ? \ w &apos; , re . IGNORECASE )
simple _ url _ 2 _ re = re . compile ( r &apos; ^ www \ . &#124; ^ ( ? ! http ) \ w &#91; ^ @ &#93; + \ . ( com &#124; edu &#124; gov &#124; int &#124; mil &#124; net &#124; org ) ( $ &#124; / . * ) $ &apos; , re . IGNORECASE )
simple _ email _ re = re . compile ( r &apos; ^ \ S + @ \ S + \ . \ S + $ &apos; )
link _ target _ attribute _ re = re . compile ( r &apos; ( &lt; a &#91; ^ &gt; &#93; * ? ) target = &#91; ^ \ s &gt; &#93; + &apos; )
html _ gunk _ re = re . compile ( r &apos; ( ? : &lt; br clear = &quot; all &quot; &gt; &#124; &lt; i &gt; &lt; \ / i &gt; &#124; &lt; b &gt; &lt; \ / b &gt; &#124; &lt; em &gt; &lt; \ / em &gt; &#124; &lt; strong &gt; &lt; \ / strong &gt; &#124; &lt; \ / ? smallcaps &gt; &#124; &lt; \ / ? uppercase &gt; ) &apos; , re . IGNORECASE )
hard _ coded _ bullets _ re = re . compile ( r &apos; ( ( ? : &lt; p &gt; ( ? : % s ) . * ? &#91; a-zA-Z &#93; . * ? &lt; / p &gt; \ s * ) + ) &apos; % &apos; &#124; &apos; . join ( re . escape ( x ) for x in DOTS ) , re . DOTALL )
trailing _ empty _ content _ re = re . compile ( r &apos; ( ? : &lt; p &gt; ( ? : &amp; nbsp ; &#124; \ s &#124; &lt; br \ / &gt; ) * ? &lt; / p &gt; \ s * ) + \ Z &apos; )
def escape ( text ) :
return mark _ safe ( force _ text ( text ) . replace ( &apos; &amp; &apos; , &apos; &amp; amp ; &apos; ) . replace ( &apos; &lt; &apos; , &apos; &amp; lt ; &apos; ) . replace ( &apos; &gt; &apos; , &apos; &amp; gt ; &apos; ) . replace ( &apos; &quot; &apos; , &apos; &amp; quot ; &apos; ) . replace ( &quot; &apos; &quot; , &apos; &amp; # 39 ; &apos; ) )
escape = allow _ lazy ( escape , six . text _ type )
_ js _ escapes = { ord ( &apos; \ \ &apos; ) : &apos; \ \ u005C &apos; , ord ( &apos; \ &apos; &apos; ) : &apos; \ \ u0027 &apos; , ord ( &apos; &quot; &apos; ) : &apos; \ \ u0022 &apos; , ord ( &apos; &gt; &apos; ) : &apos; \ \ u003E &apos; , ord ( &apos; &lt; &apos; ) : &apos; \ \ u003C &apos; , ord ( &apos; &amp; &apos; ) : &apos; \ \ u0026 &apos; , ord ( &apos; = &apos; ) : &apos; \ \ u003D &apos; , ord ( &apos; -&apos; ) : &apos; \ \ u002D &apos; , ord ( &apos; ; &apos; ) : &apos; \ \ u003B &apos; , ord ( &apos; \ u2028 &apos; ) : &apos; \ \ u2028 &apos; , ord ( &apos; \ u2029 &apos; ) : &apos; \ \ u2029 &apos; }
_ js _ escapes . update ( ( ord ( &apos; % c &apos; % z ) , &apos; \ \ u % 04X &apos; % z ) for z in range ( 32 ) )
def escapejs ( value ) :
return mark _ safe ( force _ text ( value ) . translate ( _ js _ escapes ) )
escapejs = allow _ lazy ( escapejs , six . text _ type )
def conditional _ escape ( text ) :
if hasattr ( text , &apos; _ _ html _ _ &apos; ) :
return text . _ _ html _ _ ( )
else :
return escape ( text )
def format _ html ( format _ string , * args , * * kwargs ) :
args _ safe = map ( conditional _ escape , args )
kwargs _ safe = dict ( ( k , conditional _ escape ( v ) ) for ( k , v ) in six . iteritems ( kwargs ) )
return mark _ safe ( format _ string . format ( * args _ safe , * * kwargs _ safe ) )
def format _ html _ join ( sep , format _ string , args _ generator ) :
return mark _ safe ( conditional _ escape ( sep ) . join ( format _ html ( format _ string , * tuple ( args ) ) for args in args _ generator ) )
def linebreaks ( value , autoescape = False ) :
value = normalize _ newlines ( value )
paras = re . split ( &apos; \ n { 2 , } &apos; , value )
if autoescape :
paras = &#91; &apos; &lt; p &gt; % s &lt; / p &gt; &apos; % escape ( p ) . replace ( &apos; \ n &apos; , &apos; &lt; br / &gt; &apos; ) for p in paras &#93;
else :
paras = &#91; &apos; &lt; p &gt; % s &lt; / p &gt; &apos; % p . replace ( &apos; \ n &apos; , &apos; &lt; br / &gt; &apos; ) for p in paras &#93;
return &apos; \ n \ n &apos; . join ( paras )
linebreaks = allow _ lazy ( linebreaks , six . text _ type )
class MLStripper ( HTMLParser ) :
def _ _ init _ _ ( self ) :
if sys . version _ info &#91; : 2 &#93; = = ( 3 , 2 ) :
HTMLParser . _ _ init _ _ ( self , strict = False )
else :
HTMLParser . _ _ init _ _ ( self )
self . reset ( )
self . fed = &#91; &#93;
def handle _ data ( self , d ) :
self . fed . append ( d )
def handle _ entityref ( self , name ) :
self . fed . append ( &apos; &amp; % s ; &apos; % name )
def handle _ charref ( self , name ) :
self . fed . append ( &apos; &amp; # % s ; &apos; % name )
def get _ data ( self ) :
return &apos; &apos; . join ( self . fed )
def _ strip _ once ( value ) :
s = MLStripper ( )
try :
s . feed ( value )
except HTMLParseError :
return value
try :
s . close ( )
except ( HTMLParseError , UnboundLocalError ) :
return s . get _ data ( ) + s . rawdata
else :
return s . get _ data ( )
def strip _ tags ( value ) :
while &apos; &lt; &apos; in value and &apos; &gt; &apos; in value :
new _ value = _ strip _ once ( value )
if new _ value = = value :
break
value = new _ value
return value
strip _ tags = allow _ lazy ( strip _ tags )
def remove _ tags ( html , tags ) :
tags = &#91; re . escape ( tag ) for tag in tags . split ( ) &#93;
tags _ re = &apos; ( % s ) &apos; % &apos; &#124; &apos; . join ( tags )
starttag _ re = re . compile ( r &apos; &lt; % s ( / ? &gt; &#124; ( \ s + &#91; ^ &gt; &#93; * &gt; ) ) &apos; % tags _ re , re . u )
endtag _ re = re . compile ( &apos; &lt; / % s &gt; &apos; % tags _ re )
html = starttag _ re . sub ( &apos; &apos; , html )
html = endtag _ re . sub ( &apos; &apos; , html )
return html
remove _ tags = allow _ lazy ( remove _ tags , six . text _ type )
def strip _ spaces _ between _ tags ( value ) :
return re . sub ( r &apos; &gt; \ s + &lt; &apos; , &apos; &gt; &lt; &apos; , force _ text ( value ) )
strip _ spaces _ between _ tags = allow _ lazy ( strip _ spaces _ between _ tags , six . text _ type )
def strip _ entities ( value ) :
return re . sub ( r &apos; &amp; ( ? : \ w + &#124; # \ d + ) ; &apos; , &apos; &apos; , force _ text ( value ) )
strip _ entities = allow _ lazy ( strip _ entities , six . text _ type )
def smart _ urlquote ( url ) :
try :
scheme , netloc , path , query , fragment = urlsplit ( url )
try :
netloc = netloc . encode ( &apos; idna &apos; ) . decode ( &apos; ascii &apos; )
except UnicodeError :
pass
else :
url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
except ValueError :
pass
url = unquote ( force _ str ( url ) )
url = quote ( url , safe = b &apos; ! * \ &apos; ( ) ; : @ &amp; = + $ , / ? # &#91; &#93; ~ &apos; )
return force _ text ( url )
def urlize ( text , trim _ url _ limit = None , nofollow = False , autoescape = False ) :
def trim _ url ( x , limit = trim _ url _ limit ) :
if limit is None or len ( x ) &lt; = limit :
return x
return &apos; % s ... &apos; % x &#91; : max ( 0 , limit - 3 ) &#93;
safe _ input = isinstance ( text , SafeData )
words = word _ split _ re . split ( force _ text ( text ) )
for i , word in enumerate ( words ) :
if &apos; .&apos; in word or &apos; @ &apos; in word or &apos; : &apos; in word :
lead , middle , trail = &apos; &apos; , word , &apos; &apos;
for punctuation in TRAILING _ PUNCTUATION :
if middle . endswith ( punctuation ) :
middle = middle &#91; : - len ( punctuation ) &#93;
trail = punctuation + trail
for opening , closing in WRAPPING _ PUNCTUATION :
if middle . startswith ( opening ) :
middle = middle &#91; len ( opening ) : &#93;
lead = lead + opening
if ( middle . endswith ( closing ) and middle . count ( closing ) = = middle . count ( opening ) + 1 ) :
middle = middle &#91; : - len ( closing ) &#93;
trail = closing + trail
url = None
nofollow _ attr = &apos; rel = &quot; nofollow &quot; &apos; if nofollow else &apos; &apos;
if simple _ url _ re . match ( middle ) :
url = smart _ urlquote ( middle )
elif simple _ url _ 2 _ re . match ( middle ) :
url = smart _ urlquote ( &apos; http : / / % s &apos; % middle )
elif &apos; : &apos; not in middle and simple _ email _ re . match ( middle ) :
local , domain = middle . rsplit ( &apos; @ &apos; , 1 )
try :
domain = domain . encode ( &apos; idna &apos; ) . decode ( &apos; ascii &apos; )
except UnicodeError :
continue
url = &apos; mailto : % s @ % s &apos; % ( local , domain )
nofollow _ attr = &apos; &apos;
if url :
trimmed = trim _ url ( middle )
if autoescape and not safe _ input :
lead , trail = escape ( lead ) , escape ( trail )
url , trimmed = escape ( url ) , escape ( trimmed )
middle = &apos; &lt; a href = &quot; % s &quot; % s &gt; % s &lt; / a &gt; &apos; % ( url , nofollow _ attr , trimmed )
words &#91; i &#93; = mark _ safe ( &apos; % s % s % s &apos; % ( lead , middle , trail ) )
else :
if safe _ input :
words &#91; i &#93; = mark _ safe ( word )
elif autoescape :
words &#91; i &#93; = escape ( word )
elif safe _ input :
words &#91; i &#93; = mark _ safe ( word )
elif autoescape :
words &#91; i &#93; = escape ( word )
return &apos; &apos; . join ( words )
urlize = allow _ lazy ( urlize , six . text _ type )
def avoid _ wrapping ( value ) :
return value . replace ( &quot; &quot; , &quot; \ xa0 &quot; )
from django . utils . six . moves import html _ parser as _ html _ parser
import re
import sys
current _ version = sys . version _ info
use _ workaround = ( ( current _ version &lt; ( 2 , 7 , 3 ) ) or ( current _ version &gt; = ( 3 , 0 ) and current _ version &lt; ( 3 , 2 , 3 ) ) )
HTMLParseError = _ html _ parser . HTMLParseError
if not use _ workaround :
if current _ version &gt; = ( 3 , 4 ) :
class HTMLParser ( _ html _ parser . HTMLParser ) :
def _ _ init _ _ ( self , convert _ charrefs = False , * * kwargs ) :
_ html _ parser . HTMLParser . _ _ init _ _ ( self , convert _ charrefs = convert _ charrefs , * * kwargs )
else :
HTMLParser = _ html _ parser . HTMLParser
else :
tagfind = re . compile ( &apos; ( &#91; a-zA-Z &#93; &#91; -.a-zA-Z0-9 : _ &#93; * ) ( ? : \ s &#124; / ( ? ! &gt; ) ) * &apos; )
class HTMLParser ( _ html _ parser . HTMLParser ) :
def _ _ init _ _ ( self ) :
_ html _ parser . HTMLParser . _ _ init _ _ ( self )
self . cdata _ tag = None
def set _ cdata _ mode ( self , tag ) :
try :
self . interesting = _ html _ parser . interesting _ cdata
except AttributeError :
self . interesting = re . compile ( r &apos; &lt; / \ s * % s \ s * &gt; &apos; % tag . lower ( ) , re . i )
self . cdata _ tag = tag . lower ( )
def clear _ cdata _ mode ( self ) :
self . interesting = _ html _ parser . interesting _ normal
self . cdata _ tag = None
def parse _ starttag ( self , i ) :
self . _ _ starttag _ text = None
endpos = self . check _ for _ whole _ start _ tag ( i )
if endpos &lt; 0 :
return endpos
rawdata = self . rawdata
self . _ _ starttag _ text = rawdata &#91; i : endpos &#93;
attrs = &#91; &#93;
match = tagfind . match ( rawdata , i + 1 )
assert match , &apos; unexpected call to parse _ starttag ( ) &apos;
k = match . end ( )
self . lasttag = tag = match . Group ( 1 ) . lower ( )
while k &lt; endpos :
m = _ html _ parser . attrfind . match ( rawdata , k )
if not m :
break
attrname , rest , attrvalue = m . Group ( 1 , 2 , 3 )
if not rest :
attrvalue = None
elif ( attrvalue &#91; : 1 &#93; = = &apos; \ &apos; &apos; = = attrvalue &#91; - 1 : &#93; or attrvalue &#91; : 1 &#93; = = &apos; &quot; &apos; = = attrvalue &#91; - 1 : &#93; ) :
attrvalue = attrvalue &#91; 1 : - 1 &#93;
if attrvalue :
attrvalue = self . unescape ( attrvalue )
attrs . append ( ( attrname . lower ( ) , attrvalue ) )
k = m . end ( )
end = rawdata &#91; k : endpos &#93; . strip ( )
if end not in ( &quot; &gt; &quot; , &quot; / &gt; &quot; ) :
lineno , offset = self . getpos ( )
if &quot; \ n &quot; in self . _ _ starttag _ text :
lineno = lineno + self . _ _ starttag _ text . count ( &quot; \ n &quot; )
offset = ( len ( self . _ _ starttag _ text ) - self . _ _ starttag _ text . rfind ( &quot; \ n &quot; ) )
else :
offset = offset + len ( self . _ _ starttag _ text )
self . error ( &quot; junk characters in start tag : % r &quot; % ( rawdata &#91; k : endpos &#93; &#91; : 20 &#93; , ) )
if end . endswith ( &apos; / &gt; &apos; ) :
self . handle _ startendtag ( tag , attrs )
else :
self . handle _ starttag ( tag , attrs )
if tag in self . cdata _ CONTENT _ ELEMENTS :
self . set _ cdata _ mode ( tag )
return endpos
def parse _ endtag ( self , i ) :
rawdata = self . rawdata
assert rawdata &#91; i : i + 2 &#93; = = &quot; &lt; / &quot; , &quot; unexpected call to parse _ endtag &quot;
match = _ html _ parser . endendtag . search ( rawdata , i + 1 )
if not match :
return - 1
j = match . end ( )
match = _ html _ parser . endtagfind . match ( rawdata , i )
if not match :
if self . cdata _ tag is not None :
self . handle _ data ( rawdata &#91; i : j &#93; )
return j
self . error ( &quot; bad end tag : % r &quot; % ( rawdata &#91; i : j &#93; , ) )
tag = match . Group ( 1 ) . strip ( )
if self . cdata _ tag is not None :
if tag . lower ( ) ! = self . cdata _ tag :
self . handle _ data ( rawdata &#91; i : j &#93; )
return j
self . handle _ endtag ( tag . lower ( ) )
self . clear _ cdata _ mode ( )
return j
from _ _ future _ _ import unicode _ literals
import base64
import calendar
import datetime
import re
import sys
from binascii import Error as BinasciiError
from email . utils import formatdate
from django . utils . datastructures import MultiValueDict
from django . utils . encoding import force _ str , force _ text
from django . utils . functional import allow _ lazy
from django . utils import six
from django . utils . six . moves . urllib . parse import ( quote , quote _ plus , unquote , unquote _ plus , urlparse , urlencode as original _ urlencode )
etag _ MATCH = re . compile ( r &apos; ( ? : w / ) ? &quot; ( ( ? : \ \ . &#124; &#91; ^ &quot; &#93; ) * ) &quot; &apos; )
MONTHS = &apos; jan feb mar apr may jun jul aug sep oct nov dec &apos; . split ( )
_ _ D = r &apos; ( ? p &lt; day &gt; \ d { 2 } ) &apos;
_ _ D2 = r &apos; ( ? p &lt; day &gt; &#91; \ d &#93; \ d ) &apos;
_ _ M = r &apos; ( ? p &lt; mon &gt; \ w { 3 } ) &apos;
_ _ Y = r &apos; ( ? p &lt; year &gt; \ d { 4 } ) &apos;
_ _ Y2 = r &apos; ( ? p &lt; year &gt; \ d { 2 } ) &apos;
_ _ T = r &apos; ( ? p &lt; hour &gt; \ d { 2 } ) : ( ? p &lt; min &gt; \ d { 2 } ) : ( ? p &lt; sec &gt; \ d { 2 } ) &apos;
RFC1123 _ DATE = re . compile ( r &apos; ^ \ w { 3 } , % s % s % s % s GMT $ &apos; % ( _ _ D , _ _ M , _ _ Y , _ _ T ) )
RFC850 _ DATE = re . compile ( r &apos; ^ \ w { 6,9 } , % s- % s- % s % s GMT $ &apos; % ( _ _ D , _ _ M , _ _ Y2 , _ _ T ) )
ASCTIME _ DATE = re . compile ( r &apos; ^ \ w { 3 } % s % s % s % s $ &apos; % ( _ _ M , _ _ D2 , _ _ T , _ _ Y ) )
def urlquote ( url , safe = &apos; / &apos; ) :
return force _ text ( quote ( force _ str ( url ) , force _ str ( safe ) ) )
urlquote = allow _ lazy ( urlquote , six . text _ type )
def urlquote _ plus ( url , safe = &apos; &apos; ) :
return force _ text ( quote _ plus ( force _ str ( url ) , force _ str ( safe ) ) )
urlquote _ plus = allow _ lazy ( urlquote _ plus , six . text _ type )
def urlunquote ( quoted _ url ) :
return force _ text ( unquote ( force _ str ( quoted _ url ) ) )
urlunquote = allow _ lazy ( urlunquote , six . text _ type )
def urlunquote _ plus ( quoted _ url ) :
return force _ text ( unquote _ plus ( force _ str ( quoted _ url ) ) )
urlunquote _ plus = allow _ lazy ( urlunquote _ plus , six . text _ type )
def urlencode ( query , doseq = 0 ) :
if isinstance ( query , MultiValueDict ) :
query = query . lists ( )
elif hasattr ( query , &apos; items &apos; ) :
query = query . items ( )
return original _ urlencode ( &#91; ( force _ str ( k ) , &#91; force _ str ( i ) for i in v &#93; if isinstance ( v , ( list , tuple ) ) else force _ str ( v ) ) for k , v in query &#93; , doseq )
def cookie _ date ( epoch _ seconds = None ) :
rfcdate = formatdate ( epoch _ seconds )
return &apos; % s- % s- % s GMT &apos; % ( rfcdate &#91; : 7 &#93; , rfcdate &#91; 8 : 11 &#93; , rfcdate &#91; 12 : 25 &#93; )
def http _ date ( epoch _ seconds = None ) :
return formatdate ( epoch _ seconds , usegmt = True )
def parse _ http _ date ( date ) :
for regex in RFC1123 _ DATE , RFC850 _ DATE , ASCTIME _ DATE :
m = regex . match ( date )
if m is not None :
break
else :
raise ValueError ( &quot; % r is not in a valid HTTP date format &quot; % date )
try :
year = int ( m . Group ( &apos; year &apos; ) )
if year &lt; 100 :
if year &lt; 70 :
year + = 2000
else :
year + = 1900
month = MONTHS . index ( m . Group ( &apos; mon &apos; ) . lower ( ) ) + 1
day = int ( m . Group ( &apos; day &apos; ) )
hour = int ( m . Group ( &apos; hour &apos; ) )
min = int ( m . Group ( &apos; min &apos; ) )
sec = int ( m . Group ( &apos; sec &apos; ) )
result = datetime . datetime ( year , month , day , hour , min , sec )
return calendar . timegm ( result . utctimetuple ( ) )
except Exception :
six . reraise ( ValueError , ValueError ( &quot; % r is not a valid date &quot; % date ) , sys . exc _ info ( ) &#91; 2 &#93; )
def parse _ http _ date _ safe ( date ) :
try :
return parse _ http _ date ( date )
except Exception :
pass
def base36 _ to _ int ( s ) :
if len ( s ) &gt; 13 :
raise ValueError ( &quot; Base36 input too large &quot; )
value = int ( s , 36 )
if six . PY2 and value &gt; sys . maxint :
raise ValueError ( &quot; Base36 input too large &quot; )
return value
def int _ to _ base36 ( i ) :
digits = &quot; 0123456789abcdefghijklmnopqrstuvwxyz &quot;
factor = 0
if i &lt; 0 :
raise ValueError ( &quot; Negative base36 conversion input . &quot; )
if six . PY2 :
if not isinstance ( i , six . integer _ types ) :
raise TypeError ( &quot; Non-integer base36 conversion input . &quot; )
if i &gt; sys . maxint :
raise ValueError ( &quot; Base36 conversion input too large . &quot; )
while True :
factor + = 1
if i &lt; 36 * * factor :
factor - = 1
break
base36 = &#91; &#93;
while factor &gt; = 0 :
j = 36 * * factor
base36 . append ( digits &#91; i / / j &#93; )
i = i % j
factor - = 1
return &apos; &apos; . join ( base36 )
def urlsafe _ base64 _ encode ( s ) :
return base64 . urlsafe _ b64encode ( s ) . rstrip ( b &apos; \ n = &apos; )
def urlsafe _ base64 _ decode ( s ) :
s = s . encode ( &apos; utf-8 &apos; )
try :
return base64 . urlsafe _ b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , b &apos; = &apos; ) )
except ( LookupError , BinasciiError ) as e :
raise ValueError ( e )
def parse _ etags ( etag _ str ) :
etags = ETAG _ MATCH . findall ( etag _ str )
if not etags :
return &#91; etag _ str &#93;
etags = &#91; e . encode ( &apos; ascii &apos; ) . decode ( &apos; unicode _ escape &apos; ) for e in etags &#93;
return etags
def quote _ etag ( etag ) :
return &apos; &quot; % s &quot; &apos; % etag . replace ( &apos; \ \ &apos; , &apos; \ \ \ \ &apos; ) . replace ( &apos; &quot; &apos; , &apos; \ \ &quot; &apos; )
def same _ origin ( url1 , url2 ) :
p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )
try :
return ( p1 . scheme , p1 . hostname , p1 . port ) = = ( p2 . scheme , p2 . hostname , p2 . port )
except ValueError :
return False
def is _ safe _ url ( url , host = None ) :
if not url :
return False
url = url . replace ( &apos; \ \ &apos; , &apos; / &apos; )
if url . startswith ( &apos; / / / &apos; ) :
return False
url _ info = urlparse ( url )
if not url _ info . netloc and url _ info . scheme :
return False
return ( ( not url _ info . netloc or url _ info . netloc = = host ) and ( not url _ info . scheme or url _ info . scheme in &#91; &apos; http &apos; , &apos; https &apos; &#93; ) )
import warnings
import sys
from django . utils import six
from django . utils . deprecation import RemovedInDjango19Warning
warnings . warn ( &quot; django.utils.importlib will be removed in Django 1.9 . &quot; , RemovedInDjango19Warning , stacklevel = 2 )
def _ resolve _ name ( name , package , level ) :
if not hasattr ( package , &apos; rindex &apos; ) :
raise ValueError ( &quot; &apos; package &apos; not set to a string &quot; )
dot = len ( package )
for x in range ( level , 1 , - 1 ) :
try :
dot = package . rindex ( &apos; .&apos; , 0 , dot )
except ValueError :
raise ValueError ( &quot; attempted relative import beyond top-level package &quot; )
return &quot; % s . % s &quot; % ( package &#91; : dot &#93; , name )
if six . PY3 :
from importlib import import _ module
else :
def import _ module ( name , package = None ) :
if name . startswith ( &apos; .&apos; ) :
if not package :
raise TypeError ( &quot; relative imports require the &apos; package &apos; argument &quot; )
level = 0
for character in name :
if character ! = &apos; .&apos; :
break
level + = 1
name = _ resolve _ name ( name &#91; level : &#93; , package , level )
_ _ import _ _ ( name )
return sys . modules &#91; name &#93;
from django . core . exceptions import ValidationError
from django . utils . translation import ugettext _ lazy as _
from django . utils . six . moves import xrange
def clean _ ipv6 _ address ( ip _ str , unpack _ ipv4 = False , error _ message = _ ( &quot; This is not a valid IPv6 address . &quot; ) ) :
best _ doublecolon _ start = - 1
best _ doublecolon _ len = 0
doublecolon _ start = - 1
doublecolon _ len = 0
if not is _ valid _ ipv6 _ address ( ip _ str ) :
raise ValidationError ( error _ message , code = &apos; invalid &apos; )
ip _ str = _ explode _ shorthand _ ip _ string ( ip _ str )
ip _ str = _ sanitize _ ipv4 _ mapping ( ip _ str )
if unpack _ ipv4 :
ipv4 _ unpacked = _ unpack _ ipv4 ( ip _ str )
if ipv4 _ unpacked :
return ipv4 _ unpacked
hextets = ip _ str . split ( &quot; : &quot; )
for index in range ( len ( hextets ) ) :
hextets &#91; index &#93; = hextets &#91; index &#93; . lstrip ( &apos; 0&apos; )
if not hextets &#91; index &#93; :
hextets &#91; index &#93; = &apos; 0&apos;
if hextets &#91; index &#93; = = &apos; 0&apos; :
doublecolon _ len + = 1
if doublecolon _ start = = - 1 :
doublecolon _ start = index
if doublecolon _ len &gt; best _ doublecolon _ len :
best _ doublecolon _ len = doublecolon _ len
best _ doublecolon _ start = doublecolon _ start
else :
doublecolon _ len = 0
doublecolon _ start = - 1
if best _ doublecolon _ len &gt; 1 :
best _ doublecolon _ end = ( best _ doublecolon _ start + best _ doublecolon _ len )
if best _ doublecolon _ end = = len ( hextets ) :
hextets + = &#91; &apos; &apos; &#93;
hextets &#91; best _ doublecolon _ start : best _ doublecolon _ end &#93; = &#91; &apos; &apos; &#93;
if best _ doublecolon _ start = = 0 :
hextets = &#91; &apos; &apos; &#93; + hextets
result = &quot; : &quot; . join ( hextets )
return result . lower ( )
def _ sanitize _ ipv4 _ mapping ( ip _ str ) :
if not ip _ str . lower ( ) . startswith ( &apos; 0000 : 0000 : 0000 : 0000 : 0000 : FFFF : &apos; ) :
return ip _ str
hextets = ip _ str . split ( &apos; : &apos; )
if &apos; .&apos; in hextets &#91; - 1 &#93; :
return ip _ str
ipv4 _ address = &quot; % d . % d . % d . % d &quot; % ( int ( hextets &#91; 6 &#93; &#91; 0 : 2 &#93; , 16 ) , int ( hextets &#91; 6 &#93; &#91; 2 : 4 &#93; , 16 ) , int ( hextets &#91; 7 &#93; &#91; 0 : 2 &#93; , 16 ) , int ( hextets &#91; 7 &#93; &#91; 2 : 4 &#93; , 16 ) , )
result = &apos; : &apos; . join ( hextets &#91; 0 : 6 &#93; )
result + = &apos; : &apos; + ipv4 _ address
return result
def _ unpack _ ipv4 ( ip _ str ) :
if not ip _ str . lower ( ) . startswith ( &apos; 0000 : 0000 : 0000 : 0000 : 0000 : FFFF : &apos; ) :
return None
return ip _ str . rsplit ( &apos; : &apos; , 1 ) &#91; 1 &#93;
def is _ valid _ ipv6 _ address ( ip _ str ) :
from django . core . validators import validate _ ipv4 _ address
if &apos; : &apos; not in ip _ str :
return False
if ip _ str . count ( &apos; : : &apos; ) &gt; 1 :
return False
if &apos; : : : &apos; in ip _ str :
return False
if ( ( ip _ str . startswith ( &apos; : &apos; ) and not ip _ str . startswith ( &apos; : : &apos; ) ) or ( ip _ str . endswith ( &apos; : &apos; ) and not ip _ str . endswith ( &apos; : : &apos; ) ) ) :
return False
if ip _ str . count ( &apos; : &apos; ) &gt; 7 :
return False
if &apos; : : &apos; not in ip _ str and ip _ str . count ( &apos; : &apos; ) ! = 7 :
if ip _ str . count ( &apos; .&apos; ) ! = 3 :
return False
ip _ str = _ explode _ shorthand _ ip _ string ( ip _ str )
for hextet in ip _ str . split ( &apos; : &apos; ) :
if hextet . count ( &apos; .&apos; ) = = 3 :
if not ip _ str . split ( &apos; : &apos; ) &#91; - 1 &#93; = = hextet :
return False
try :
validate _ ipv4 _ address ( hextet )
except ValidationError :
return False
else :
try :
if int ( hextet , 16 ) &lt; 0x0 or int ( hextet , 16 ) &gt; 0xFFFF :
return False
except ValueError :
return False
return True
def _ explode _ shorthand _ ip _ string ( ip _ str ) :
if not _ is _ shorthand _ ip ( ip _ str ) :
return ip _ str
new _ ip = &#91; &#93;
hextet = ip _ str . split ( &apos; : : &apos; )
if &apos; .&apos; in ip _ str . split ( &apos; : &apos; ) &#91; - 1 &#93; :
fill _ to = 7
else :
fill _ to = 8
if len ( hextet ) &gt; 1 :
sep = len ( hextet &#91; 0 &#93; . split ( &apos; : &apos; ) ) + len ( hextet &#91; 1 &#93; . split ( &apos; : &apos; ) )
new _ ip = hextet &#91; 0 &#93; . split ( &apos; : &apos; )
for _ _ in xrange ( fill _ to - sep ) :
new _ ip . append ( &apos; 0000 &apos; )
new _ ip + = hextet &#91; 1 &#93; . split ( &apos; : &apos; )
else :
new _ ip = ip _ str . split ( &apos; : &apos; )
ret _ ip = &#91; &#93;
for hextet in new _ ip :
ret _ ip . append ( ( &apos; 0&apos; * ( 4 - len ( hextet ) ) + hextet ) . lower ( ) )
return &apos; : &apos; . join ( ret _ ip )
def _ is _ shorthand _ ip ( ip _ str ) :
if ip _ str . count ( &apos; : : &apos; ) = = 1 :
return True
if any ( len ( x ) &lt; 4 for x in ip _ str . split ( &apos; : &apos; ) ) :
return True
return False
def is _ iterable ( x ) :
try :
iter ( x )
except TypeError :
return False
else :
return True
import re
class Tok ( object ) :
num = 0
def _ _ init _ _ ( self , name , regex , next = None ) :
self . id = Tok . num
tok . num + = 1
self . name = name
self . regex = regex
self . next = next
def literals ( choices , prefix = &quot; &quot; , suffix = &quot; &quot; ) :
return &quot; &#124; &quot; . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )
class Lexer ( object ) :
def _ _ init _ _ ( self , states , first ) :
self . regexes = { }
self . toks = { }
for state , rules in states . items ( ) :
parts = &#91; &#93;
for tok in rules :
groupid = &quot; t % d &quot; % tok . id
self . toks &#91; groupid &#93; = tok
parts . append ( &quot; ( ? p &lt; % s &gt; % s ) &quot; % ( groupid , tok . regex ) )
self . regexes &#91; state &#93; = re . compile ( &quot; &#124; &quot; . join ( parts ) , re . MULTILINE &#124; re . verbose )
self . state = first
def lex ( self , text ) :
end = len ( text )
state = self . state
regexes = self . regexes
toks = self . toks
start = 0
while start &lt; end :
for match in regexes &#91; state &#93; . finditer ( text , start ) :
name = match . lastgroup
tok = toks &#91; name &#93;
toktext = match . Group ( name )
start + = len ( toktext )
yield ( tok . name , toktext )
if tok . next :
state = tok . next
break
self . state = state
class JsLexer ( Lexer ) :
both _ before = &#91; Tok ( &quot; comment &quot; , r &quot; / \ * ( . &#124; \ n ) * ? \ * / &quot; ) , Tok ( &quot; linecomment &quot; , r &quot; / / . * ? $ &quot; ) , Tok ( &quot; ws &quot; , r &quot; \ s + &quot; ) , Tok ( &quot; keyword &quot; , literals ( &quot; &quot; &quot; break case catch class const continue debugger default delete do else enum export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with &quot; &quot; &quot; , suffix = r &quot; \ b &quot; ) , next = &apos; reg &apos; ) , Tok ( &quot; reserved &quot; , literals ( &quot; null true false &quot; , suffix = r &quot; \ b &quot; ) , next = &apos; div &apos; ) , Tok ( &quot; id &quot; , r &quot; &quot; &quot; ( &#91; a-zA-Z _ $ &#93; &#124; \ \ u &#91; 0-9a-fA-Z &#93; { 4 } ) # first char ( &#91; a-zA-Z _ $ 0-9 &#93; &#124; \ \ u &#91; 0-9a-fA-F &#93; { 4 } ) * # rest chars &quot; &quot; &quot; , next = &apos; div &apos; ) , Tok ( &quot; hnum &quot; , r &quot; 0 &#91; xX &#93; &#91; 0-9a-fA-F &#93; + &quot; , next = &apos; div &apos; ) , Tok ( &quot; onum &quot; , r &quot; 0 &#91; 0-7 &#93; + &quot; ) , Tok ( &quot; dnum &quot; , r &quot; &quot; &quot; ( ( 0 &#124; &#91; 1-9 &#93; &#91; 0-9 &#93; * ) # DecimalIntegerLiteral \ . # dot &#91; 0-9 &#93; * # DecimalDigits-opt ( &#91; eE &#93; &#91; - + &#93; ? &#91; 0-9 &#93; + ) ? # ExponentPart-opt &#124; \ . # dot &#91; 0-9 &#93; + # DecimalDigits ( &#91; eE &#93; &#91; - + &#93; ? &#91; 0-9 &#93; + ) ? # ExponentPart-opt &#124; ( 0 &#124; &#91; 1-9 &#93; &#91; 0-9 &#93; * ) # DecimalIntegerLiteral ( &#91; eE &#93; &#91; - + &#93; ? &#91; 0-9 &#93; + ) ? # ExponentPart-opt ) &quot; &quot; &quot; , next = &apos; div &apos; ) , Tok ( &quot; punct &quot; , literals ( &quot; &quot; &quot; &gt; &gt; &gt; = = = = ! = = &gt; &gt; &gt; &lt; &lt; = &gt; &gt; = &lt; = &gt; = = = ! = &lt; &lt; &gt; &gt; &amp; &amp; &#124; &#124; + = - = * = % = &amp; = &#124; = ^ = &quot; &quot; &quot; ) , next = &quot; reg &quot; ) , Tok ( &quot; punct &quot; , literals ( &quot; + + -- ) &#93; &quot; ) , next = &apos; div &apos; ) , Tok ( &quot; punct &quot; , literals ( &quot; { } ( &#91; . ; , &lt; &gt; + - * % &amp; &#124; ^ ! ~ ? : = &quot; ) , next = &apos; reg &apos; ) , Tok ( &quot; string &quot; , r &apos; &quot; ( &#91; ^ &quot; \ \ &#93; &#124; ( \ \ ( . &#124; \ n ) ) ) * ? &quot; &apos; , next = &apos; div &apos; ) , Tok ( &quot; string &quot; , r &quot; &apos; ( &#91; ^ &apos; \ \ &#93; &#124; ( \ \ ( . &#124; \ n ) ) ) * ? &apos; &quot; , next = &apos; div &apos; ) , &#93;
both _ after = &#91; Tok ( &quot; other &quot; , r &quot; . &quot; ) , &#93;
states = { &apos; div &apos; : both _ before + &#91; Tok ( &quot; punct &quot; , literals ( &quot; / = / &quot; ) , next = &apos; reg &apos; ) , &#93; + both _ after , &apos; reg &apos; : both _ before + &#91; Tok ( &quot; regex &quot; , r &quot; &quot; &quot; / # opening slash # first character is .. ( &#91; ^ * \ \ / &#91; &#93; # anything but * \ / or &#91; &#124; \ \ . # or an escape sequence &#124; \ &#91; # or a class , which has ( &#91; ^ \ &#93; \ \ &#93; # anything but \ or &#93; &#124; \ \ . # or an escape sequence ) * # many times \ &#93; ) # following characters are same , except for excluding a star ( &#91; ^ \ \ / &#91; &#93; # anything but \ / or &#91; &#124; \ \ . # or an escape sequence &#124; \ &#91; # or a class , which has ( &#91; ^ \ &#93; \ \ &#93; # anything but \ or &#93; &#124; \ \ . # or an escape sequence ) * # many times \ &#93; ) * # many times / # closing slash &#91; a-zA-Z0-9 &#93; * # trailing flags &quot; &quot; &quot; , next = &apos; div &apos; ) , &#93; + both _ after , }
def _ _ init _ _ ( self ) :
super ( JsLexer , self ) . _ _ init _ _ ( self . states , &apos; reg &apos; )
def prepare _ js _ for _ gettext ( js ) :
def escape _ quotes ( m ) :
s = m . Group ( 0 )
if s = = &apos; &quot; &apos; :
return r &apos; \ &quot; &apos;
else :
return s
Lexer = JsLexer ( )
c = &#91; &#93;
for name , tok in lexer . lex ( js ) :
if name = = &apos; regex &apos; :
tok = &apos; &quot; REGEX &quot; &apos;
elif name = = &apos; string &apos; :
if tok . startswith ( &quot; &apos; &quot; ) :
guts = re . sub ( r &quot; \ \ . &#124; . &quot; , escape _ quotes , tok &#91; 1 : - 1 &#93; )
tok = &apos; &quot; &apos; + guts + &apos; &quot; &apos;
elif name = = &apos; id &apos; :
tok = tok . replace ( &quot; \ \ &quot; , &quot; U &quot; )
c . append ( tok )
return &apos; &apos; . join ( c )
import logging
import sys
import warnings
from django . conf import settings
from django . core import mail
from django . core . mail import get _ connection
from django . utils . deprecation import RemovedInNextVersionWarning
from django . utils . module _ loading import import _ string
from django . views . DEBUG import ExceptionReporter , get _ exception _ reporter _ filter
from logging import NullHandler
from logging . config import dictConfig
getLogger = logging . getLogger
default _ LOGGING = { &apos; version &apos; : 1 , &apos; disable _ existing _ loggers &apos; : False , &apos; filters &apos; : { &apos; require _ debug _ false &apos; : { &apos; ( ) &apos; : &apos; django.utils.log.RequireDebugFalse &apos; , } , &apos; require _ debug _ true &apos; : { &apos; ( ) &apos; : &apos; django.utils.log.RequireDebugTrue &apos; , } , } , &apos; handlers &apos; : { &apos; console &apos; : { &apos; level &apos; : &apos; info &apos; , &apos; filters &apos; : &#91; &apos; require _ debug _ true &apos; &#93; , &apos; class &apos; : &apos; logging.StreamHandler &apos; , } , &apos; null &apos; : { &apos; class &apos; : &apos; logging.NullHandler &apos; , } , &apos; mail _ admins &apos; : { &apos; level &apos; : &apos; error &apos; , &apos; filters &apos; : &#91; &apos; require _ debug _ false &apos; &#93; , &apos; class &apos; : &apos; django.utils.log.AdminEmailHandler &apos; } } , &apos; loggers &apos; : { &apos; django &apos; : { &apos; handlers &apos; : &#91; &apos; console &apos; &#93; , } , &apos; django.request &apos; : { &apos; handlers &apos; : &#91; &apos; mail _ admins &apos; &#93; , &apos; level &apos; : &apos; error &apos; , &apos; propagate &apos; : False , } , &apos; django.security &apos; : { &apos; handlers &apos; : &#91; &apos; mail _ admins &apos; &#93; , &apos; level &apos; : &apos; error &apos; , &apos; propagate &apos; : False , } , &apos; py.warnings &apos; : { &apos; handlers &apos; : &#91; &apos; console &apos; &#93; , } , } }
def configure _ logging ( logging _ config , logging _ settings ) :
if not sys . warnoptions :
logging . captureWarnings ( True )
warnings . simplefilter ( &quot; default &quot; , RemovedInNextVersionWarning )
if logging _ config :
logging _ config _ func = import _ string ( logging _ config )
logging _ config _ func ( DEFAULT _ LOGGING )
if logging _ settings :
logging _ config _ func ( logging _ settings )
class AdminEmailHandler ( logging . handler ) :
def _ _ init _ _ ( self , include _ html = False , email _ backend = None ) :
logging . handler . _ _ init _ _ ( self )
self . include _ html = include _ html
self . email _ backend = email _ backend
def emit ( self , record ) :
try :
request = record . request
subject = &apos; % s ( % s IP ) : % s &apos; % ( record . levelname , ( &apos; internal &apos; if request . meta . get ( &apos; REMOTE _ ADDR &apos; ) in settings . internal _ IPS else &apos; EXTERNAL &apos; ) , record . getMessage ( ) )
filter = get _ exception _ reporter _ filter ( request )
request _ repr = &apos; \ n { 0 } &apos; . format ( filter . get _ request _ repr ( request ) )
except Exception :
subject = &apos; % s : % s &apos; % ( record . levelname , record . getMessage ( ) )
request = None
request _ repr = &quot; unavailable &quot;
subject = self . format _ subject ( subject )
if record . exc _ info :
exc _ info = record . exc _ info
else :
exc _ info = ( None , record . getMessage ( ) , None )
message = &quot; % s \ n \ nRequest repr ( ) : % s &quot; % ( self . format ( record ) , request _ repr )
reporter = ExceptionReporter ( request , is _ email = True , * exc _ info )
html _ message = reporter . get _ traceback _ html ( ) if self . include _ html else None
mail . mail _ admins ( subject , message , fail _ silently = True , html _ message = html _ message , connection = self . connection ( ) )
def connection ( self ) :
return get _ connection ( backend = self . email _ backend , fail _ silently = True )
def format _ subject ( self , subject ) :
formatted _ subject = subject . replace ( &apos; \ n &apos; , &apos; \ \ n &apos; ) . replace ( &apos; \ r &apos; , &apos; \ \ r &apos; )
return formatted _ subject &#91; : 989 &#93;
class CallbackFilter ( logging . filter ) :
def _ _ init _ _ ( self , callback ) :
self . callback = callback
def filter ( self , record ) :
if self . callback ( record ) :
return 1
return 0
class RequireDebugFalse ( logging . filter ) :
def filter ( self , record ) :
return not settings . DEBUG
class RequireDebugTrue ( logging . filter ) :
def filter ( self , record ) :
return settings . DEBUG
try :
from functools import lru _ cache
except ImportError :
from collections import namedtuple
from functools import update _ wrapper
from threading import RLock
_ CacheInfo = namedtuple ( &quot; CacheInfo &quot; , &#91; &quot; hits &quot; , &quot; MISSES &quot; , &quot; maxsize &quot; , &quot; currsize &quot; &#93; )
class _ HashedSeq ( list ) :
_ _ slots _ _ = &apos; hashvalue&apos;
def _ _ init _ _ ( self , tup , hash = hash ) :
self &#91; : &#93; = tup
self . hashvalue = hash ( tup )
def _ _ hash _ _ ( self ) :
return self . hashvalue
def _ make _ key ( args , kwds , typed , kwd _ mark = ( object ( ) , ) , fasttypes = { int , str , frozenset , type ( None ) } , sorted = sorted , tuple = tuple , type = type , len = len ) :
key = args
if kwds :
sorted _ items = sorted ( kwds . items ( ) )
key + = kwd _ mark
for item in sorted _ items :
key + = item
if typed :
key + = tuple ( type ( v ) for v in args )
if kwds :
key + = tuple ( type ( v ) for k , v in sorted _ items )
elif len ( key ) = = 1 and type ( key &#91; 0 &#93; ) in fasttypes :
return key &#91; 0 &#93;
return _ HashedSeq ( key )
def lru _ cache ( maxsize = 100 , typed = False ) :
def decorating _ function ( user _ function ) :
cache = dict ( )
stats = &#91; 0 , 0 &#93;
HITS , MISSES = 0 , 1
make _ key = _ make _ key
cache _ get = cache . get
_ len = len
lock = RLock ( )
root = &#91; &#93;
root &#91; : &#93; = &#91; root , root , None , None &#93;
nonlocal _ root = &#91; root &#93;
PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
if maxsize = = 0 :
def wrapper ( * args , * * kwds ) :
result = user _ function ( * args , * * kwds )
stats &#91; MISSES &#93; + = 1
return result
elif maxsize is None :
def wrapper ( * args , * * kwds ) :
key = make _ key ( args , kwds , typed )
result = cache _ get ( key , root )
if result is not root :
stats &#91; HITS &#93; + = 1
return result
result = user _ function ( * args , * * kwds )
cache &#91; key &#93; = result
stats &#91; MISSES &#93; + = 1
return result
else :
def wrapper ( * args , * * kwds ) :
key = make _ key ( args , kwds , typed ) if kwds or typed else args
with lock :
link = cache _ get ( key )
if link is not None :
root , = nonlocal _ root
link _ prev , link _ next , key , result = link
link _ prev &#91; NEXT &#93; = link _ next
link _ next &#91; PREV &#93; = link _ prev
last = root &#91; PREV &#93;
last &#91; NEXT &#93; = root &#91; PREV &#93; = link
link &#91; PREV &#93; = last
link &#91; NEXT &#93; = root
stats &#91; HITS &#93; + = 1
return result
result = user _ function ( * args , * * kwds )
with lock :
root , = nonlocal _ root
if key in cache :
pass
elif _ len ( cache ) &gt; = maxsize :
oldroot = root
oldroot &#91; KEY &#93; = key
oldroot &#91; RESULT &#93; = result
root = nonlocal _ root &#91; 0 &#93; = oldroot &#91; NEXT &#93;
oldkey = root &#91; KEY &#93;
oldvalue = root &#91; RESULT &#93;
root &#91; KEY &#93; = root &#91; RESULT &#93; = None
del cache &#91; oldkey &#93;
cache &#91; key &#93; = oldroot
else :
last = root &#91; PREV &#93;
link = &#91; last , root , key , result &#93;
last &#91; NEXT &#93; = root &#91; PREV &#93; = cache &#91; key &#93; = link
stats &#91; MISSES &#93; + = 1
return result
def cache _ info ( ) :
with lock :
return _ CacheInfo ( stats &#91; HITS &#93; , stats &#91; MISSES &#93; , maxsize , len ( cache ) )
def cache _ clear ( ) :
with lock :
cache . clear ( )
root = nonlocal _ root &#91; 0 &#93;
root &#91; : &#93; = &#91; root , root , None , None &#93;
stats &#91; : &#93; = &#91; 0 , 0 &#93;
wrapper . _ _ wrapped _ _ = user _ function
wrapper . cache _ info = cache _ info
wrapper . cache _ clear = cache _ clear
return update _ wrapper ( wrapper , user _ function )
return decorating _ function
from _ _ future _ _ import absolute _ import
import copy
from importlib import import _ module
import os
import sys
import warnings
from django . core . exceptions import ImproperlyConfigured
from django . utils import six
from django . utils . deprecation import RemovedInDjango19Warning
def import _ string ( dotted _ path ) :
try :
module _ path , class _ name = dotted _ path . rsplit ( &apos; .&apos; , 1 )
except ValueError :
msg = &quot; % s doesn &apos;t look like a module path &quot; % dotted _ path
six . reraise ( ImportError , ImportError ( msg ) , sys . exc _ info ( ) &#91; 2 &#93; )
module = import _ module ( module _ path )
try :
return getattr ( module , class _ name )
except AttributeError :
msg = &apos; Module &quot; % s &quot; does not define a &quot; % s &quot; attribute / class &apos; % ( dotted _ path , class _ name )
six . reraise ( ImportError , ImportError ( msg ) , sys . exc _ info ( ) &#91; 2 &#93; )
def import _ by _ path ( dotted _ path , error _ prefix = &apos; &apos; ) :
warnings . warn ( &apos; import _ by _ path ( ) has been deprecated . use import _ string ( ) instead . &apos; , RemovedInDjango19Warning , stacklevel = 2 )
try :
attr = import _ string ( dotted _ path )
except ImportError as e :
msg = &apos; % sError importing module % s : &quot; % s &quot; &apos; % ( error _ prefix , dotted _ path , e )
six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) , sys . exc _ info ( ) &#91; 2 &#93; )
return attr
def autodiscover _ modules ( * args , * * kwargs ) :
from django . apps import apps
register _ to = kwargs . get ( &apos; register _ to &apos; )
for app _ config in apps . get _ app _ configs ( ) :
try :
if register _ to :
before _ import _ registry = copy . copy ( register _ to . _ registry )
for module _ to _ search in args :
import _ module ( &apos; % s . % s &apos; % ( app _ config . name , module _ to _ search ) )
except :
if register _ to :
register _ to . _ registry = before _ import _ registry
if module _ has _ submodule ( app _ config . module , module _ to _ search ) :
raise
if sys . version _ info &#91; : 2 &#93; &gt; = ( 3 , 3 ) :
if sys . version _ info &#91; : 2 &#93; &gt; = ( 3 , 4 ) :
from importlib . util import find _ spec as importlib _ find
else :
from importlib import find _ loader as importlib _ find
def module _ has _ submodule ( package , module _ name ) :
try :
package _ name = package . _ _ name _ _
package _ path = package . _ _ path _ _
except AttributeError :
return False
full _ module _ name = package _ name + &apos; .&apos; + module _ name
return importlib _ find ( full _ module _ name , package _ path ) is not None
else :
import imp
def module _ has _ submodule ( package , module _ name ) :
name = &quot; . &quot; . join ( &#91; package . _ _ name _ _ , module _ name &#93; )
try :
return sys . modules &#91; name &#93; is not None
except KeyError :
pass
try :
package _ path = package . _ _ path _ _
except AttributeError :
return False
for finder in sys . meta _ path :
if finder . find _ module ( name , package _ path ) :
return True
for entry in package _ path :
try :
finder = sys . path _ importer _ cache &#91; entry &#93;
if finder is None :
try :
file _ , _ , _ = imp . find _ module ( module _ name , &#91; entry &#93; )
if file _ :
file _ . close ( )
return True
except ImportError :
continue
elif finder . find _ module ( name ) :
return True
else :
continue
except KeyError :
for hook in sys . path _ hooks :
try :
finder = hook ( entry )
if finder . find _ module ( name ) :
return True
else :
break
except ImportError :
continue
else :
if os . path . isdir ( entry ) :
try :
file _ , _ , _ = imp . find _ module ( module _ name , &#91; entry &#93; )
if file _ :
file _ . close ( )
return True
except ImportError :
pass
else :
return False
from django . conf import settings
from django . utils . SafeString import mark _ safe
from django . utils import six
def format ( number , decimal _ sep , decimal _ pos = None , grouping = 0 , thousand _ sep = &apos; &apos; , force _ grouping = False ) :
use _ grouping = settings . use _ L10N and settings . use _ THOUSAND _ SEPARATOR
use _ grouping = use _ grouping or force _ grouping
use _ grouping = use _ grouping and grouping &gt; 0
if isinstance ( number , int ) and not use _ grouping and not decimal _ pos :
return mark _ safe ( six . text _ type ( number ) )
sign = &apos; &apos;
str _ number = six . text _ type ( number )
if str _ number &#91; 0 &#93; = = &apos; -&apos; :
sign = &apos; -&apos;
str _ number = str _ number &#91; 1 : &#93;
if &apos; .&apos; in str _ number :
int _ part , dec _ part = str _ number . split ( &apos; .&apos; )
if decimal _ pos is not None :
dec _ part = dec _ part &#91; : decimal _ pos &#93;
else :
int _ part , dec _ part = str _ number , &apos; &apos;
if decimal _ pos is not None :
dec _ part = dec _ part + ( &apos; 0&apos; * ( decimal _ pos - len ( dec _ part ) ) )
if dec _ part :
dec _ part = decimal _ sep + dec _ part
if use _ grouping :
int _ part _ gd = &apos; &apos;
for cnt , digit in enumerate ( int _ part &#91; : : - 1 &#93; ) :
if cnt and not cnt % grouping :
int _ part _ gd + = thousand _ sep
int _ part _ gd + = digit
int _ part = int _ part _ gd &#91; : : - 1 &#93;
return sign + int _ part + dec _ part
from _ _ future _ _ import unicode _ literals
from django . utils import six
from django . utils . six . moves import zip
escape _ MAPPINGS = { &quot; A &quot; : None , &quot; b &quot; : None , &quot; B &quot; : None , &quot; d &quot; : &quot; 0 &quot; , &quot; D &quot; : &quot; x &quot; , &quot; s &quot; : &quot; &quot; , &quot; S &quot; : &quot; x &quot; , &quot; w &quot; : &quot; x &quot; , &quot; W &quot; : &quot; ! &quot; , &quot; Z &quot; : None , }
class Choice ( list ) :
class Group ( list ) :
class NonCapture ( list ) :
def normalize ( pattern ) :
result = &#91; &#93;
non _ capturing _ groups = &#91; &#93;
consume _ next = True
pattern _ iter = next _ char ( iter ( pattern ) )
num _ args = 0
try :
ch , escaped = next ( pattern _ iter )
except StopIteration :
return &#91; ( &apos; &apos; , &#91; &#93; ) &#93;
try :
while True :
if escaped :
result . append ( ch )
elif ch = = &apos; .&apos; :
result . append ( &quot; . &quot; )
elif ch = = &apos; &#124; &apos; :
raise NotImplementedError ( &apos; Awaiting Implementation &apos; )
elif ch = = &quot; ^ &quot; :
pass
elif ch = = &apos; $ &apos; :
break
elif ch = = &apos; ) &apos; :
start = non _ capturing _ groups . pop ( )
inner = NonCapture ( result &#91; start : &#93; )
result = result &#91; : start &#93; + &#91; inner &#93;
elif ch = = &apos; &#91; &apos; :
ch , escaped = next ( pattern _ iter )
result . append ( ch )
ch , escaped = next ( pattern _ iter )
while escaped or ch ! = &apos; &#93; &apos; :
ch , escaped = next ( pattern _ iter )
elif ch = = &apos; ( &apos; :
ch , escaped = next ( pattern _ iter )
if ch ! = &apos; ? &apos; or escaped :
name = &quot; _ % d &quot; % num _ args
num _ args + = 1
result . append ( Group ( ( ( &quot; % % ( % s ) s &quot; % name ) , name ) ) )
walk _ to _ end ( ch , pattern _ iter )
else :
ch , escaped = next ( pattern _ iter )
if ch in &quot; iLmsu # &quot; :
walk _ to _ end ( ch , pattern _ iter )
elif ch = = &apos; : &apos; :
non _ capturing _ groups . append ( len ( result ) )
elif ch ! = &apos; P &apos; :
raise ValueError ( &quot; Non-reversible reg-exp portion : &apos; ( ? % s &apos; &quot; % ch )
else :
ch , escaped = next ( pattern _ iter )
if ch not in ( &apos; &lt; &apos; , &apos; = &apos; ) :
raise ValueError ( &quot; Non-reversible reg-exp portion : &apos; ( ? p % s &apos; &quot; % ch )
if ch = = &apos; &lt; &apos; :
terminal _ char = &apos; &gt; &apos;
else :
terminal _ char = &apos; ) &apos;
name = &#91; &#93;
ch , escaped = next ( pattern _ iter )
while ch ! = terminal _ char :
name . append ( ch )
ch , escaped = next ( pattern _ iter )
param = &apos; &apos; . join ( name )
if terminal _ char ! = &apos; ) &apos; :
result . append ( Group ( ( ( &quot; % % ( % s ) s &quot; % param ) , param ) ) )
walk _ to _ end ( ch , pattern _ iter )
else :
result . append ( Group ( ( ( &quot; % % ( % s ) s &quot; % param ) , None ) ) )
elif ch in &quot; * ? + { &quot; :
count , ch = get _ quantifier ( ch , pattern _ iter )
if ch :
consume _ next = False
if count = = 0 :
if contains ( result &#91; - 1 &#93; , Group ) :
result &#91; - 1 &#93; = Choice ( &#91; None , result &#91; - 1 &#93; &#93; )
else :
result . pop ( )
elif count &gt; 1 :
result . extend ( &#91; result &#91; - 1 &#93; &#93; * ( count - 1 ) )
else :
result . append ( ch )
if consume _ next :
ch , escaped = next ( pattern _ iter )
else :
consume _ next = True
except StopIteration :
pass
except NotImplementedError :
return &#91; ( &apos; &apos; , &#91; &#93; ) &#93;
return list ( zip ( * flatten _ result ( result ) ) )
def next _ char ( input _ iter ) :
for ch in input _ iter :
if ch ! = &apos; \ \ &apos; :
yield ch , False
continue
ch = next ( input _ iter )
representative = ESCAPE _ MAPPINGS . get ( ch , ch )
if representative is None :
continue
yield representative , True
def walk _ to _ end ( ch , input _ iter ) :
if ch = = &apos; ( &apos; :
nesting = 1
else :
nesting = 0
for ch , escaped in input _ iter :
if escaped :
continue
elif ch = = &apos; ( &apos; :
nesting + = 1
elif ch = = &apos; ) &apos; :
if not nesting :
return
nesting - = 1
def get _ quantifier ( ch , input _ iter ) :
if ch in &apos; * ? + &apos; :
try :
ch2 , escaped = next ( input _ iter )
except StopIteration :
ch2 = None
if ch2 = = &apos; ? &apos; :
ch2 = None
if ch = = &apos; + &apos; :
return 1 , ch2
return 0 , ch2
quant = &#91; &#93;
while ch ! = &apos; } &apos; :
ch , escaped = next ( input _ iter )
quant . append ( ch )
quant = quant &#91; : - 1 &#93;
values = &apos; &apos; . join ( quant ) . split ( &apos; , &apos; )
try :
ch , escaped = next ( input _ iter )
except StopIteration :
ch = None
if ch = = &apos; ? &apos; :
ch = None
return int ( values &#91; 0 &#93; ) , ch
def contains ( source , inst ) :
if isinstance ( source , inst ) :
return True
if isinstance ( source , NonCapture ) :
for elt in source :
if contains ( elt , inst ) :
return True
return False
def flatten _ result ( source ) :
if source is None :
return &#91; &apos; &apos; &#93; , &#91; &#91; &#93; &#93;
if isinstance ( source , Group ) :
if source &#91; 1 &#93; is None :
params = &#91; &#93;
else :
params = &#91; source &#91; 1 &#93; &#93;
return &#91; source &#91; 0 &#93; &#93; , &#91; params &#93;
result = &#91; &apos; &apos; &#93;
result _ args = &#91; &#91; &#93; &#93;
pos = last = 0
for pos , elt in enumerate ( source ) :
if isinstance ( elt , six . string _ types ) :
continue
piece = &apos; &apos; . join ( source &#91; last : pos &#93; )
if isinstance ( elt , Group ) :
piece + = elt &#91; 0 &#93;
param = elt &#91; 1 &#93;
else :
param = None
last = pos + 1
for i in range ( len ( result ) ) :
result &#91; i &#93; + = piece
if param :
result _ args &#91; i &#93; . append ( param )
if isinstance ( elt , ( Choice , NonCapture ) ) :
if isinstance ( elt , NonCapture ) :
elt = &#91; elt &#93;
inner _ result , inner _ args = &#91; &#93; , &#91; &#93;
for item in elt :
res , args = flatten _ result ( item )
inner _ result . extend ( res )
inner _ args . extend ( args )
new _ result = &#91; &#93;
new _ args = &#91; &#93;
for item , args in zip ( result , result _ args ) :
for i _ item , i _ args in zip ( inner _ result , inner _ args ) :
new _ result . append ( item + i _ item )
new _ args . append ( args &#91; : &#93; + i _ args )
result = new _ result
result _ args = new _ args
if pos &gt; = last :
piece = &apos; &apos; . join ( source &#91; last : &#93; )
for i in range ( len ( result ) ) :
result &#91; i &#93; + = piece
return result , result _ args
from django . utils . functional import curry , Promise
from django . utils import six
class EscapeData ( object ) :
pass
class EscapeBytes ( bytes , EscapeData ) :
pass
class EscapeText ( six . text _ type , EscapeData ) :
pass
if six . PY3 :
EscapeString = EscapeText
else :
EscapeString = EscapeBytes
EscapeUnicode = EscapeText
class SafeData ( object ) :
def _ _ html _ _ ( self ) :
return self
class SafeBytes ( bytes , SafeData ) :
def _ _ add _ _ ( self , rhs ) :
t = super ( SafeBytes , self ) . _ _ add _ _ ( rhs )
if isinstance ( rhs , SafeText ) :
return SafeText ( t )
elif isinstance ( rhs , SafeBytes ) :
return SafeBytes ( t )
return t
def _ proxy _ method ( self , * args , * * kwargs ) :
method = kwargs . pop ( &apos; method &apos; )
data = method ( self , * args , * * kwargs )
if isinstance ( data , bytes ) :
return SafeBytes ( data )
else :
return SafeText ( data )
decode = curry ( _ proxy _ method , method = bytes . decode )
class SafeText ( six . text _ type , SafeData ) :
def _ _ add _ _ ( self , rhs ) :
t = super ( SafeText , self ) . _ _ add _ _ ( rhs )
if isinstance ( rhs , SafeData ) :
return SafeText ( t )
return t
def _ proxy _ method ( self , * args , * * kwargs ) :
method = kwargs . pop ( &apos; method &apos; )
data = method ( self , * args , * * kwargs )
if isinstance ( data , bytes ) :
return SafeBytes ( data )
else :
return SafeText ( data )
encode = curry ( _ proxy _ method , method = six . text _ type . encode )
if six . PY3 :
SafeString = SafeText
else :
SafeString = SafeBytes
SafeUnicode = SafeText
def mark _ safe ( s ) :
if isinstance ( s , SafeData ) :
return s
if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _ delegate _ bytes ) :
return SafeBytes ( s )
if isinstance ( s , ( six . text _ type , Promise ) ) :
return SafeText ( s )
return SafeString ( str ( s ) )
def mark _ for _ escaping ( s ) :
if isinstance ( s , ( SafeData , EscapeData ) ) :
return s
if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _ delegate _ bytes ) :
return EscapeBytes ( s )
if isinstance ( s , ( six . text _ type , Promise ) ) :
return EscapeText ( s )
return EscapeBytes ( bytes ( s ) )
import operator
import sys
import types
_ _ author _ _ = &quot; Benjamin Peterson &lt; benjamin @ python.org &gt; &quot;
_ _ version _ _ = &quot; 1.6.1 &quot;
PY2 = sys . version _ info &#91; 0 &#93; = = 2
PY3 = sys . version _ info &#91; 0 &#93; = = 3
if PY3 :
string _ types = str ,
integer _ types = int ,
class _ types = type ,
text _ type = str
binary _ type = bytes
maxsize = sys . maxsize
else :
string _ types = basestring ,
integer _ types = ( int , long )
class _ types = ( type , types . ClassType )
text _ type = unicode
binary _ type = str
if sys . platform . startswith ( &quot; java &quot; ) :
maxsize = int ( ( 1 &lt; &lt; 31 ) - 1 )
else :
class X ( object ) :
def _ _ len _ _ ( self ) :
return 1 &lt; &lt; 31
try :
len ( X ( ) )
except OverflowError :
maxsize = int ( ( 1 &lt; &lt; 31 ) - 1 )
else :
maxsize = int ( ( 1 &lt; &lt; 63 ) - 1 )
del X
def _ add _ doc ( func , doc ) :
func . _ _ doc _ _ = doc
def _ import _ module ( name ) :
_ _ import _ _ ( name )
return sys . modules &#91; name &#93;
class _ LazyDescr ( object ) :
def _ _ init _ _ ( self , name ) :
self . name = name
def _ _ get _ _ ( self , obj , tp ) :
try :
result = self . _ resolve ( )
except ImportError :
raise AttributeError ( &quot; % s could not be imported &quot; % self . name )
setattr ( obj , self . name , result )
delattr ( obj . _ _ class _ _ , self . name )
return result
class MovedModule ( _ LazyDescr ) :
def _ _ init _ _ ( self , name , old , new = None ) :
super ( MovedModule , self ) . _ _ init _ _ ( name )
if PY3 :
if new is None :
new = name
self . mod = new
else :
self . mod = old
def _ resolve ( self ) :
return _ import _ module ( self . mod )
def _ _ getattr _ _ ( self , attr ) :
if ( attr in ( &quot; _ _ file _ _ &quot; , &quot; _ _ name _ _ &quot; , &quot; _ _ path _ _ &quot; ) and self . mod not in sys . modules ) :
raise AttributeError ( attr )
try :
_ module = self . _ resolve ( )
except ImportError :
raise AttributeError ( attr )
value = getattr ( _ module , attr )
setattr ( self , attr , value )
return value
class _ LazyModule ( types . ModuleType ) :
def _ _ init _ _ ( self , name ) :
super ( _ LazyModule , self ) . _ _ init _ _ ( name )
self . _ _ doc _ _ = self . _ _ class _ _ . _ _ doc _ _
def _ _ dir _ _ ( self ) :
attrs = &#91; &quot; _ _ doc _ _ &quot; , &quot; _ _ name _ _ &quot; &#93;
attrs + = &#91; attr . name for attr in self . _ moved _ attributes &#93;
return attrs
_ moved _ attributes = &#91; &#93;
class MovedAttribute ( _ LazyDescr ) :
def _ _ init _ _ ( self , name , old _ mod , new _ mod , old _ attr = None , new _ attr = None ) :
super ( MovedAttribute , self ) . _ _ init _ _ ( name )
if PY3 :
if new _ mod is None :
new _ mod = name
self . mod = new _ mod
if new _ attr is None :
if old _ attr is None :
new _ attr = name
else :
new _ attr = old _ attr
self . attr = new _ attr
else :
self . mod = old _ mod
if old _ attr is None :
old _ attr = name
self . attr = old _ attr
def _ resolve ( self ) :
module = _ import _ module ( self . mod )
return getattr ( module , self . attr )
class _ MovedItems ( _ LazyModule ) :
_ moved _ attributes = &#91; MovedAttribute ( &quot; cStringIO &quot; , &quot; cStringIO &quot; , &quot; io &quot; , &quot; StringIO &quot; ) , MovedAttribute ( &quot; filter &quot; , &quot; itertools &quot; , &quot; builtins &quot; , &quot; ifilter &quot; , &quot; filter &quot; ) , MovedAttribute ( &quot; filterfalse &quot; , &quot; itertools &quot; , &quot; itertools &quot; , &quot; ifilterfalse &quot; , &quot; filterfalse &quot; ) , MovedAttribute ( &quot; input &quot; , &quot; _ _ builtin _ _ &quot; , &quot; builtins &quot; , &quot; raw _ input &quot; , &quot; input &quot; ) , MovedAttribute ( &quot; map &quot; , &quot; itertools &quot; , &quot; builtins &quot; , &quot; imap &quot; , &quot; map &quot; ) , MovedAttribute ( &quot; range &quot; , &quot; _ _ builtin _ _ &quot; , &quot; builtins &quot; , &quot; xrange &quot; , &quot; range &quot; ) , MovedAttribute ( &quot; reload _ module &quot; , &quot; _ _ builtin _ _ &quot; , &quot; imp &quot; , &quot; reload &quot; ) , MovedAttribute ( &quot; reduce &quot; , &quot; _ _ builtin _ _ &quot; , &quot; functools &quot; ) , MovedAttribute ( &quot; StringIO &quot; , &quot; StringIO &quot; , &quot; io &quot; ) , MovedAttribute ( &quot; UserString &quot; , &quot; UserString &quot; , &quot; collections &quot; ) , MovedAttribute ( &quot; xrange &quot; , &quot; _ _ builtin _ _ &quot; , &quot; builtins &quot; , &quot; xrange &quot; , &quot; range &quot; ) , MovedAttribute ( &quot; zip &quot; , &quot; itertools &quot; , &quot; builtins &quot; , &quot; izip &quot; , &quot; zip &quot; ) , MovedAttribute ( &quot; zip _ longest &quot; , &quot; itertools &quot; , &quot; itertools &quot; , &quot; izip _ longest &quot; , &quot; zip _ longest &quot; ) , MovedModule ( &quot; builtins &quot; , &quot; _ _ builtin _ _ &quot; ) , MovedModule ( &quot; configparser &quot; , &quot; ConfigParser &quot; ) , MovedModule ( &quot; copyreg &quot; , &quot; copy _ reg &quot; ) , MovedModule ( &quot; dbm _ gnu &quot; , &quot; gdbm &quot; , &quot; dbm.gnu &quot; ) , MovedModule ( &quot; http _ cookiejar &quot; , &quot; cookielib &quot; , &quot; http.cookiejar &quot; ) , MovedModule ( &quot; http _ cookies &quot; , &quot; cookie &quot; , &quot; http.cookies &quot; ) , MovedModule ( &quot; html _ entities &quot; , &quot; htmlentitydefs &quot; , &quot; html.entities &quot; ) , MovedModule ( &quot; html _ parser &quot; , &quot; HTMLParser &quot; , &quot; html.parser &quot; ) , MovedModule ( &quot; http _ client &quot; , &quot; httplib &quot; , &quot; http.client &quot; ) , MovedModule ( &quot; email _ mime _ multipart &quot; , &quot; email.MIMEMultipart &quot; , &quot; email.mime.multipart &quot; ) , MovedModule ( &quot; email _ mime _ text &quot; , &quot; email.MIMEText &quot; , &quot; email.mime.text &quot; ) , MovedModule ( &quot; email _ mime _ base &quot; , &quot; email.MIMEBase &quot; , &quot; email.mime.base &quot; ) , MovedModule ( &quot; BaseHTTPServer &quot; , &quot; BaseHTTPServer &quot; , &quot; http.server &quot; ) , MovedModule ( &quot; CGIHTTPServer &quot; , &quot; CGIHTTPServer &quot; , &quot; http.server &quot; ) , MovedModule ( &quot; SimpleHTTPServer &quot; , &quot; SimpleHTTPServer &quot; , &quot; http.server &quot; ) , MovedModule ( &quot; cPickle &quot; , &quot; cPickle &quot; , &quot; pickle &quot; ) , MovedModule ( &quot; queue &quot; , &quot; queue &quot; ) , MovedModule ( &quot; reprlib &quot; , &quot; repr &quot; ) , MovedModule ( &quot; socketserver &quot; , &quot; socketserver &quot; ) , MovedModule ( &quot; _ thread &quot; , &quot; thread &quot; , &quot; _ thread &quot; ) , MovedModule ( &quot; tkinter &quot; , &quot; Tkinter &quot; ) , MovedModule ( &quot; tkinter _ dialog &quot; , &quot; Dialog &quot; , &quot; tkinter.dialog &quot; ) , MovedModule ( &quot; tkinter _ filedialog &quot; , &quot; FileDialog &quot; , &quot; tkinter.filedialog &quot; ) , MovedModule ( &quot; tkinter _ scrolledtext &quot; , &quot; ScrolledText &quot; , &quot; tkinter.scrolledtext &quot; ) , MovedModule ( &quot; tkinter _ simpledialog &quot; , &quot; SimpleDialog &quot; , &quot; tkinter.simpledialog &quot; ) , MovedModule ( &quot; tkinter _ tix &quot; , &quot; Tix &quot; , &quot; tkinter.tix &quot; ) , MovedModule ( &quot; tkinter _ ttk &quot; , &quot; ttk &quot; , &quot; tkinter.ttk &quot; ) , MovedModule ( &quot; tkinter _ constants &quot; , &quot; Tkconstants &quot; , &quot; tkinter.constants &quot; ) , MovedModule ( &quot; tkinter _ dnd &quot; , &quot; Tkdnd &quot; , &quot; tkinter.dnd &quot; ) , MovedModule ( &quot; tkinter _ colorchooser &quot; , &quot; tkColorChooser &quot; , &quot; tkinter.colorchooser &quot; ) , MovedModule ( &quot; tkinter _ commondialog &quot; , &quot; tkCommonDialog &quot; , &quot; tkinter.commondialog &quot; ) , MovedModule ( &quot; tkinter _ tkfiledialog &quot; , &quot; tkFileDialog &quot; , &quot; tkinter.filedialog &quot; ) , MovedModule ( &quot; tkinter _ font &quot; , &quot; tkFont &quot; , &quot; tkinter.font &quot; ) , MovedModule ( &quot; tkinter _ messagebox &quot; , &quot; tkMessageBox &quot; , &quot; tkinter.messagebox &quot; ) , MovedModule ( &quot; tkinter _ tksimpledialog &quot; , &quot; tkSimpleDialog &quot; , &quot; tkinter.simpledialog &quot; ) , MovedModule ( &quot; urllib _ parse &quot; , _ _ name _ _ + &quot; .moves.urllib _ parse &quot; , &quot; urllib.parse &quot; ) , MovedModule ( &quot; urllib _ error &quot; , _ _ name _ _ + &quot; .moves.urllib _ error &quot; , &quot; urllib.error &quot; ) , MovedModule ( &quot; urllib &quot; , _ _ name _ _ + &quot; .moves.urllib &quot; , _ _ name _ _ + &quot; .moves.urllib &quot; ) , MovedModule ( &quot; urllib _ robotparser &quot; , &quot; robotparser &quot; , &quot; urllib.robotparser &quot; ) , MovedModule ( &quot; xmlrpc _ client &quot; , &quot; xmlrpclib &quot; , &quot; xmlrpc.client &quot; ) , MovedModule ( &quot; xmlrpc _ server &quot; , &quot; xmlrpclib &quot; , &quot; xmlrpc.server &quot; ) , MovedModule ( &quot; winreg &quot; , &quot; _ winreg &quot; ) , &#93;
for attr in _ moved _ attributes :
setattr ( _ MovedItems , attr . name , attr )
if isinstance ( attr , MovedModule ) :
sys . modules &#91; _ _ name _ _ + &quot; .moves. &quot; + attr . name &#93; = attr
del attr
_ MovedItems . _ moved _ attributes = _ moved _ attributes
moves = sys . modules &#91; _ _ name _ _ + &quot; .moves &quot; &#93; = _ MovedItems ( _ _ name _ _ + &quot; .moves &quot; )
class Module _ six _ moves _ urllib _ parse ( _ LazyModule ) :
_ urllib _ parse _ moved _ attributes = &#91; MovedAttribute ( &quot; ParseResult &quot; , &quot; urlparse &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; SplitResult &quot; , &quot; urlparse &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; parse _ qs &quot; , &quot; urlparse &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; parse _ qsl &quot; , &quot; urlparse &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; urldefrag &quot; , &quot; urlparse &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; urljoin &quot; , &quot; urlparse &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; urlparse &quot; , &quot; urlparse &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; urlsplit &quot; , &quot; urlparse &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; urlunparse &quot; , &quot; urlparse &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; urlunsplit &quot; , &quot; urlparse &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; quote &quot; , &quot; urllib &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; quote _ plus &quot; , &quot; urllib &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; unquote &quot; , &quot; urllib &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; unquote _ plus &quot; , &quot; urllib &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; urlencode &quot; , &quot; urllib &quot; , &quot; urllib.parse &quot; ) , MovedAttribute ( &quot; splitquery &quot; , &quot; urllib &quot; , &quot; urllib.parse &quot; ) , &#93;
for attr in _ urllib _ parse _ moved _ attributes :
setattr ( Module _ six _ moves _ urllib _ parse , attr . name , attr )
del attr
module _ six _ moves _ urllib _ parse . _ moved _ attributes = _ urllib _ parse _ moved _ attributes
sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib _ parse &quot; &#93; = sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib.parse &quot; &#93; = Module _ six _ moves _ urllib _ parse ( _ _ name _ _ + &quot; .moves.urllib _ parse &quot; )
class Module _ six _ moves _ urllib _ error ( _ LazyModule ) :
_ urllib _ error _ moved _ attributes = &#91; MovedAttribute ( &quot; URLError &quot; , &quot; urllib2 &quot; , &quot; urllib.error &quot; ) , MovedAttribute ( &quot; HTTPError &quot; , &quot; urllib2 &quot; , &quot; urllib.error &quot; ) , MovedAttribute ( &quot; ContentTooShortError &quot; , &quot; urllib &quot; , &quot; urllib.error &quot; ) , &#93;
for attr in _ urllib _ error _ moved _ attributes :
setattr ( Module _ six _ moves _ urllib _ error , attr . name , attr )
del attr
module _ six _ moves _ urllib _ error . _ moved _ attributes = _ urllib _ error _ moved _ attributes
sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib _ error &quot; &#93; = sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib.error &quot; &#93; = Module _ six _ moves _ urllib _ error ( _ _ name _ _ + &quot; .moves.urllib.error &quot; )
class Module _ six _ moves _ urllib _ request ( _ LazyModule ) :
_ urllib _ request _ moved _ attributes = &#91; MovedAttribute ( &quot; urlopen &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; install _ opener &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; build _ opener &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; pathname2url &quot; , &quot; urllib &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; url2pathname &quot; , &quot; urllib &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; getproxies &quot; , &quot; urllib &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; Request &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; OpenerDirector &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; HTTPDefaultErrorHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; HTTPRedirectHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; HTTPCookieProcessor &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; ProxyHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; BaseHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; HTTPPasswordMgr &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; HTTPPasswordMgrWithDefaultRealm &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; AbstractBasicAuthHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; HTTPBasicAuthHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; ProxyBasicAuthHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; AbstractDigestAuthHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; HTTPDigestAuthHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; ProxyDigestAuthHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; HTTPHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; HTTPSHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; FileHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; FTPHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; CacheFTPHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; UnknownHandler &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; HTTPErrorProcessor &quot; , &quot; urllib2 &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; urlretrieve &quot; , &quot; urllib &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; urlcleanup &quot; , &quot; urllib &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; URLopener &quot; , &quot; urllib &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; FancyURLopener &quot; , &quot; urllib &quot; , &quot; urllib.request &quot; ) , MovedAttribute ( &quot; proxy _ bypass &quot; , &quot; urllib &quot; , &quot; urllib.request &quot; ) , &#93;
for attr in _ urllib _ request _ moved _ attributes :
setattr ( Module _ six _ moves _ urllib _ request , attr . name , attr )
del attr
module _ six _ moves _ urllib _ request . _ moved _ attributes = _ urllib _ request _ moved _ attributes
sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib _ request &quot; &#93; = sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib.request &quot; &#93; = Module _ six _ moves _ urllib _ request ( _ _ name _ _ + &quot; .moves.urllib.request &quot; )
class Module _ six _ moves _ urllib _ response ( _ LazyModule ) :
_ urllib _ response _ moved _ attributes = &#91; MovedAttribute ( &quot; addbase &quot; , &quot; urllib &quot; , &quot; urllib.response &quot; ) , MovedAttribute ( &quot; addclosehook &quot; , &quot; urllib &quot; , &quot; urllib.response &quot; ) , MovedAttribute ( &quot; addinfo &quot; , &quot; urllib &quot; , &quot; urllib.response &quot; ) , MovedAttribute ( &quot; addinfourl &quot; , &quot; urllib &quot; , &quot; urllib.response &quot; ) , &#93;
for attr in _ urllib _ response _ moved _ attributes :
setattr ( Module _ six _ moves _ urllib _ response , attr . name , attr )
del attr
module _ six _ moves _ urllib _ response . _ moved _ attributes = _ urllib _ response _ moved _ attributes
sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib _ response &quot; &#93; = sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib.response &quot; &#93; = Module _ six _ moves _ urllib _ response ( _ _ name _ _ + &quot; .moves.urllib.response &quot; )
class Module _ six _ moves _ urllib _ robotparser ( _ LazyModule ) :
_ urllib _ robotparser _ moved _ attributes = &#91; MovedAttribute ( &quot; RobotFileParser &quot; , &quot; robotparser &quot; , &quot; urllib.robotparser &quot; ) , &#93;
for attr in _ urllib _ robotparser _ moved _ attributes :
setattr ( Module _ six _ moves _ urllib _ robotparser , attr . name , attr )
del attr
module _ six _ moves _ urllib _ robotparser . _ moved _ attributes = _ urllib _ robotparser _ moved _ attributes
sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib _ robotparser &quot; &#93; = sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib.robotparser &quot; &#93; = Module _ six _ moves _ urllib _ robotparser ( _ _ name _ _ + &quot; .moves.urllib.robotparser &quot; )
class Module _ six _ moves _ urllib ( types . ModuleType ) :
parse = sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib _ parse &quot; &#93;
error = sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib _ error &quot; &#93;
request = sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib _ request &quot; &#93;
response = sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib _ response &quot; &#93;
robotparser = sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib _ robotparser &quot; &#93;
def _ _ dir _ _ ( self ) :
return &#91; &apos; parse &apos; , &apos; error &apos; , &apos; request &apos; , &apos; response &apos; , &apos; robotparser &apos; &#93;
sys . modules &#91; _ _ name _ _ + &quot; .moves.urllib &quot; &#93; = Module _ six _ moves _ urllib ( _ _ name _ _ + &quot; .moves.urllib &quot; )
def add _ move ( move ) :
setattr ( _ MovedItems , move . name , move )
def remove _ move ( name ) :
try :
delattr ( _ MovedItems , name )
except AttributeError :
try :
del moves . _ _ dict _ _ &#91; name &#93;
except KeyError :
raise AttributeError ( &quot; no such move , % r &quot; % ( name , ) )
if PY3 :
_ meth _ func = &quot; _ _ func _ _ &quot;
_ meth _ self = &quot; _ _ self _ _ &quot;
_ func _ closure = &quot; _ _ closure _ _ &quot;
_ func _ code = &quot; _ _ code _ _ &quot;
_ func _ defaults = &quot; _ _ defaults _ _ &quot;
_ func _ globals = &quot; _ _ globals _ _ &quot;
_ iterkeys = &quot; keys &quot;
_ itervalues = &quot; values &quot;
_ iteritems = &quot; items &quot;
_ iterlists = &quot; lists &quot;
else :
_ meth _ func = &quot; im _ func &quot;
_ meth _ self = &quot; im _ self &quot;
_ func _ closure = &quot; func _ closure &quot;
_ func _ code = &quot; func _ code &quot;
_ func _ defaults = &quot; func _ defaults &quot;
_ func _ globals = &quot; func _ globals &quot;
_ iterkeys = &quot; iterkeys &quot;
_ itervalues = &quot; itervalues &quot;
_ iteritems = &quot; iteritems &quot;
_ iterlists = &quot; iterlists &quot;
try :
advance _ iterator = next
except NameError :
def advance _ iterator ( it ) :
return it . next ( )
next = advance _ iterator
try :
callable = callable
except NameError :
def callable ( obj ) :
return any ( &quot; _ _ call _ _ &quot; in klass . _ _ dict _ _ for klass in type ( obj ) . _ _ mro _ _ )
if PY3 :
def get _ unbound _ function ( unbound ) :
return unbound
create _ bound _ method = types . MethodType
iterator = object
else :
def get _ unbound _ function ( unbound ) :
return unbound . im _ func
def create _ bound _ method ( func , obj ) :
return types . MethodType ( func , obj , obj . _ _ class _ _ )
class Iterator ( object ) :
def next ( self ) :
return type ( self ) . _ _ next _ _ ( self )
callable = callable
_ add _ doc ( get _ unbound _ function , &quot; &quot; &quot; Get the function out of a possibly unbound function &quot; &quot; &quot; )
get _ method _ function = operator . attrgetter ( _ meth _ func )
get _ method _ self = operator . attrgetter ( _ meth _ self )
get _ function _ closure = operator . attrgetter ( _ func _ closure )
get _ function _ code = operator . attrgetter ( _ func _ code )
get _ function _ defaults = operator . attrgetter ( _ func _ defaults )
get _ function _ globals = operator . attrgetter ( _ func _ globals )
def iterkeys ( d , * * kw ) :
return iter ( getattr ( d , _ iterkeys ) ( * * kw ) )
def itervalues ( d , * * kw ) :
return iter ( getattr ( d , _ itervalues ) ( * * kw ) )
def iteritems ( d , * * kw ) :
return iter ( getattr ( d , _ iteritems ) ( * * kw ) )
def iterlists ( d , * * kw ) :
return iter ( getattr ( d , _ iterlists ) ( * * kw ) )
if PY3 :
def b ( s ) :
return s . encode ( &quot; latin-1 &quot; )
def u ( s ) :
return s
unichr = chr
if sys . version _ info &#91; 1 &#93; &lt; = 1 :
def int2byte ( i ) :
return bytes ( ( i , ) )
else :
int2byte = operator . methodcaller ( &quot; to _ bytes &quot; , 1 , &quot; big &quot; )
byte2int = operator . itemgetter ( 0 )
indexbytes = operator . getitem
iterbytes = iter
import io
StringIO = io . StringIO
BytesIO = io . BytesIO
else :
def b ( s ) :
return s
def u ( s ) :
return unicode ( s . replace ( r &apos; \ \ &apos; , r &apos; \ \ \ \ &apos; ) , &quot; unicode _ escape &quot; )
unichr = unichr
int2byte = chr
def byte2int ( bs ) :
return ord ( bs &#91; 0 &#93; )
def indexbytes ( buf , i ) :
return ord ( buf &#91; i &#93; )
def iterbytes ( buf ) :
return ( ord ( byte ) for byte in buf )
import StringIO
StringIO = BytesIO = StringIO . StringIO
_ add _ doc ( b , &quot; &quot; &quot; Byte literal &quot; &quot; &quot; )
_ add _ doc ( u , &quot; &quot; &quot; Text literal &quot; &quot; &quot; )
if PY3 :
exec _ = getattr ( moves . builtins , &quot; exec &quot; )
def reraise ( tp , value , tb = None ) :
if value . _ _ traceback _ _ is not tb :
raise value . with _ traceback ( tb )
raise value
else :
def exec _ ( _ code _ , _ globs _ = None , _ locs _ = None ) :
if _ globs _ is None :
frame = sys . _ getframe ( 1 )
_ globs _ = frame . f _ globals
if _ locs _ is None :
_ locs _ = frame . f _ locals
del frame
elif _ locs _ is None :
_ locs _ = _ globs _
exec ( &quot; &quot; &quot; exec _ code _ in _ globs _ , _ locs _ &quot; &quot; &quot; )
exec _ ( &quot; &quot; &quot; def reraise ( tp , value , tb = None ) : raise tp , value , tb &quot; &quot; &quot; )
print _ = getattr ( moves . builtins , &quot; print &quot; , None )
if print _ is None :
def print _ ( * args , * * kwargs ) :
fp = kwargs . pop ( &quot; file &quot; , sys . stdout )
if fp is None :
return
def write ( data ) :
if not isinstance ( data , basestring ) :
data = str ( data )
if ( isinstance ( fp , file ) and isinstance ( data , unicode ) and fp . encoding is not None ) :
errors = getattr ( fp , &quot; errors &quot; , None )
if errors is None :
errors = &quot; strict &quot;
data = data . encode ( fp . encoding , errors )
fp . write ( data )
want _ unicode = False
sep = kwargs . pop ( &quot; sep &quot; , None )
if sep is not None :
if isinstance ( sep , unicode ) :
want _ unicode = True
elif not isinstance ( sep , str ) :
raise TypeError ( &quot; sep must be None or a string &quot; )
end = kwargs . pop ( &quot; end &quot; , None )
if end is not None :
if isinstance ( end , unicode ) :
want _ unicode = True
elif not isinstance ( end , str ) :
raise TypeError ( &quot; end must be None or a string &quot; )
if kwargs :
raise TypeError ( &quot; invalid keyword arguments to print ( ) &quot; )
if not want _ unicode :
for arg in args :
if isinstance ( arg , unicode ) :
want _ unicode = True
break
if want _ unicode :
newline = unicode ( &quot; \ n &quot; )
space = unicode ( &quot; &quot; )
else :
newline = &quot; \ n &quot;
space = &quot; &quot;
if sep is None :
sep = space
if end is None :
end = newline
for i , arg in enumerate ( args ) :
if i :
write ( sep )
write ( arg )
write ( end )
_ add _ doc ( reraise , &quot; &quot; &quot; Reraise an exception . &quot; &quot; &quot; )
def with _ metaclass ( meta , * bases ) :
class metaclass ( meta ) :
_ _ call _ _ = type . _ _ call _ _
_ _ init _ _ = type . _ _ init _ _
def _ _ new _ _ ( cls , name , this _ bases , d ) :
if this _ bases is None :
return type . _ _ new _ _ ( cls , name , ( ) , d )
return meta ( name , bases , d )
return metaclass ( &apos; temporary _ class &apos; , None , { } )
def add _ metaclass ( metaclass ) :
def wrapper ( cls ) :
orig _ vars = cls . _ _ dict _ _ . copy ( )
orig _ vars . pop ( &apos; _ _ dict _ _ &apos; , None )
orig _ vars . pop ( &apos; _ _ weakref _ _ &apos; , None )
slots = orig _ vars . get ( &apos; _ _ slots _ _ &apos; )
if slots is not None :
if isinstance ( slots , str ) :
slots = &#91; slots &#93;
for slots _ var in slots :
orig _ vars . pop ( slots _ var )
return metaclass ( cls . _ _ name _ _ , cls . _ _ bases _ _ , orig _ vars )
return wrapper
if PY3 :
_ assertCountEqual = &quot; assertCountEqual &quot;
_ assertRaisesRegex = &quot; assertRaisesRegex &quot;
_ assertRegex = &quot; assertRegex &quot;
memoryview = memoryview
buffer _ types = ( bytes , bytearray , memoryview )
else :
_ assertCountEqual = &quot; assertItemsEqual &quot;
_ assertRaisesRegex = &quot; assertRaisesRegexp &quot;
_ assertRegex = &quot; assertRegexpMatches &quot;
if sys . platform . startswith ( &apos; java &apos; ) :
memoryview = memoryview
else :
memoryview = buffer
buffer _ types = ( bytearray , memoryview )
def assertCountEqual ( self , * args , * * kwargs ) :
return getattr ( self , _ assertCountEqual ) ( * args , * * kwargs )
def assertRaisesRegex ( self , * args , * * kwargs ) :
return getattr ( self , _ assertRaisesRegex ) ( * args , * * kwargs )
def assertRegex ( self , * args , * * kwargs ) :
return getattr ( self , _ assertRegex ) ( * args , * * kwargs )
add _ move ( MovedModule ( &quot; _ dummy _ thread &quot; , &quot; dummy _ thread &quot; ) )
add _ move ( MovedModule ( &quot; _ thread &quot; , &quot; thread &quot; ) )
import contextlib
try :
import threading
except ImportError :
import dummy _ threading as threading
class RWLock ( object ) :
def _ _ init _ _ ( self ) :
self . mutex = threading . RLock ( )
self . can _ read = threading . Semaphore ( 0 )
self . can _ write = threading . Semaphore ( 0 )
self . active _ readers = 0
self . active _ writers = 0
self . waiting _ readers = 0
self . waiting _ writers = 0
def reader _ enters ( self ) :
with self . mutex :
if self . active _ writers = = 0 and self . waiting _ writers = = 0 :
self . active _ readers + = 1
self . can _ read . release ( )
else :
self . waiting _ readers + = 1
self . can _ read . acquire ( )
def reader _ leaves ( self ) :
with self . mutex :
self . active _ readers - = 1
if self . active _ readers = = 0 and self . waiting _ writers ! = 0 :
self . active _ writers + = 1
self . waiting _ writers - = 1
self . can _ write . release ( )
@ contextlib . contextmanager
def reader ( self ) :
self . reader _ enters ( )
try :
yield
finally :
self . reader _ leaves ( )
def writer _ enters ( self ) :
with self . mutex :
if self . active _ writers = = 0 and self . waiting _ writers = = 0 and self . active _ readers = = 0 :
self . active _ writers + = 1
self . can _ write . release ( )
else :
self . waiting _ writers + = 1
self . can _ write . acquire ( )
def writer _ leaves ( self ) :
with self . mutex :
self . active _ writers - = 1
if self . waiting _ writers ! = 0 :
self . active _ writers + = 1
self . waiting _ writers - = 1
self . can _ write . release ( )
elif self . waiting _ readers ! = 0 :
t = self . waiting _ readers
self . waiting _ readers = 0
self . active _ readers + = t
while t &gt; 0 :
self . can _ read . release ( )
t - = 1
@ contextlib . contextmanager
def writer ( self ) :
self . writer _ enters ( )
try :
yield
finally :
self . writer _ leaves ( )
from django . utils import six
color _ names = ( &apos; black &apos; , &apos; red &apos; , &apos; green &apos; , &apos; yellow &apos; , &apos; blue &apos; , &apos; magenta &apos; , &apos; cyan &apos; , &apos; white &apos; )
foreground = dict ( ( color _ names &#91; x &#93; , &apos; 3 % s &apos; % x ) for x in range ( 8 ) )
background = dict ( ( color _ names &#91; x &#93; , &apos; 4 % s &apos; % x ) for x in range ( 8 ) )
reset = &apos; 0&apos;
opt _ dict = { &apos; bold &apos; : &apos; 1&apos; , &apos; underscore &apos; : &apos; 4&apos; , &apos; blink &apos; : &apos; 5&apos; , &apos; reverse &apos; : &apos; 7&apos; , &apos; conceal &apos; : &apos; 8&apos; }
def colorize ( text = &apos; &apos; , opts = ( ) , * * kwargs ) :
code _ list = &#91; &#93;
if text = = &apos; &apos; and len ( opts ) = = 1 and opts &#91; 0 &#93; = = &apos; reset &apos; :
return &apos; \ x1b &#91; % sm &apos; % RESET
for k , v in six . iteritems ( kwargs ) :
if k = = &apos; fg &apos; :
code _ list . append ( foreground &#91; v &#93; )
elif k = = &apos; bg &apos; :
code _ list . append ( background &#91; v &#93; )
for o in opts :
if o in opt _ dict :
code _ list . append ( opt _ dict &#91; o &#93; )
if &apos; noreset &apos; not in opts :
text = &apos; % s \ x1b &#91; % sm &apos; % ( text or &apos; &apos; , RESET )
return &apos; % s % s &apos; % ( ( &apos; \ x1b &#91; % sm &apos; % &apos; ; &apos; . join ( code _ list ) ) , text or &apos; &apos; )
def make _ style ( opts = ( ) , * * kwargs ) :
return lambda text : colorize ( text , opts , * * kwargs )
NOCOLOR _ PALETTE = &apos; nocolor&apos;
DARK _ PALETTE = &apos; dark&apos;
light _ PALETTE = &apos; light&apos;
PALETTES = { NOCOLOR _ PALETTE : { &apos; ERROR &apos; : { } , &apos; WARNING &apos; : { } , &apos; Notice &apos; : { } , &apos; SQL _ FIELD &apos; : { } , &apos; SQL _ COLTYPE &apos; : { } , &apos; SQL _ KEYWORD &apos; : { } , &apos; SQL _ TABLE &apos; : { } , &apos; HTTP _ INFO &apos; : { } , &apos; HTTP _ SUCCESS &apos; : { } , &apos; HTTP _ REDIRECT &apos; : { } , &apos; HTTP _ NOT _ MODIFIED &apos; : { } , &apos; HTTP _ BAD _ REQUEST &apos; : { } , &apos; HTTP _ NOT _ FOUND &apos; : { } , &apos; HTTP _ SERVER _ ERROR &apos; : { } , &apos; migrate _ HEADING &apos; : { } , &apos; migrate _ LABEL &apos; : { } , &apos; migrate _ SUCCESS &apos; : { } , &apos; migrate _ FAILURE &apos; : { } , } , DARK _ PALETTE : { &apos; ERROR &apos; : { &apos; fg &apos; : &apos; red &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; WARNING &apos; : { &apos; fg &apos; : &apos; yellow &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; Notice &apos; : { &apos; fg &apos; : &apos; red &apos; } , &apos; SQL _ FIELD &apos; : { &apos; fg &apos; : &apos; green &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; SQL _ COLTYPE &apos; : { &apos; fg &apos; : &apos; green &apos; } , &apos; SQL _ KEYWORD &apos; : { &apos; fg &apos; : &apos; yellow &apos; } , &apos; SQL _ TABLE &apos; : { &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; HTTP _ INFO &apos; : { &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; HTTP _ SUCCESS &apos; : { } , &apos; HTTP _ REDIRECT &apos; : { &apos; fg &apos; : &apos; green &apos; } , &apos; HTTP _ NOT _ MODIFIED &apos; : { &apos; fg &apos; : &apos; cyan &apos; } , &apos; HTTP _ BAD _ REQUEST &apos; : { &apos; fg &apos; : &apos; red &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; HTTP _ NOT _ FOUND &apos; : { &apos; fg &apos; : &apos; yellow &apos; } , &apos; HTTP _ SERVER _ ERROR &apos; : { &apos; fg &apos; : &apos; magenta &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; migrate _ HEADING &apos; : { &apos; fg &apos; : &apos; cyan &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; migrate _ LABEL &apos; : { &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; migrate _ SUCCESS &apos; : { &apos; fg &apos; : &apos; green &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; migrate _ FAILURE &apos; : { &apos; fg &apos; : &apos; red &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , } , LIGHT _ PALETTE : { &apos; ERROR &apos; : { &apos; fg &apos; : &apos; red &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; WARNING &apos; : { &apos; fg &apos; : &apos; yellow &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; Notice &apos; : { &apos; fg &apos; : &apos; red &apos; } , &apos; SQL _ FIELD &apos; : { &apos; fg &apos; : &apos; green &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; SQL _ COLTYPE &apos; : { &apos; fg &apos; : &apos; green &apos; } , &apos; SQL _ KEYWORD &apos; : { &apos; fg &apos; : &apos; blue &apos; } , &apos; SQL _ TABLE &apos; : { &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; HTTP _ INFO &apos; : { &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; HTTP _ SUCCESS &apos; : { } , &apos; HTTP _ REDIRECT &apos; : { &apos; fg &apos; : &apos; green &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; HTTP _ NOT _ MODIFIED &apos; : { &apos; fg &apos; : &apos; green &apos; } , &apos; HTTP _ BAD _ REQUEST &apos; : { &apos; fg &apos; : &apos; red &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; HTTP _ NOT _ FOUND &apos; : { &apos; fg &apos; : &apos; red &apos; } , &apos; HTTP _ SERVER _ ERROR &apos; : { &apos; fg &apos; : &apos; magenta &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; migrate _ HEADING &apos; : { &apos; fg &apos; : &apos; cyan &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; migrate _ LABEL &apos; : { &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; migrate _ SUCCESS &apos; : { &apos; fg &apos; : &apos; green &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , &apos; migrate _ FAILURE &apos; : { &apos; fg &apos; : &apos; red &apos; , &apos; opts &apos; : ( &apos; bold &apos; , ) } , } }
default _ PALETTE = DARK _ PALETTE
def parse _ color _ setting ( config _ string ) :
if not config _ string :
return PALETTES &#91; DEFAULT _ PALETTE &#93;
parts = config _ string . lower ( ) . split ( &apos; ; &apos; )
PALETTE = PALETTES &#91; NOCOLOR _ PALETTE &#93; . copy ( )
for part in parts :
if part in PALETTES :
PALETTE . update ( PALETTES &#91; part &#93; )
elif &apos; = &apos; in part :
definition = { }
role , instructions = part . split ( &apos; = &apos; )
role = role . upper ( )
styles = instructions . split ( &apos; , &apos; )
styles . reverse ( )
colors = styles . pop ( ) . split ( &apos; / &apos; )
colors . reverse ( )
fg = colors . pop ( )
if fg in color _ names :
definition &#91; &apos; fg &apos; &#93; = fg
if colors and colors &#91; - 1 &#93; in color _ names :
definition &#91; &apos; bg &apos; &#93; = colors &#91; - 1 &#93;
opts = tuple ( s for s in styles if s in opt _ dict . keys ( ) )
if opts :
definition &#91; &apos; opts &apos; &#93; = opts
if role in PALETTES &#91; NOCOLOR _ PALETTE &#93; and definition :
PALETTE &#91; role &#93; = definition
if palette = = PALETTES &#91; NOCOLOR _ PALETTE &#93; :
return None
return palette
from _ _ future _ _ import unicode _ literals
import re
import unicodedata
from gzip import GzipFile
from io import BytesIO
import warnings
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import force _ text
from django . utils . functional import allow _ lazy , SimpleLazyObject
from django . utils import six
from django . utils . six . moves import html _ entities
from django . utils . translation import ugettext _ lazy , ugettext as _ , pgettext
from django . utils . SafeString import mark _ safe
if six . PY2 :
from django . utils . encoding import force _ unicode
capfirst = lambda x : x and force _ text ( x ) &#91; 0 &#93; . upper ( ) + force _ text ( x ) &#91; 1 : &#93;
capfirst = allow _ lazy ( capfirst , six . text _ type )
re _ words = re . compile ( r &apos; &lt; . * ? &gt; &#124; ( ( ? : \ w &#91; - \ w &#93; * &#124; &amp; . * ? ; ) + ) &apos; , re . u &#124; re . s )
re _ chars = re . compile ( r &apos; &lt; . * ? &gt; &#124; ( . ) &apos; , re . u &#124; re . s )
re _ tag = re . compile ( r &apos; &lt; ( / ) ? ( &#91; ^ &#93; + ? ) ( ? : ( \ s * / ) &#124; . * ? ) ? &gt; &apos; , re . s )
re _ newlines = re . compile ( r &apos; \ r \ n &#124; \ r &apos; )
re _ camel _ case = re . compile ( r &apos; ( ( ( ? &lt; = &#91; a-z &#93; ) &#91; A-Z &#93; ) &#124; ( &#91; A-Z &#93; ( ? ! &#91; A-Z &#93; &#124; $ ) ) ) &apos; )
def wrap ( text , width ) :
text = force _ text ( text )
def _ generator ( ) :
for line in text . splitlines ( True ) :
max _ width = min ( ( line . endswith ( &apos; \ n &apos; ) and width + 1 or width ) , width )
while len ( line ) &gt; max _ width :
space = line &#91; : max _ width + 1 &#93; . rfind ( &apos; &apos; ) + 1
if space = = 0 :
space = line . find ( &apos; &apos; ) + 1
if space = = 0 :
yield line
line = &apos; &apos;
break
yield &apos; % s \ n &apos; % line &#91; : space - 1 &#93;
line = line &#91; space : &#93;
max _ width = min ( ( line . endswith ( &apos; \ n &apos; ) and width + 1 or width ) , width )
if line :
yield line
return &apos; &apos; . join ( _ generator ( ) )
wrap = allow _ lazy ( wrap , six . text _ type )
class Truncator ( SimpleLazyObject ) :
def _ _ init _ _ ( self , text ) :
super ( Truncator , self ) . _ _ init _ _ ( lambda : force _ text ( text ) )
def add _ truncation _ text ( self , text , truncate = None ) :
if truncate is None :
truncate = pgettext ( &apos; String to return when truncating text &apos; , &apos; % ( truncated _ text ) s ... &apos; )
truncate = force _ text ( truncate )
if &apos; % ( truncated _ text ) s &apos; in truncate :
return truncate % { &apos; truncated _ text &apos; : text }
if text . endswith ( truncate ) :
return text
return &apos; % s % s &apos; % ( text , truncate )
def chars ( self , num , truncate = None , html = False ) :
length = int ( num )
text = unicodedata . normalize ( &apos; NFC &apos; , self . _ wrapped )
truncate _ len = length
for char in self . add _ truncation _ text ( &apos; &apos; , truncate ) :
if not unicodedata . combining ( char ) :
truncate _ len - = 1
if truncate _ len = = 0 :
break
if html :
return self . _ truncate _ html ( length , truncate , text , truncate _ len , False )
return self . _ text _ chars ( length , truncate , text , truncate _ len )
chars = allow _ lazy ( chars )
def _ text _ chars ( self , length , truncate , text , truncate _ len ) :
s _ len = 0
end _ index = None
for i , char in enumerate ( text ) :
if unicodedata . combining ( char ) :
continue
s _ len + = 1
if end _ index is None and s _ len &gt; truncate _ len :
end _ index = i
if s _ len &gt; length :
return self . add _ truncation _ text ( text &#91; : end _ index or 0 &#93; , truncate )
return text
def words ( self , num , truncate = None , html = False ) :
length = int ( num )
if html :
return self . _ truncate _ html ( length , truncate , self . _ wrapped , length , True )
return self . _ text _ words ( length , truncate )
words = allow _ lazy ( words )
def _ text _ words ( self , length , truncate ) :
words = self . _ wrapped . split ( )
if len ( words ) &gt; length :
words = words &#91; : length &#93;
return self . add _ truncation _ text ( &apos; &apos; . join ( words ) , truncate )
return &apos; &apos; . join ( words )
def _ truncate _ html ( self , length , truncate , text , truncate _ len , words ) :
if words and length &lt; = 0 :
return &apos; &apos;
html4 _ singlets = ( &apos; br &apos; , &apos; col &apos; , &apos; link &apos; , &apos; base &apos; , &apos; img &apos; , &apos; param &apos; , &apos; area &apos; , &apos; hr &apos; , &apos; input &apos; )
pos = 0
end _ text _ pos = 0
current _ len = 0
open _ tags = &#91; &#93;
regex = re _ words if words else re _ chars
while current _ len &lt; = length :
m = regex . search ( text , pos )
if not m :
break
pos = m . end ( 0 )
if m . Group ( 1 ) :
current _ len + = 1
if current _ len = = truncate _ len :
end _ text _ pos = pos
continue
tag = re _ tag . match ( m . Group ( 0 ) )
if not tag or current _ len &gt; = truncate _ len :
continue
closing _ tag , tagname , self _ closing = tag . groups ( )
tagname = tagname . lower ( )
if self _ closing or tagname in html4 _ singlets :
pass
elif closing _ tag :
try :
i = open _ tags . index ( tagname )
except ValueError :
pass
else :
open _ tags = open _ tags &#91; i + 1 : &#93;
else :
open _ tags . insert ( 0 , tagname )
if current _ len &lt; = length :
return text
out = text &#91; : end _ text _ pos &#93;
truncate _ text = self . add _ truncation _ text ( &apos; &apos; , truncate )
if truncate _ text :
out + = truncate _ text
for tag in open _ tags :
out + = &apos; &lt; / % s &gt; &apos; % tag
return out
def get _ valid _ filename ( s ) :
s = force _ text ( s ) . strip ( ) . replace ( &apos; &apos; , &apos; _ &apos; )
return re . sub ( r &apos; ( ? u ) &#91; ^ - \ w . &#93; &apos; , &apos; &apos; , s )
get _ valid _ filename = allow _ lazy ( get _ valid _ filename , six . text _ type )
def get _ text _ list ( list _ , last _ word = ugettext _ lazy ( &apos; or &apos; ) ) :
if len ( list _ ) = = 0 :
return &apos; &apos;
if len ( list _ ) = = 1 :
return force _ text ( list _ &#91; 0 &#93; )
return &apos; % s % s % s &apos; % ( _ ( &apos; , &apos; ) . join ( force _ text ( i ) for i in list _ &#91; : - 1 &#93; ) , force _ text ( last _ word ) , force _ text ( list _ &#91; - 1 &#93; ) )
get _ text _ list = allow _ lazy ( get _ text _ list , six . text _ type )
def normalize _ newlines ( text ) :
text = force _ text ( text )
return re _ newlines . sub ( &apos; \ n &apos; , text )
normalize _ newlines = allow _ lazy ( normalize _ newlines , six . text _ type )
def phone2numeric ( phone ) :
char2number = { &apos; a &apos; : &apos; 2&apos; , &apos; b &apos; : &apos; 2&apos; , &apos; c &apos; : &apos; 2&apos; , &apos; d &apos; : &apos; 3&apos; , &apos; e &apos; : &apos; 3&apos; , &apos; f &apos; : &apos; 3&apos; , &apos; g &apos; : &apos; 4&apos; , &apos; h &apos; : &apos; 4&apos; , &apos; i &apos; : &apos; 4&apos; , &apos; j &apos; : &apos; 5&apos; , &apos; k &apos; : &apos; 5&apos; , &apos; l &apos; : &apos; 5&apos; , &apos; m &apos; : &apos; 6&apos; , &apos; n &apos; : &apos; 6&apos; , &apos; o &apos; : &apos; 6&apos; , &apos; p &apos; : &apos; 7&apos; , &apos; q &apos; : &apos; 7&apos; , &apos; r &apos; : &apos; 7&apos; , &apos; s &apos; : &apos; 7&apos; , &apos; t &apos; : &apos; 8&apos; , &apos; u &apos; : &apos; 8&apos; , &apos; v &apos; : &apos; 8&apos; , &apos; w &apos; : &apos; 9&apos; , &apos; x &apos; : &apos; 9&apos; , &apos; y &apos; : &apos; 9&apos; , &apos; z &apos; : &apos; 9&apos; }
return &apos; &apos; . join ( char2number . get ( c , c ) for c in phone . lower ( ) )
phone2numeric = allow _ lazy ( phone2numeric )
def compress _ string ( s ) :
zbuf = BytesIO ( )
zfile = GzipFile ( mode = &apos; wb &apos; , compresslevel = 6 , fileobj = zbuf )
zfile . write ( s )
zfile . close ( )
return zbuf . getvalue ( )
class StreamingBuffer ( object ) :
def _ _ init _ _ ( self ) :
self . vals = &#91; &#93;
def write ( self , val ) :
self . vals . append ( val )
def read ( self ) :
ret = b &apos; &apos; . join ( self . vals )
self . vals = &#91; &#93;
return ret
def flush ( self ) :
return
def close ( self ) :
return
def compress _ sequence ( sequence ) :
buf = StreamingBuffer ( )
zfile = GzipFile ( mode = &apos; wb &apos; , compresslevel = 6 , fileobj = buf )
yield buf . read ( )
for item in sequence :
zfile . write ( item )
zfile . flush ( )
yield buf . read ( )
zfile . close ( )
yield buf . read ( )
ustring _ re = re . compile ( &quot; ( &#91; \ u0080- \ uffff &#93; ) &quot; )
def javascript _ quote ( s , quote _ double _ quotes = False ) :
msg = ( &quot; django.utils.text.javascript _ quote ( ) is deprecated . &quot; &quot; use django.utils.html.escapejs ( ) instead . &quot; )
warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )
def fix ( match ) :
return &quot; \ \ u % 04x &quot; % ord ( match . Group ( 1 ) )
if type ( s ) = = bytes :
s = s . decode ( &apos; utf-8 &apos; )
elif type ( s ) ! = six . text _ type :
raise TypeError ( s )
s = s . replace ( &apos; \ \ &apos; , &apos; \ \ \ \ &apos; )
s = s . replace ( &apos; \ r &apos; , &apos; \ \ r &apos; )
s = s . replace ( &apos; \ n &apos; , &apos; \ \ n &apos; )
s = s . replace ( &apos; \ t &apos; , &apos; \ \ t &apos; )
s = s . replace ( &quot; &apos; &quot; , &quot; \ \ &apos; &quot; )
s = s . replace ( &apos; &lt; / &apos; , &apos; &lt; \ \ / &apos; )
if quote _ double _ quotes :
s = s . replace ( &apos; &quot; &apos; , &apos; &amp; quot ; &apos; )
return ustring _ re . sub ( fix , s )
javascript _ quote = allow _ lazy ( javascript _ quote , six . text _ type )
smart _ split _ re = re . compile ( r &quot; &quot; &quot; ( ( ? : &#91; ^ \ s &apos; &quot; &#93; * ( ? : ( ? : &quot; ( ? : &#91; ^ &quot; \ \ &#93; &#124; \ \ . ) * &quot; &#124; &apos; ( ? : &#91; ^ &apos; \ \ &#93; &#124; \ \ . ) * &apos; ) &#91; ^ \ s &apos; &quot; &#93; * ) + ) &#124; \ S + ) &quot; &quot; &quot; , re . verbose )
def smart _ split ( text ) :
text = force _ text ( text )
for bit in smart _ split _ re . finditer ( text ) :
yield bit . Group ( 0 )
def _ replace _ entity ( match ) :
text = match . Group ( 1 )
if text &#91; 0 &#93; = = &apos; # &apos; :
text = text &#91; 1 : &#93;
try :
if text &#91; 0 &#93; in &apos; xX &apos; :
c = int ( text &#91; 1 : &#93; , 16 )
else :
c = int ( text )
return six . unichr ( c )
except ValueError :
return match . Group ( 0 )
else :
try :
return six . unichr ( html _ entities . name2codepoint &#91; text &#93; )
except ( ValueError , KeyError ) :
return match . Group ( 0 )
_ entity _ re = re . compile ( r &quot; &amp; ( # ? &#91; xX &#93; ? ( ? : &#91; 0-9a-fA-F &#93; + &#124; \ w { 1,8 } ) ) ; &quot; )
def unescape _ entities ( text ) :
return _ entity _ re . sub ( _ replace _ entity , text )
unescape _ entities = allow _ lazy ( unescape _ entities , six . text _ type )
def unescape _ string _ literal ( s ) :
if s &#91; 0 &#93; not in &quot; \ &quot; &apos; &quot; or s &#91; - 1 &#93; ! = s &#91; 0 &#93; :
raise ValueError ( &quot; Not a string literal : % r &quot; % s )
quote = s &#91; 0 &#93;
return s &#91; 1 : - 1 &#93; . replace ( r &apos; \ % s &apos; % quote , quote ) . replace ( r &apos; \ \ &apos; , &apos; \ \ &apos; )
unescape _ string _ literal = allow _ lazy ( unescape _ string _ literal )
def slugify ( value ) :
value = unicodedata . normalize ( &apos; NFKD &apos; , value ) . encode ( &apos; ascii &apos; , &apos; ignore &apos; ) . decode ( &apos; ascii &apos; )
value = re . sub ( &apos; &#91; ^ \ w \ s- &#93; &apos; , &apos; &apos; , value ) . strip ( ) . lower ( )
return mark _ safe ( re . sub ( &apos; &#91; - \ s &#93; + &apos; , &apos; -&apos; , value ) )
slugify = allow _ lazy ( slugify , six . text _ type )
def camel _ case _ to _ spaces ( value ) :
return re _ camel _ case . sub ( r &apos; \ 1 &apos; , value ) . strip ( ) . lower ( )
from _ _ future _ _ import unicode _ literals
import datetime
from django . utils . html import avoid _ wrapping
from django . utils . timezone import is _ aware , utc
from django . utils . translation import ugettext , ungettext _ lazy
def timesince ( d , now = None , reversed = False ) :
chunks = ( ( 60 * 60 * 24 * 365 , ungettext _ lazy ( &apos; % d year &apos; , &apos; % d years &apos; ) ) , ( 60 * 60 * 24 * 30 , ungettext _ lazy ( &apos; % d month &apos; , &apos; % d months &apos; ) ) , ( 60 * 60 * 24 * 7 , ungettext _ lazy ( &apos; % d week &apos; , &apos; % d weeks &apos; ) ) , ( 60 * 60 * 24 , ungettext _ lazy ( &apos; % d day &apos; , &apos; % d days &apos; ) ) , ( 60 * 60 , ungettext _ lazy ( &apos; % d hour &apos; , &apos; % d hours &apos; ) ) , ( 60 , ungettext _ lazy ( &apos; % d minute &apos; , &apos; % d minutes &apos; ) ) )
if not isinstance ( d , datetime . datetime ) :
d = datetime . datetime ( d . year , d . month , d . day )
if now and not isinstance ( now , datetime . datetime ) :
now = datetime . datetime ( now . year , now . month , now . day )
if not now :
now = datetime . datetime . now ( utc if is _ aware ( d ) else None )
delta = ( d - now ) if reversed else ( now - d )
since = delta . days * 24 * 60 * 60 + delta . seconds
if since &lt; = 0 :
return avoid _ wrapping ( ugettext ( &apos; 0 minutes &apos; ) )
for i , ( seconds , name ) in enumerate ( chunks ) :
count = since / / seconds
if count ! = 0 :
break
result = avoid _ wrapping ( name % count )
if i + 1 &lt; len ( chunks ) :
seconds2 , name2 = chunks &#91; i + 1 &#93;
count2 = ( since - ( seconds * count ) ) / / seconds2
if count2 ! = 0 :
result + = ugettext ( &apos; , &apos; ) + avoid _ wrapping ( name2 % count2 )
return result
def timeuntil ( d , now = None ) :
return timesince ( d , now , reversed = True )
from datetime import datetime , timedelta , tzinfo
from threading import local
import sys
import time as _ time
try :
import pytz
except ImportError :
pytz = None
from django . conf import settings
from django . utils import six
_ _ all _ _ = &#91; &apos; utc &apos; , &apos; get _ fixed _ timezone &apos; , &apos; get _ default _ timezone &apos; , &apos; get _ default _ timezone _ name &apos; , &apos; get _ current _ timezone &apos; , &apos; get _ current _ timezone _ name &apos; , &apos; activate &apos; , &apos; deactivate &apos; , &apos; override &apos; , &apos; localtime &apos; , &apos; now &apos; , &apos; is _ aware &apos; , &apos; is _ naive &apos; , &apos; make _ aware &apos; , &apos; make _ naive &apos; , &#93;
zero = timedelta ( 0 )
class UTC ( tzinfo ) :
def _ _ repr _ _ ( self ) :
return &quot; &lt; UTC &gt; &quot;
def utcoffset ( self , dt ) :
return ZERO
def tzname ( self , dt ) :
return &quot; UTC &quot;
def dst ( self , dt ) :
return ZERO
class FixedOffset ( tzinfo ) :
def _ _ init _ _ ( self , offset = None , name = None ) :
if offset is not None :
self . _ _ offset = timedelta ( minutes = offset )
if name is not None :
self . _ _ name = name
def utcoffset ( self , dt ) :
return self . _ _ offset
def tzname ( self , dt ) :
return self . _ _ name
def dst ( self , dt ) :
return ZERO
class ReferenceLocalTimezone ( tzinfo ) :
def _ _ init _ _ ( self ) :
self . STDOFFSET = timedelta ( seconds = - _ time . timezone )
if _ time . daylight :
self . DSTOFFSET = timedelta ( seconds = - _ time . altzone )
else :
self . DSTOFFSET = self . STDOFFSET
self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET
tzinfo . _ _ init _ _ ( self )
def utcoffset ( self , dt ) :
if self . _ isdst ( dt ) :
return self . DSTOFFSET
else :
return self . STDOFFSET
def dst ( self , dt ) :
if self . _ isdst ( dt ) :
return self . DSTDIFF
else :
return ZERO
def tzname ( self , dt ) :
return _ time . tzname &#91; self . _ isdst ( dt ) &#93;
def _ isdst ( self , dt ) :
tt = ( dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , 0 , 0 )
stamp = _ time . mktime ( tt )
tt = _ time . localtime ( stamp )
return tt . tm _ isdst &gt; 0
class LocalTimezone ( ReferenceLocalTimezone ) :
def tzname ( self , dt ) :
is _ dst = False if dt is None else self . _ isdst ( dt )
return _ time . tzname &#91; is _ dst &#93;
def _ isdst ( self , dt ) :
try :
return super ( LocalTimezone , self ) . _ isdst ( dt )
except ( OverflowError , ValueError ) as exc :
exc _ type = type ( exc )
exc _ value = exc _ type ( &quot; Unsupported value : % r . you should install pytz . &quot; % dt )
exc _ value . _ _ cause _ _ = exc
six . reraise ( exc _ type , exc _ value , sys . exc _ info ( ) &#91; 2 &#93; )
utc = pytz . utc if pytz else UTC ( )
def get _ fixed _ timezone ( offset ) :
if isinstance ( offset , timedelta ) :
offset = offset . seconds / / 60
sign = &apos; -&apos; if offset &lt; 0 else &apos; + &apos;
hhmm = &apos; % 02d % 02d &apos; % divmod ( abs ( offset ) , 60 )
name = sign + hhmm
return FixedOffset ( offset , name )
_ localtime = None
def get _ default _ timezone ( ) :
global _ localtime
if _ localtime is None :
if isinstance ( settings . time _ ZONE , six . string _ types ) and pytz is not None :
_ localtime = pytz . timezone ( settings . time _ ZONE )
else :
_ localtime = LocalTimezone ( )
return _ localtime
def get _ default _ timezone _ name ( ) :
return _ get _ timezone _ name ( get _ default _ timezone ( ) )
_ active = local ( )
def get _ current _ timezone ( ) :
return getattr ( _ active , &quot; value &quot; , get _ default _ timezone ( ) )
def get _ current _ timezone _ name ( ) :
return _ get _ timezone _ name ( get _ current _ timezone ( ) )
def _ get _ timezone _ name ( timezone ) :
try :
return timezone . ZONE
except AttributeError :
return timezone . tzname ( None )
def activate ( timezone ) :
if isinstance ( timezone , tzinfo ) :
_ active . value = timezone
elif isinstance ( timezone , six . string _ types ) and pytz is not None :
_ active . value = pytz . timezone ( timezone )
else :
raise ValueError ( &quot; Invalid timezone : % r &quot; % timezone )
def deactivate ( ) :
if hasattr ( _ active , &quot; value &quot; ) :
del _ active . value
class override ( object ) :
def _ _ init _ _ ( self , timezone ) :
self . timezone = timezone
self . old _ timezone = getattr ( _ active , &apos; value &apos; , None )
def _ _ enter _ _ ( self ) :
if self . timezone is None :
deactivate ( )
else :
activate ( self . timezone )
def _ _ exit _ _ ( self , exc _ type , exc _ value , traceback ) :
if self . old _ timezone is None :
deactivate ( )
else :
_ active . value = self . old _ timezone
def template _ localtime ( value , use _ tz = None ) :
should _ convert = ( isinstance ( value , datetime ) and ( settings . use _ TZ if use _ tz is None else use _ tz ) and not is _ naive ( value ) and getattr ( value , &apos; convert _ to _ local _ time &apos; , True ) )
return localtime ( value ) if should _ convert else value
def localtime ( value , timezone = None ) :
if timezone is None :
timezone = get _ current _ timezone ( )
value = value . astimezone ( timezone )
if hasattr ( timezone , &apos; normalize &apos; ) :
value = timezone . normalize ( value )
return value
def now ( ) :
if settings . use _ TZ :
return datetime . utcnow ( ) . replace ( tzinfo = utc )
else :
return datetime . now ( )
def is _ aware ( value ) :
return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None
def is _ naive ( value ) :
return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None
def make _ aware ( value , timezone ) :
if hasattr ( timezone , &apos; localize &apos; ) :
return timezone . localize ( value , is _ dst = None )
else :
if is _ aware ( value ) :
raise ValueError ( &quot; make _ aware expects a naive datetime , got % s &quot; % value )
return value . replace ( tzinfo = timezone )
def make _ naive ( value , timezone ) :
value = value . astimezone ( timezone )
if hasattr ( timezone , &apos; normalize &apos; ) :
value = timezone . normalize ( value )
return value . replace ( tzinfo = None )
from _ _ future _ _ import unicode _ literals
import re
from django . utils . encoding import force _ text
from django . utils . functional import lazy
from django . utils import six
_ _ all _ _ = &#91; &apos; activate &apos; , &apos; deactivate &apos; , &apos; override &apos; , &apos; deactivate _ all &apos; , &apos; get _ language &apos; , &apos; get _ language _ from _ request &apos; , &apos; get _ language _ info &apos; , &apos; get _ language _ bidi &apos; , &apos; check _ for _ language &apos; , &apos; to _ locale &apos; , &apos; templatize &apos; , &apos; string _ concat &apos; , &apos; gettext &apos; , &apos; gettext _ lazy &apos; , &apos; gettext _ noop &apos; , &apos; ugettext &apos; , &apos; ugettext _ lazy &apos; , &apos; ugettext _ noop &apos; , &apos; ngettext &apos; , &apos; ngettext _ lazy &apos; , &apos; ungettext &apos; , &apos; ungettext _ lazy &apos; , &apos; pgettext &apos; , &apos; pgettext _ lazy &apos; , &apos; npgettext &apos; , &apos; npgettext _ lazy &apos; , &apos; LANGUAGE _ SESSION _ KEY &apos; , &#93;
language _ SESSION _ KEY = &apos; _ language&apos;
class TranslatorCommentWarning ( SyntaxWarning ) :
pass
class Trans ( object ) :
def _ _ getattr _ _ ( self , real _ name ) :
from django . conf import settings
if settings . use _ I18N :
from django . utils . translation import trans _ real as trans
else :
from django . utils . translation import trans _ null as trans
setattr ( self , real _ name , getattr ( trans , real _ name ) )
return getattr ( trans , real _ name )
_ trans = Trans ( )
del Trans
def gettext _ noop ( message ) :
return _ trans . gettext _ noop ( message )
ugettext _ noop = gettext _ noop
def gettext ( message ) :
return _ trans . gettext ( message )
def ngettext ( singular , plural , number ) :
return _ trans . ngettext ( singular , plural , number )
def ugettext ( message ) :
return _ trans . ugettext ( message )
def ungettext ( singular , plural , number ) :
return _ trans . ungettext ( singular , plural , number )
def pgettext ( context , message ) :
return _ trans . pgettext ( context , message )
def npgettext ( context , singular , plural , number ) :
return _ trans . npgettext ( context , singular , plural , number )
gettext _ lazy = lazy ( gettext , str )
ugettext _ lazy = lazy ( ugettext , six . text _ type )
pgettext _ lazy = lazy ( pgettext , six . text _ type )
def lazy _ number ( func , resultclass , number = None , * * kwargs ) :
if isinstance ( number , int ) :
kwargs &#91; &apos; number &apos; &#93; = number
proxy = lazy ( func , resultclass ) ( * * kwargs )
else :
class NumberAwareString ( resultclass ) :
def _ _ mod _ _ ( self , rhs ) :
if isinstance ( rhs , dict ) and number :
try :
number _ value = rhs &#91; number &#93;
except KeyError :
raise KeyError ( &apos; Your dictionary lacks key \ &apos; % s \ &apos; . &apos; &apos; Please provide it , because it is required to &apos; &apos; determine whether string is singular or plural . &apos; % number )
else :
number _ value = rhs
kwargs &#91; &apos; number &apos; &#93; = number _ value
translated = func ( * * kwargs )
try :
translated = translated % rhs
except TypeError :
pass
return translated
proxy = lazy ( lambda * * kwargs : NumberAwareString ( ) , NumberAwareString ) ( * * kwargs )
return proxy
def ngettext _ lazy ( singular , plural , number = None ) :
return lazy _ number ( ngettext , str , singular = singular , plural = plural , number = number )
def ungettext _ lazy ( singular , plural , number = None ) :
return lazy _ number ( ungettext , six . text _ type , singular = singular , plural = plural , number = number )
def npgettext _ lazy ( context , singular , plural , number = None ) :
return lazy _ number ( npgettext , six . text _ type , context = context , singular = singular , plural = plural , number = number )
def activate ( language ) :
return _ trans . activate ( language )
def deactivate ( ) :
return _ trans . deactivate ( )
class override ( object ) :
def _ _ init _ _ ( self , language , deactivate = False ) :
self . language = language
self . deactivate = deactivate
self . old _ language = get _ language ( )
def _ _ enter _ _ ( self ) :
if self . language is not None :
activate ( self . language )
else :
deactivate _ all ( )
def _ _ exit _ _ ( self , exc _ type , exc _ value , traceback ) :
if self . deactivate :
deactivate ( )
else :
activate ( self . old _ language )
def get _ language ( ) :
return _ trans . get _ language ( )
def get _ language _ bidi ( ) :
return _ trans . get _ language _ bidi ( )
def check _ for _ language ( lang _ code ) :
return _ trans . check _ for _ language ( lang _ code )
def to _ locale ( language ) :
return _ trans . to _ locale ( language )
def get _ language _ from _ request ( request , check _ path = False ) :
return _ trans . get _ language _ from _ request ( request , check _ path )
def get _ language _ from _ path ( path ) :
return _ trans . get _ language _ from _ path ( path )
def templatize ( src , origin = None ) :
return _ trans . templatize ( src , origin )
def deactivate _ all ( ) :
return _ trans . deactivate _ all ( )
def _ string _ concat ( * strings ) :
return &apos; &apos; . join ( force _ text ( s ) for s in strings )
string _ concat = lazy ( _ string _ concat , six . text _ type )
def get _ language _ info ( lang _ code ) :
from django . conf . locale import LANG _ INFO
try :
return LANG _ INFO &#91; lang _ code &#93;
except KeyError :
if &apos; -&apos; not in lang _ code :
raise KeyError ( &quot; Unknown language code % s . &quot; % lang _ code )
generic _ lang _ code = lang _ code . split ( &apos; -&apos; ) &#91; 0 &#93;
try :
return LANG _ INFO &#91; generic _ lang _ code &#93;
except KeyError :
raise KeyError ( &quot; Unknown language code % s and % s . &quot; % ( lang _ code , generic _ lang _ code ) )
trim _ whitespace _ re = re . compile ( &apos; \ s * \ n \ s * &apos; )
def trim _ whitespace ( s ) :
return trim _ whitespace _ re . sub ( &apos; &apos; , s . strip ( ) )
from django . conf import settings
from django . utils . encoding import force _ text
from django . utils . SafeString import mark _ safe , SafeData
def ngettext ( singular , plural , number ) :
if number = = 1 :
return singular
return plural
ngettext _ lazy = ngettext
def ungettext ( singular , plural , number ) :
return force _ text ( ngettext ( singular , plural , number ) )
def pgettext ( context , message ) :
return ugettext ( message )
def npgettext ( context , singular , plural , number ) :
return ungettext ( singular , plural , number )
activate = lambda x : None
deactivate = deactivate _ all = lambda : None
get _ language = lambda : settings . language _ CODE
get _ language _ bidi = lambda : settings . language _ CODE in settings . LANGUAGES _ BIDI
check _ for _ language = lambda x : true
def gettext ( message ) :
if isinstance ( message , SafeData ) :
return mark _ safe ( message )
return message
def ugettext ( message ) :
return force _ text ( gettext ( message ) )
gettext _ noop = gettext _ lazy = _ = gettext
def to _ locale ( language ) :
p = language . find ( &apos; -&apos; )
if p &gt; = 0 :
return language &#91; : p &#93; . lower ( ) + &apos; _ &apos; + language &#91; p + 1 : &#93; . upper ( )
else :
return language . lower ( )
def get _ language _ from _ request ( request , check _ path = False ) :
return settings . language _ CODE
def get _ language _ from _ path ( request ) :
return None
from _ _ future _ _ import unicode _ literals
from collections import OrderedDict
import os
import re
import sys
import gettext as gettext _ module
from threading import local
import warnings
from django . apps import apps
from django . conf import settings
from django . core . exceptions import AppRegistryNotReady
from django . dispatch import receiver
from django . test . signals import setting _ changed
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . encoding import force _ text
from django . utils . _ os import upath
from django . utils . SafeString import mark _ safe , SafeData
from django . utils import six , lru _ cache
from django . utils . six import StringIO
from django . utils . translation import TranslatorCommentWarning , trim _ whitespace , LANGUAGE _ SESSION _ KEY
_ translations = { }
_ active = local ( )
_ default = None
_ supported = None
context _ SEPARATOR = &quot; \ x04 &quot;
accept _ language _ re = re . compile ( r &apos; &apos; &apos; ( &#91; A-Za-z &#93; { 1,8 } ( ? : - &#91; A-Za-z0-9 &#93; { 1,8 } ) * &#124; \ * ) # &quot; en &quot; , &quot; en-au &quot; , &quot; x-y-z &quot; , &quot; es-419 &quot; , &quot; * &quot; ( ? : \ s * ; \ s * q = ( 0 ( ? : \ . \ d { , 3 } ) ? &#124; 1 ( ? : .0 { , 3 } ) ? ) ) ? # Optional &quot; q = 1.00 &quot; , &quot; q = 0.8 &quot; ( ? : \ s * , \ s * &#124; $ ) # Multiple accepts per header . &apos; &apos;&apos; , re . verbose )
language _ code _ re = re . compile ( r &apos; ^ &#91; a-z &#93; { 1,8 } ( ? : - &#91; a-z0-9 &#93; { 1,8 } ) * $ &apos; , re . IGNORECASE )
language _ code _ prefix _ re = re . compile ( r &apos; ^ / ( &#91; \ w- &#93; + ) ( / &#124; $ ) &apos; )
_ BROWSERS _ DEPRECATED _ LOCALES = { &apos; zh-cn &apos; : &apos; zh-hans &apos; , &apos; zh-tw &apos; : &apos; zh-hant &apos; , }
_ DJANGO _ DEPRECATED _ LOCALES = _ BROWSERS _ DEPRECATED _ LOCALES
@ receiver ( setting _ changed )
def reset _ cache ( * * kwargs ) :
if kwargs &#91; &apos; setting &apos; &#93; in ( &apos; LANGUAGES &apos; , &apos; LANGUAGE _ CODE &apos; ) :
global _ supported
_ supported = None
check _ for _ language . cache _ clear ( )
get _ supported _ language _ variant . cache _ clear ( )
def to _ locale ( language , to _ lower = False ) :
p = language . find ( &apos; -&apos; )
if p &gt; = 0 :
if to _ lower :
return language &#91; : p &#93; . lower ( ) + &apos; _ &apos; + language &#91; p + 1 : &#93; . lower ( )
else :
if len ( language &#91; p + 1 : &#93; ) &gt; 2 :
return language &#91; : p &#93; . lower ( ) + &apos; _ &apos; + language &#91; p + 1 &#93; . upper ( ) + language &#91; p + 2 : &#93; . lower ( )
return language &#91; : p &#93; . lower ( ) + &apos; _ &apos; + language &#91; p + 1 : &#93; . upper ( )
else :
return language . lower ( )
def to _ language ( locale ) :
p = locale . find ( &apos; _ &apos; )
if p &gt; = 0 :
return locale &#91; : p &#93; . lower ( ) + &apos; -&apos; + locale &#91; p + 1 : &#93; . lower ( )
else :
return locale . lower ( )
class DjangoTranslation ( gettext _ module . GNUTranslations ) :
def _ _ init _ _ ( self , language ) :
gettext _ module . GNUTranslations . _ _ init _ _ ( self )
self . _ _ language = language
self . _ _ to _ language = to _ language ( language )
self . _ _ locale = to _ locale ( language )
self . plural = lambda n : int ( n ! = 1 )
self . _ init _ translation _ catalog ( )
self . _ add _ installed _ apps _ translations ( )
self . _ add _ local _ translations ( )
self . _ add _ fallback ( )
def _ _ repr _ _ ( self ) :
return &quot; &lt; DjangoTranslation lang : % s &gt; &quot; % self . _ _ language
def _ new _ gnu _ trans ( self , localedir , use _ null _ fallback = True ) :
translation = gettext _ module . translation ( domain = &apos; django &apos; , localedir = localedir , languages = &#91; self . _ _ locale &#93; , codeset = &apos; utf-8 &apos; , fallback = use _ null _ fallback )
if not hasattr ( translation , &apos; _ catalog &apos; ) :
translation . _ catalog = { }
translation . _ info = { }
return translation
def _ init _ translation _ catalog ( self ) :
settingsfile = upath ( sys . modules &#91; settings . _ _ module _ _ &#93; . _ _ file _ _ )
localedir = os . path . join ( os . path . dirname ( settingsfile ) , &apos; locale &apos; )
use _ null _ fallback = True
if self . _ _ language = = settings . language _ CODE :
use _ null _ fallback = False
translation = self . _ new _ gnu _ trans ( localedir , use _ null _ fallback )
self . _ info = translation . _ info . copy ( )
self . _ catalog = translation . _ catalog . copy ( )
def _ add _ installed _ apps _ translations ( self ) :
try :
app _ configs = reversed ( list ( apps . get _ app _ configs ( ) ) )
except AppRegistryNotReady :
raise AppRegistryNotReady ( &quot; The translation infrastructure cannot be initialized before the &quot; &quot; apps registry is ready . check that you don &apos;t make non-lazy &quot; &quot; gettext calls at import time . &quot; )
for app _ config in app _ configs :
localedir = os . path . join ( app _ config . path , &apos; locale &apos; )
translation = self . _ new _ gnu _ trans ( localedir )
self . merge ( translation )
def _ add _ local _ translations ( self ) :
for localedir in reversed ( settings . locale _ PATHS ) :
translation = self . _ new _ gnu _ trans ( localedir )
self . merge ( translation )
def _ add _ fallback ( self ) :
if self . _ _ language = = settings . language _ CODE or self . _ _ language = = &quot; en-us &quot; :
return
default _ translation = translation ( settings . language _ CODE )
self . add _ fallback ( default _ translation )
def merge ( self , other ) :
self . _ catalog . update ( other . _ catalog )
def language ( self ) :
return self . _ _ language
def to _ language ( self ) :
return self . _ _ to _ language
def translation ( language ) :
global _ translations
if language not in _ translations :
_ translations &#91; language &#93; = DjangoTranslation ( language )
return _ translations &#91; language &#93;
def activate ( language ) :
if language in _ DJANGO _ DEPRECATED _ LOCALES :
msg = ( &quot; The use of the language code &apos; % s &apos; is deprecated . &quot; &quot; Please use the &apos; % s &apos; translation instead . &quot; )
warnings . warn ( msg % ( language , _ DJANGO _ DEPRECATED _ LOCALES &#91; language &#93; ) , RemovedInDjango19Warning , stacklevel = 2 )
_ active . value = translation ( language )
def deactivate ( ) :
if hasattr ( _ active , &quot; value &quot; ) :
del _ active . value
def deactivate _ all ( ) :
_ active . value = gettext _ module . NullTranslations ( )
def get _ language ( ) :
t = getattr ( _ active , &quot; value &quot; , None )
if t is not None :
try :
return t . to _ language ( )
except AttributeError :
pass
return settings . language _ CODE
def get _ language _ bidi ( ) :
base _ lang = get _ language ( ) . split ( &apos; -&apos; ) &#91; 0 &#93;
return base _ lang in settings . LANGUAGES _ BIDI
def catalog ( ) :
global _ default
t = getattr ( _ active , &quot; value &quot; , None )
if t is not None :
return t
if _ default is None :
_ default = translation ( settings . language _ CODE )
return _ default
def do _ translate ( message , translation _ function ) :
global _ default
eol _ message = message . replace ( str ( &apos; \ r \ n &apos; ) , str ( &apos; \ n &apos; ) ) . replace ( str ( &apos; \ r &apos; ) , str ( &apos; \ n &apos; ) )
t = getattr ( _ active , &quot; value &quot; , None )
if t is not None :
result = getattr ( t , translation _ function ) ( eol _ message )
else :
if _ default is None :
_ default = translation ( settings . language _ CODE )
result = getattr ( _ default , translation _ function ) ( eol _ message )
if isinstance ( message , SafeData ) :
return mark _ safe ( result )
return result
def gettext ( message ) :
return do _ translate ( message , &apos; gettext &apos; )
if six . PY3 :
ugettext = gettext
else :
def ugettext ( message ) :
return do _ translate ( message , &apos; ugettext &apos; )
def pgettext ( context , message ) :
msg _ with _ ctxt = &quot; % s % s % s &quot; % ( context , CONTEXT _ SEPARATOR , message )
result = ugettext ( msg _ with _ ctxt )
if CONTEXT _ SEPARATOR in result :
result = force _ text ( message )
return result
def gettext _ noop ( message ) :
return message
def do _ ntranslate ( singular , plural , number , translation _ function ) :
global _ default
t = getattr ( _ active , &quot; value &quot; , None )
if t is not None :
return getattr ( t , translation _ function ) ( singular , plural , number )
if _ default is None :
_ default = translation ( settings . language _ CODE )
return getattr ( _ default , translation _ function ) ( singular , plural , number )
def ngettext ( singular , plural , number ) :
return do _ ntranslate ( singular , plural , number , &apos; ngettext &apos; )
if six . PY3 :
ungettext = ngettext
else :
def ungettext ( singular , plural , number ) :
return do _ ntranslate ( singular , plural , number , &apos; ungettext &apos; )
def npgettext ( context , singular , plural , number ) :
msgs _ with _ ctxt = ( &quot; % s % s % s &quot; % ( context , CONTEXT _ SEPARATOR , singular ) , &quot; % s % s % s &quot; % ( context , CONTEXT _ SEPARATOR , plural ) , number )
result = ungettext ( * msgs _ with _ ctxt )
if CONTEXT _ SEPARATOR in result :
result = ungettext ( singular , plural , number )
return result
def all _ locale _ paths ( ) :
globalpath = os . path . join ( os . path . dirname ( upath ( sys . modules &#91; settings . _ _ module _ _ &#93; . _ _ file _ _ ) ) , &apos; locale &apos; )
return &#91; globalpath &#93; + list ( settings . locale _ PATHS )
@ lru _ cache . lru _ cache ( maxsize = 1000 )
def check _ for _ language ( lang _ code ) :
if not language _ code _ re . search ( lang _ code ) :
return False
for path in all _ locale _ paths ( ) :
if gettext _ module . find ( &apos; django &apos; , path , &#91; to _ locale ( lang _ code ) &#93; ) is not None :
return True
return False
@ lru _ cache . lru _ cache ( maxsize = 1000 )
def get _ supported _ language _ variant ( lang _ code , strict = False ) :
global _ supported
if _ supported is None :
_ supported = OrderedDict ( settings . LANGUAGES )
if lang _ code :
replacement = _ BROWSERS _ DEPRECATED _ LOCALES . get ( lang _ code )
if lang _ code not in _ supported and replacement in _ supported :
return replacement
generic _ lang _ code = lang _ code . split ( &apos; -&apos; ) &#91; 0 &#93;
for code in ( lang _ code , generic _ lang _ code ) :
if code in _ supported and check _ for _ language ( code ) :
return code
if not strict :
for supported _ code in _ supported :
if supported _ code . startswith ( generic _ lang _ code + &apos; -&apos; ) :
return supported _ code
raise LookupError ( lang _ code )
def get _ language _ from _ path ( path , strict = False ) :
regex _ match = language _ code _ prefix _ re . match ( path )
if not regex _ match :
return None
lang _ code = regex _ match . Group ( 1 )
try :
return get _ supported _ language _ variant ( lang _ code , strict = strict )
except LookupError :
return None
def get _ language _ from _ request ( request , check _ path = False ) :
global _ supported
if _ supported is None :
_ supported = OrderedDict ( settings . LANGUAGES )
if check _ path :
lang _ code = get _ language _ from _ path ( request . path _ info )
if lang _ code is not None :
return lang _ code
if hasattr ( request , &apos; session &apos; ) :
lang _ code = request . SESSION . get ( LANGUAGE _ SESSION _ KEY )
if lang _ code in _ supported and lang _ code is not None and check _ for _ language ( lang _ code ) :
return lang _ code
lang _ code = request . cookies . get ( settings . language _ COOKIE _ NAME )
try :
return get _ supported _ language _ variant ( lang _ code )
except LookupError :
pass
accept = request . meta . get ( &apos; HTTP _ ACCEPT _ LANGUAGE &apos; , &apos; &apos; )
for accept _ lang , unused in parse _ accept _ lang _ header ( accept ) :
if accept _ lang = = &apos; * &apos; :
break
if not language _ code _ re . search ( accept _ lang ) :
continue
try :
return get _ supported _ language _ variant ( accept _ lang )
except LookupError :
continue
try :
return get _ supported _ language _ variant ( settings . language _ CODE )
except LookupError :
return settings . language _ CODE
dot _ re = re . compile ( r &apos; \ S &apos; )
def blankout ( src , char ) :
return dot _ re . sub ( char , src )
context _ re = re . compile ( r &quot; &quot; &quot; ^ \ s + . * context \ s + ( ( ? : &quot; &#91; ^ &quot; &#93; * ? &quot; ) &#124; ( ? : &apos; &#91; ^ &apos; &#93; * ? &apos; ) ) \ s * &quot; &quot; &quot; )
inline _ re = re . compile ( r &quot; &quot; &quot; ^ \ s * trans \ s + ( ( ? : &quot; &#91; ^ &quot; &#93; * ? &quot; ) &#124; ( ? : &apos; &#91; ^ &apos; &#93; * ? &apos; ) ) ( \ s + . * context \ s + ( ( ? : &quot; &#91; ^ &quot; &#93; * ? &quot; ) &#124; ( ? : &apos; &#91; ^ &apos; &#93; * ? &apos; ) ) ) ? \ s * &quot; &quot; &quot; )
block _ re = re . compile ( r &quot; &quot; &quot; ^ \ s * blocktrans ( \ s + . * context \ s + ( ( ? : &quot; &#91; ^ &quot; &#93; * ? &quot; ) &#124; ( ? : &apos; &#91; ^ &apos; &#93; * ? &apos; ) ) ) ? ( ? : \ s + &#124; $ ) &quot; &quot; &quot; )
endblock _ re = re . compile ( r &quot; &quot; &quot; ^ \ s * endblocktrans $ &quot; &quot; &quot; )
plural _ re = re . compile ( r &quot; &quot; &quot; ^ \ s * plural $ &quot; &quot; &quot; )
constant _ re = re . compile ( r &quot; &quot; &quot; _ \ ( ( ( ? : &quot; . * ? &quot; ) &#124; ( ? : &apos; . * ? &apos; ) ) \ ) &quot; &quot; &quot; )
one _ percent _ re = re . compile ( r &quot; &quot; &quot; ( ? &lt; ! % ) % ( ? ! % ) &quot; &quot; &quot; )
def templatize ( src , origin = None ) :
from django . template import ( Lexer , TOKEN _ TEXT , TOKEN _ VAR , TOKEN _ BLOCK , TOKEN _ COMMENT , TRANSLATOR _ COMMENT _ MARK )
src = force _ text ( src , settings . file _ CHARSET )
out = StringIO ( &apos; &apos; )
message _ context = None
intrans = False
inplural = False
trimmed = False
singular = &#91; &#93;
plural = &#91; &#93;
incomment = False
COMMENT = &#91; &#93;
lineno _ comment _ map = { }
COMMENT _ lineno _ cache = None
